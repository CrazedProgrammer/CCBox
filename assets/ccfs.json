{"rom":{"LICENSE":"ComputerCraft Public License\n============================\n\nVersion 1.0.0 (Based on Minecraft Mod Public License 1.0.1)\n\n0. Definitions\n--------------\n\nMinecraft: Denotes a copy of the PC Java version of the game \u201CMinecraft\u201D licensed by Mojang AB\n\nUser: Anybody that interacts with the software in one of the following ways:\n   - play\n   - decompile\n   - recompile or compile\n   - modify\n   - distribute\n\nMod: The mod code designated by the present license, in source form, binary\nform, as obtained standalone, as part of a wider distribution or resulting from\nthe compilation of the original or modified sources.\n\nDependency: Code required for the mod to work properly. This includes \ndependencies required to compile the code as well as any file or modification\nthat is explicitly or implicitly required for the mod to be working.\n\n1. Scope\n--------\n\nThe present license is granted to any user of the mod. As a prerequisite, \na user must own a legally acquired copy of Minecraft\n\n2. Liability\n------------\n\nThis mod is provided 'as is' with no warranties, implied or otherwise. The owner\nof this mod takes no responsibility for any damages incurred from the use of\nthis mod. This mod alters fundamental parts of the Minecraft game, parts of\nMinecraft may not work with this mod installed. All damages caused from the use\nor misuse of this mod fall on the user.\n\n3. Play rights\n--------------\n\nThe user is allowed to install this mod on a Minecraft client or server and to play \nwithout restriction.\n\n4. Modification rights\n----------------------\n\nThe user has the right to decompile the source code, look at either the \ndecompiled version or the original source code, and to modify it.\n\n5. Distribution of original or modified copy rights\n---------------------------------------------------\n\nIs subject to distribution rights this entire mod in its various forms. This\ninclude:\n   - original binary or source forms of this mod files\n   - modified versions of these binaries or source files, as well as binaries\n     resulting from source modifications\n   - patch to its source or binary files\n   - any copy of a portion of its binary source files\n\nThe user is allowed to redistribute this mod partially, in totality, or \nincluded in a distribution.\n\nWhen distributing binary files, the user must provide means to obtain its \nentire set of sources or modified sources at no cost.\n\nAll distributions of this mod must remain licensed under the CCPL.\n\nAll dependencies that this mod have on other mods or classes must be licensed\nunder conditions comparable to this version of CCPL, with the exception of the\nMinecraft code and the mod loading framework (e.g. Forge).\n\nModified version of binaries and sources, as well as files containing sections\ncopied from this mod, should be distributed under the terms of the present\nlicense.\n\n7. Use of mod code and assets in other projects\n-----------------------------------------------\n\nIt is permitted to use the code and assets contained in this mod (and modified\nversions thereof) in other Minecraft Mods, provided they are non-commercial.\nHowever: the code and assets may not be used in commercial mods, mods for other\ngames, other games, other non-game projects, or any commercial projects.\n\nWhen using code covered by this license in other projects, the source code used\nmust be made available at no cost and remain licensed under the CCPL.\n\n8. Contributing\n---------------\n\nIf you choose to contribute code or assets to be included in this mod, you\nagree that, if added to to the main repository at \nhttps:\/\/github.com\/dan200\/ComputerCraft, your contributions will be covered by\nthis license, and that Daniel Ratcliffe will retain the right to re-license the\nmod, including your contributions, in part or in whole, under other licenses.\n","modules":{"command":{".ignoreme":"--[[\nAlright then, don't ignore me. This file is to ensure the existence of the \"modules/command\" folder.\nYou can use this folder to add modules who can be loaded with require() to your Resourcepack.\n]]"},"main":{".ignoreme":"--[[\nAlright then, don't ignore me. This file is to ensure the existence of the \"modules/main\" folder.\nYou can use this folder to add modules who can be loaded with require() to your Resourcepack.\n]]"},"turtle":{".ignoreme":"--[[\nAlright then, don't ignore me. This file is to ensure the existence of the \"modules/turtle\" folder.\nYou can use this folder to add modules who can be loaded with require() to your Resourcepack.\n]]"}},"help":{"intro.txt":"Welcome to CraftOS!\nType \"programs\" to see the programs you can run.\nType \"help <program>\" to see help for a specific program.\nType \"help programming\" to learn about programming.\nType \"help whatsnew\" to find out about new features.\nType \"help credits\" to learn who made all this.\nType \"help index\" to see all help topics.","rename.txt":"rename renames a file or directory.\n\nex:\n\"rename foo bar\" renames the file \"foo\" to \"bar\".","monitor.txt":"monitor will connect to an attached Monitor peripheral, and run a program on its display.\nType \"help monitors\" for help using monitors as peripherals in lua programs.\n\nex:\n\"monitor left hello\" will run the \"hello\" program on the monitor to the left of the computer.\n\"monitor top edit foo\" will run the edit program on the top monitor, editing the file \"foo\".","dj.txt":"dj plays Music Discs from disk drives attached to the computer.\n\nex:\n\"dj\" or \"dj play\" plays a random disc.\n\"dj play left\" plays the disc in the drive on the left of the computer.\n\"dj stop\" stops the current disc.","dance.txt":"dance is a program for Turtles. Turtles love to get funky.","adventure.txt":"adventure is a text adventure game for CraftOS. To navigate around the world of adventure, type simple instructions to the interpreter, for example: \"go north\", \"punch tree\", \"craft planks\", \"mine coal with pickaxe\", \"hit creeper with sword\"","hello.txt":"hello prints the text \"Hello World!\" to the screen.","peripherals.txt":"The \"peripherals\" program will list all of the peripheral devices accessible from this computer.\nPeripherals are external devices which CraftOS Computers and Turtles can interact with using the peripheral API.\nType \"help peripheral\" to learn about using the peripheral API.\nType \"help drives\" to learn about using Disk Drives.\nType \"help modems\" to learn about using Modems.\nType \"help monitors\" to learn about using Monitors.\nType \"help printers\" to learn about using Printers.","table.txt":"table is a standard Lua5.1 API.\nRefer to http://www.lua.org/manual/5.1/ for more information.","repeat.txt":"repeat is a program for repeating rednet messages across long distances. To use, connect 2 or more modems to a computer and run the \"repeat\" program; from then on, any rednet message sent from any computer in wireless range or connected by networking cable to either of the modems will be repeated to those on the other side.","drives.txt":"The Disk Drive is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Disk Drive is connected, peripheral.getType() will return \"drive\".\n\nMethods exposed by the Disk Drive:\nisDiskPresent()\ngetDiskLabel()\nsetDiskLabel( label )\nhasData()\ngetMountPath()\nhasAudio()\ngetAudioTitle()\nplayAudio()\nstopAudio()\nejectDisk()\ngetDiskID()\n\nEvents fired by the Disk Drive:\n\"disk\" when a disk or other item is inserted into the drive. Argument is the name of the drive.\n\"disk_eject\" when a disk is removed from a  drive. Argument is the name of the drive.\nType \"help events\" to learn about the event system.","commands.txt":"On a Command Computer, \"commands\" will list all the commands available for use. Use \"exec\" to execute them.\nType \"help commandsapi\" for help using commands in lua programs.","shellapi.txt":"Functions in the Shell API:\nshell.exit()\nshell.dir()\nshell.setDir( path )\nshell.path()\nshell.setPath( path )\nshell.resolve( localpath )\nshell.resolveProgram( name )\nshell.aliases()\nshell.setAlias( alias, command )\nshell.clearAlias( alias )\nshell.programs()\nshell.run( program, arguments )\nshell.getRunningProgram()\nshell.complete( line )\nshell.completeProgram( program )\nshell.setCompletionFunction( program, fnComplete )\nshell.openTab( program, arguments ) (Advanced Computer required)\nshell.switchTab( n ) (Advanced Computer required)","events.txt":"The function os.pullEvent() will yield the program until a system event occurs. The first return value is the event name, followed by any arguments.\n\nSome events which can occur are:\n\"char\" when text is typed on the keyboard. Argument is the character typed.\n\"key\" when a key is pressed on the keyboard. Arguments are the keycode and whether the key is a repeat. Compare the keycode to the values in keys API to see which key was pressed.\n\"key_up\" when a key is released on the keyboard. Argument is the numerical keycode. Compare to the values in keys API to see which key was released.\n\"paste\" when text is pasted from the users keyboard. Argument is the line of text pasted.\n\nEvents only on advanced computers:\n\"mouse_click\" when a user clicks the mouse. Arguments are button, xPos, yPos.\n\"mouse_drag\" when a user moves the mouse when held. Arguments are button, xPos, yPos.\n\"mouse_up\" when a user releases the mouse button. Arguments are button, xPos, yPos.\n\"mouse_scroll\" when a user uses the scrollwheel on the mouse. Arguments are direction, xPos, yPos.\n\nOther APIs and peripherals will emit their own events. See their respective help pages for details.","falling.txt":"\"From Russia with Fun\" comes a fun, new, suspiciously-familiar falling block game for CraftOS. Only on Pocket Computers!","bit.txt":"Functions in the bit manipulation API (NOTE: This API will be removed in a future version. Use bit32 instead):\nbit.bnot(n)          -- bitwise not (~n)\nbit.band(m, n)       -- bitwise and (m & n)\nbit.bor(m, n)        -- bitwise or (m | n)\nbit.bxor(m, n)       -- bitwise xor (m ^ n)\nbit.brshift(n, bits) -- right shift (n >> bits)\nbit.blshift(n, bits) -- left shift (n << bits)","shutdown.txt":"shutdown will turn off the computer.","apis.txt":"apis lists the currently loaded APIs available to programs in CraftOS.\n\nType \"help <api>\" to see help for a specific api.\nCall os.loadAPI( path ) to load extra apis.","colours.txt":"Functions in the colours api\n(used for redstone.setBundledOutput):\ncolours.combine( colour1, colour2, colour3, ...)\ncolours.subtract( colours, colour1, colour2, ...)\ncolours.test( colours, colour )\ncolours.rgb8( r, g, b )\n\nColour constants in the colours api, in ascending bit order:\ncolours.white, colours.orange, colours.magenta, colours.lightBlue, colours.yellow, colours.lime, colours.pink, colours.grey, colours.lightGrey, colours.cyan, colours.purple, colours.blue, colours.brown, colours.green, colours.red, colours.black.","commandsapi.txt":"Functions in the commands API:\ncommands.exec( command )\ncommands.execAsync( command )\ncommands.list()\ncommands.getBlockPosition()\ncommands.getBlockInfo( x, y, z )\ncommands.getBlockInfos( minx, miny, minz, maxx, maxy, maxz )\n\nThe commands API can also be used to invoke commands directly, like so:\ncommands.say( \"Hello World\" )\ncommands.give( \"dan200\", \"minecraft:diamond\", 64 )\nThis works with any command. Use \"commands.async\" instead of \"commands\" to execute asynchronously.\n\nThe commands API is only available on Command Computers.\nVisit http://minecraft.gamepedia.com/Commands for documentation on all commands.","earth.txt":"Mostly harmless.","label.txt":"label gets or sets the label of the Computer, or of Floppy Disks in attached disk drives.\n\nex:\n\"label get\" prints the label of the computer.\n\"label get left\" prints the label of the disk in the left drive.\n\"label set \"My Computer\"\" set the label of the computer to \"My Computer\".\n\"label set left \"My Programs\"\" - sets the label of the disk in the left drive to \"My Programs\".\n\"label clear\" clears the label of the computer.\n\"label clear left\" clears the label of the disk in the left drive.","helpapi.txt":"Functions in the help API:\nhelp.setPath( path )\nhelp.lookup( topic )\nhelp.topics()\nhelp.completeTopic( topic )","worm.txt":"You've played it in the arcades, now experience the high-octane thrills of the hit game \"WORM!\" on your home computer! Only on CraftOS!","eject.txt":"eject ejects the contents of an attached disk drive.\n\nex:\n\"eject left\" ejects the contents of the disk drive to the left of the computer.","workbench.txt":"Workbenches are peripheral devices found on Crafty Turtles running CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a workbench is attached to a turtle, peripheral.getType() will return \"workbench\".\n\nMethods exposed by Workbenches:\ncraft( channel )","reboot.txt":"reboot will turn the computer off and on again.\nYou can also hold Ctrl+R at any time to quickly reboot.","pocket.txt":"pocket is an API available on pocket computers, which allows modifying its upgrades.\nFunctions in the pocket API:\npocket.equipBack()\npocket.unequipBack()\n\nWhen equipping upgrades, it will search your inventory for a suitable upgrade, starting in the selected slot. If one cannot be found then it will check your offhand.","time.txt":"time prints the current time of day.","window.txt":"Functions in the window API:\nwindow.create( parent, x, y, width, height, visible )\n\nWindows created with the window API have the following methods:\nwrite( text )\nblit( text, textColor, backgroundColor )\nclear()\nclearLine()\ngetCursorPos()\nsetCursorPos( x, y )\nsetCursorBlink( blink )\nisColor()\nsetTextColor( color )\nsetBackgroundColor( color )\ngetTextColor()\ngetBackgroundColor()\ngetSize()\nscroll( n )\nsetVisible( bVisible )\nredraw()\nrestoreCursor()\ngetPosition()\nreposition( x, y, width, height )\ngetPaletteColor( color )\nsetPaletteColor( color, r, g, b )","whatsnew.txt":"New Features in ComputerCraft 1.80:\n\n* Added .getResponseHeaders() to HTTP responses.\n* Return a HTTP response when a HTTP error occurs.\n* Added a GUI to change ComputerCraft config options.\n* os.time() and os.day() now accept parameters to give the real world time.\n* Added os.epoch()\n* Monitor text now glows in the dark.\n* Added a \"Pocket Computer upgrade API\" so mod developers can add their own pocket upgrades.\n* Added pocket.equipBack()/pocket.unequipBack() to add/remove pocket upgrades.\n* Added term.setPaletteColor()/term.getPaletteColor() to change/check colors\n* Added colors.rgb8()/colours.rgb8() \n* Performance improvements to fs.find\n* Requires the player to be interacting with the computer when typing\n* Disk labels are limited to 32 characters\n* Labels can now only include characters within the printable range ( to ~)\n* Various model improvements\n* There is now a configurable file descriptor limit\n* Threads are now daemon threads\n* Termination signals are now sent unless the computer is off\n* Fixed compilation errors\n* Now handles tile entity changes\n* GPS coordinates now have to be numbers\n* Turtle upgrades now act as tools and peripherals\n* The Filesystem.list result is now sorted\n* The number of values to unpack can now be manually specified\n* Small terminal & monitor rendering improvements\n* General improvements to the documentation\n* Redstone inputs are no longer reset when adding peripherals\n* Turtles now use tinting\n* shell.resolveProgram now picks up on *.lua files\n* Fixed a handful of bugs in ComputerCraft\n* Added speaker block, turtle upgrade, pocket upgrade, and peripheral api\n* Startup can now be a directory containing multiple startup files\n* Added .getLabel to the computer peripheral\n\nType \"help changelog\" to see the full version history.","changelog.txt":"New Features in ComputerCraft 1.80:\n\n* Added .getResponseHeaders() to HTTP responses.\n* Return a HTTP response when a HTTP error occurs.\n* Added a GUI to change ComputerCraft config options.\n* os.time() and os.day() now accept parameters to give the real world time.\n* Added os.epoch()\n* Monitor text now glows in the dark.\n* Added a \"Pocket Computer upgrade API\" so mod developers can add their own pocket upgrades.\n* Added pocket.equipBack()/pocket.unequipBack() to add/remove pocket upgrades.\n* Added term.setPaletteColor()/term.getPaletteColor() to change/check colors\n* Added colors.rgb8()/colours.rgb8() \n* Performance improvements to fs.find\n* Requires the player to be interacting with the computer when typing\n* Disk labels are limited to 32 characters\n* Labels can now only include characters within the printable range ( to ~)\n* Various model improvements\n* There is now a configurable file descriptor limit\n* Threads are now daemon threads\n* Termination signals are now sent unless the computer is off\n* Fixed compilation errors\n* Now handles tile entity changes\n* GPS coordinates now have to be numbers\n* Turtle upgrades now act as tools and peripherals\n* The Filesystem.list result is now sorted\n* The number of values to unpack can now be manually specified\n* Small terminal & monitor rendering improvements\n* General improvements to the documentation\n* Redstone inputs are no longer reset when adding peripherals\n* Turtles now use tinting\n* shell.resolveProgram now picks up on *.lua files\n* Fixed a handful of bugs in ComputerCraft\n* Added speaker block, turtle upgrade, pocket upgrade, and peripheral api\n* Startup can now be a directory containing multiple startup files\n* Added .getLabel to the computer peripheral\n\nNew Features in ComputerCraft 1.79:\n\n* Ported ComputerCraftEdu to Minecraft 1.8.9\n* Fixed a handful of bugs in ComputerCraft\n\nNew Features in ComputerCraft 1.77:\n\n* Ported to Minecraft 1.8.9\n* Added \"settings\" API\n* Added \"set\" and \"wget\" programs\n* Added settings to disable multishell, startup scripts, and tab completion on a per-computer basis. The default values for these settings can be customised in ComputerCraft.cfg\n* All Computer and Turtle items except Command Computers can now be mounted in Disk Drives\n\nNew Features in ComputerCraft 1.76:\n\n* Ported to Minecraft 1.8\n* Added Ender Modems for cross-dimensional communication\n* Fixed handling of 8-bit characters. All the characters in the ISO 8859-1 codepage can now be displayed\n* Added some extra graphical characters in the unused character positions, including a suite of characters for Teletext style drawing\n* Added support for the new commands in Minecraft 1.8 to the Command Computer\n* The return values of turtle.inspect() and commands.getBlockInfo() now include blockstate information\n* Added commands.getBlockInfos() function for Command Computers\n* Added new \"peripherals\" program\n* Replaced the \"_CC_VERSION\" and \"_MC_VERSION\" constants with a new \"_HOST\" constant\n* Shortened the length of time that \"Ctrl+T\", \"Ctrl+S\" and \"Ctrl+R\" must be held down for to terminate, shutdown and reboot the computer\n* textutils.serialiseJSON() now takes an optional parameter allowing it to produce JSON text with unquoted object keys. This is used by all autogenerated methods in the \"commands\" api except for \"title\" and \"tellraw\"\n* Fixed many bugs\n\nNew Features in ComputerCraft 1.75:\n\n* Fixed monitors sometimes rendering without part of their text.\n* Fixed a regression in the \"bit\" API.\n\nNew Features in ComputerCraft 1.74:\n\n* Added tab completion to \"edit\", \"lua\" and the shell.\n* Added textutils.complete(), fs.complete(), shell.complete(), shell.setCompletionFunction() and help.complete().\n* Added tab completion options to read().\n* Added \"key_up\" and \"mouse_up\" events.\n* Non-advanced terminals now accept both grey colours.\n* Added term.getTextColour(), term.getBackgroundColour() and term.blit().\n* Improved the performance of text rendering on Advanced Computers.\n* Added a \"Run\" button to the edit program on Advanced Computers.\n* Turtles can now push players and entities (configurable).\n* Turtles now respect server spawn protection (configurable).\n* Added a turtle permissions API for mod authors.\n* Implemented a subset of the Lua 5.2 API so programs can be written against it now, ahead of a future Lua version upgrade.\n* Added a config option to disable parts of the Lua 5.1 API which will be removed when a future Lua version upgrade happens.\n* Command Computers can no longer be broken by survival players.\n* Fixed the \"pick block\" key not working on ComputerCraft items in creative mode.\n* Fixed the \"edit\" program being hard to use on certain European keyboards.\n* Added \"_CC_VERSION\" and \"_MC_VERSION\" constants.\n\nNew Features in ComputerCraft 1.73:\n\n* The \"exec\" program, commands.exec() and all related Command Computer functions now return the console output of the command.\n* Fixed two multiplayer crash bugs.\n\nNew Features in ComputerCraft 1.7:\n\n* Added Command Computers\n* Added new API: commands\n* Added new programs: commands, exec\n* Added textutils.serializeJSON()\n* Added ILuaContext.executeMainThreadTask() for peripheral developers\n* Disk Drives and Printers can now be renamed with Anvils\n* Fixed various bugs, crashes and exploits\n* Fixed problems with HD texture packs\n* Documented the new features in the in-game help\n\nNew Features in ComputerCraft 1.65:\n\n* Fixed a multiplayer-only crash with turtle.place()\n* Fixed some problems with http.post()\n* Fixed fs.getDrive() returning incorrect results on remote peripherals\n\nNew Features in ComputerCraft 1.64:\n\n* Ported to Minecraft 1.7.10\n* New turtle functions: turtle.inspect(), turtle.inspectUp(), turtle.inspectDown(), turtle.getItemDetail()\n* Lots of bug and crash fixes, a huge stability improvement over previous versions\n\nNew Features in ComputerCraft 1.63:\n\n* Turtles can now be painted with dyes, and cleaned with water buckets\n* Added a new game: Redirection - ComputerCraft Edition\n* Turtle label nameplates now only show when the Turtle is moused-over\n* The HTTP API is now enabled by default, and can be configured with a whitelist of permitted domains\n* http.get() and http.post() now accept parameters to control the request headers\n* New fs function: fs.getDir( path )\n* Fixed some bugs\n\nNew Features in ComputerCraft 1.62:\n\n* Added IRC-style commands to the \"chat\" program\n* Fixed some bugs and crashes\n\nNew Features in ComputerCraft 1.6:\n\n* Added Pocket Computers\n* Added a multi-tasking system for Advanced Computers and Turtles\n* Turtles can now swap out their tools and peripherals at runtime\n* Turtles can now carry two tools or peripherals at once in any combination\n* Turtles and Computers can now be labelled using Name Tags and Anvils\n* Added a configurable fuel limit for Turtles\n* Added hostnames, protocols and long distance routing to the rednet API\n* Added a peer-to-peer chat program to demonstrate new rednet capabilities\n* Added a new game, only on Pocket Computers: \"falling\" by GopherATL\n* File system commands in the shell now accept wildcard arguments\n* The shell now accepts long arguments in quotes\n* Terminal redirection now no longer uses a stack-based system. Instead: term.current() gets the current terminal object and term.redirect() replaces it. term.restore() has been removed.\n* Added a new Windowing API for addressing sub-areas of the terminal\n* New programs: fg, bg, multishell, chat, repeat, redstone, equip, unequip\n* Improved programs: copy, move, delete, rename, paint, shell\n* Removed programs: redset, redprobe, redpulse\n* New APIs: window, multishell\n* New turtle functions: turtle.equipLeft() and turtle.equipRight()\n* New peripheral functions: peripheral.find( [type] )\n* New rednet functions: rednet.host( protocol, hostname ), rednet.unhost( protocol ), rednet.locate( protocol, [hostname] )\n* New fs function: fs.find( wildcard )\n* New shell functions: shell.openTab(), shell.switchTab( [number] )\n* New event \"term_resize\" fired when the size of a terminal changes\n* Improved rednet functions: rednet.send(), rednet.broadcast() and rednet.receive() now take optional protocol parameters\n* turtle.craft(0) and turtle.refuel(0) now return true if there is a valid recipe or fuel item, but do not craft of refuel anything\n* turtle.suck( [limit] ) can now be used to limit the number of items picked up\n* Users of turtle.dig() and turtle.attack() can now specify which side of the turtle to look for a tool to use (by default, both will be considered)\n* textutils.serialise( text ) now produces human-readable output\n* Refactored most of the codebase and fixed many old bugs and instabilities, turtles should never ever lose their content now\n* Fixed the \"turtle_inventory\" event firing when it shouldn't have\n* Added error messages to many more turtle functions after they return false\n* Documented all new programs and API changes in the \"help\" system\n\nNew Features in ComputerCraft 1.58:\n\n* Fixed a long standing bug where turtles could lose their identify if they travel too far away\n* Fixed use of deprecated code, ensuring mod compatibility with the latest versions of Minecraft Forge, and world compatibility with future versions of Minecraft\n\nNew Features in ComputerCraft 1.57:\n\n* Ported to Minecraft 1.6.4\n* Added two new Treasure Disks: Conway's Game of Life by vilsol and Protector by fredthead\n* Fixed a very nasty item duplication bug\n\nNew Features in ComputerCraft 1.56:\n\n* Added Treasure Disks: Floppy Disks in dungeons which contain interesting community made programs. Find them all!\n* All turtle functions now return additional error messages when they fail.\n* Resource Packs with Lua Programs can now be edited when extracted to a folder, for easier editing.\n\nNew Features in ComputerCraft 1.55:\n\n* Ported to Minecraft 1.6.2\n* Added Advanced Turtles\n* Added \"turtle_inventory\" event. Fires when any change is made to the inventory of a turtle\n* Added missing functions io.close, io.flush, io.input, io.lines, io.output\n* Tweaked the screen colours used by Advanced Computers, Monitors and Turtles\n* Added new features for Peripheral authors\n* Lua programs can now be included in Resource Packs\n\nNew Features in ComputerCraft 1.52:\n\n* Ported to Minecraft 1.5.1\n\nNew Features in ComputerCraft 1.51:\n\n* Ported to Minecraft 1.5\n* Added Wired Modems\n* Added Networking Cables\n* Made Wireless Modems more expensive to craft\n* New redstone API functions: getAnalogInput(), setAnalogOutput(), getAnalogOutput()\n* Peripherals can now be controlled remotely over wired networks. New peripheral API function: getNames()\n* New event: \"monitor_resize\" when the size of a monitor changes\n* Except for labelled computers and turtles, ComputerCraft blocks no longer drop items in creative mode\n* The pick block function works in creative mode now works for all ComputerCraft blocks\n* All blocks and items now use the IDs numbers assigned by FTB by default\n* Fixed turtles sometimes placing blocks with incorrect orientations\n* Fixed Wireless modems being able to send messages to themselves\n* Fixed turtle.attack() having a very short range\n* Various bugfixes\n\nNew Features in ComputerCraft 1.5:\n\n* Redesigned Wireless Modems; they can now send and receive on multiple channels, independent of the computer ID. To use these features, interface with modem peripherals directly. The rednet API still functions as before\n* Floppy Disks can now be dyed with multiple dyes, just like armour\n* The \"excavate\" program now retains fuel in it's inventory, so can run unattended\n* turtle.place() now tries all possible block orientations before failing\n* turtle.refuel(0) returns true if a fuel item is selected\n* turtle.craft(0) returns true if the inventory is a valid recipe\n* The in-game help system now has documentation for all the peripherals and their methods, including the new modem functionality\n* A romantic surprise\n\nNew Features in ComputerCraft 1.48:\n\n* Ported to Minecraft 1.4.6\n* Advanced Monitors now emit a \"monitor_touch\" event when right clicked\n* Advanced Monitors are now cheaper to craft\n* Turtles now get slightly less fuel from items\n* Computers can now interact with Command Blocks (if enabled in ComputerCraft.cfg)\n* New API function: os.day()\n* A christmas surprise\n\nNew Features in ComputerCraft 1.45:\n\n* Added Advanced Computers\n* Added Advanced Monitors\n* New program: paint by nitrogenfingers\n* New API: paintutils\n* New term functions: term.setBackgroundColor, term.setTextColor, term.isColor\n* New turtle function: turtle.transferTo\n\nNew Features in ComputerCraft 1.43:\n\n* Added Printed Pages\n* Added Printed Books\n* Fixed incompatibility with Forge 275 and above\n* Labelled Turtles now keep their fuel when broken\n\nNew Features in ComputerCraft 1.42:\n\n* Ported to Minecraft 1.3.2\n* Added Printers\n* Floppy Disks can be dyed different colours\n* Wireless Crafty Turtles can now be crafted\n* New textures\n* New forge config file\n* Bug fixes\n\nNew Features in ComputerCraft 1.4:\n\n* Ported to Forge Mod Loader. ComputerCraft can now be ran directly from the .zip without extraction\n* Added Farming Turtles\n* Added Felling Turtles\n* Added Digging Turtles\n* Added Melee Turtles\n* Added Crafty Turtles\n* Added 14 new Turtle Combinations accessible by combining the turtle upgrades above\n* Labelled computers and turtles can now be crafted into turtles or other turtle types without losing their ID, label and data\n* Added a \"Turtle Upgrade API\" for mod developers to create their own tools and peripherals for turtles\n* Turtles can now attack entities with turtle.attack(), and collect their dropped items\n* Turtles can now use turtle.place() with any item the player can, and can interact with entities\n* Turtles can now craft items with turtle.craft()\n* Turtles can now place items into inventories with turtle.drop()\n* Changed the behaviour of turtle.place() and turtle.drop() to only consider the currently selected slot\n* Turtles can now pick up items from the ground, or from inventories, with turtle.suck()\n* Turtles can now compare items in their inventories\n* Turtles can place signs with text on them with turtle.place( [signText] )\n* Turtles now optionally require fuel items to move, and can refuel themselves\n* The size of the the turtle inventory has been increased to 16\n* The size of the turtle screen has been increased\n* New turtle functions: turtle.compareTo( [slotNum] ), turtle.craft(), turtle.attack(), turtle.attackUp(), turtle.attackDown(), turtle.dropUp(), turtle.dropDown(), turtle.getFuelLevel(), turtle.refuel()\n* New disk function: disk.getID()\n* New turtle programs: craft, refuel\n* \"excavate\" program now much smarter: Will return items to a chest when full, attack mobs, and refuel itself automatically\n* New API: keys\n* Added optional Floppy Disk and Hard Drive space limits for computers and turtles\n* New fs function: fs.getFreeSpace( path ), also fs.getDrive() works again\n* The send and receive range of wireless modems now increases with altitude, allowing long range networking from high-altitude computers (great for GPS networks)\n* http.request() now supports https:// URLs\n* Right clicking a Disk Drive with a Floppy Disk or a Record when sneaking will insert the item into the Disk Drive automatically\n* The default size of the computer screen has been increased\n* Several stability and security fixes. LuaJ can now no longer leave dangling threads when a computer is unloaded, turtles can no longer be destroyed by tree leaves or walking off the edge of the loaded map. Computers no longer crash when used with RedPower frames.\n\nNew Features in ComputerCraft 1.31:\n\n* Ported to Minecraft 1.2.3\n* Added Monitors (thanks to Cloudy)\n* Updated LuaJ to a newer, less memory hungry version\n* rednet_message event now has a third parameter, \"distance\", to support position triangulation.\n* New programs: gps, monitor, pastebin.\n* Added a secret program. Use with large monitors!\n* New apis: gps, vector\n* New turtle functions: turtle.compare(), turtle.compareUp(), turtle.compareDown(), turtle.drop( quantity )\n* New http functions: http.post().\n* New term functions: term.redirect(), term.restore()\n* New textutils functions: textutils.urlEncode()\n* New rednet functions: rednet.isOpen()\n* New config options: modem_range, modem_rangeDuringStorm\n* Bug fixes, program tweaks, and help updates\n\nNew Features in ComputerCraft 1.3:\n\n* Ported to Minecraft Forge\n* Added Turtles\n* Added Wireless Modems\n* Added Mining Turtles\n* Added Wireless Turtles\n* Added Wireless Mining Turtles\n* Computers and Disk Drives no longer get destroyed by water.\n* Computers and Turtles can now be labelled with the label program, and labelled devices keep their state when destroyed.\n* Computers/Turtles can connect to adjacent devices, and turn them on and off\n* User programs now give line numbers in their error messages\n* New APIs: turtle, peripheral\n* New programs for turtles: tunnel, excavate, go, turn, dance\n* New os functions: os.getComputerLabel(), os.setComputerLabel()\n* Added \"filter\" parameter to os.pullEvent()\n* New shell function: shell.getCurrentProgram()\n* New textutils functions: textutils.serialize(), textutils.unserialize(), textutils.tabulate(), textutils.pagedTabulate(), textutils.slowWrite()\n* New io file function: file:lines()\n* New fs function: fs.getSize()\n* Disk Drives can now play records from other mods\n* Bug fixes, program tweaks, and help updates\n\nNew Features in ComputerCraft 1.2:\n\n* Added Disk Drives and Floppy Disks\n* Added Ctrl+T shortcut to terminate the current program (hold)\n* Added Ctrl+S shortcut to shutdown the computer (hold)\n* Added Ctrl+R shortcut to reboot the computer (hold)\n* New Programs: alias, apis, copy, delete, dj, drive, eject, id, label, list, move, reboot, redset, rename, time, worm.\n* New APIs: bit, colours, disk, help, rednet, parallel, textutils.\n* New color functions: colors.combine(), colors.subtract(), colors.test()\n* New fs functions: fs.getName(), new modes for fs.open()\n* New os functions: os.loadAPI(), os.unloadAPI(),\nos.clock(), os.time(), os.setAlarm(),\nos.reboot(), os.queueEvent()\n* New redstone function: redstone.getSides()\n* New shell functions: shell.setPath(), shell.programs(), shell.resolveProgram(), shell.setAlias()\n* Lots of updates to the help pages\n* Bug fixes\n\nNew Features in ComputerCraft 1.1:\n\n* Added Multiplayer support throughout.\n* Added connectivity with RedPower bundled cables\n* Added HTTP api, enabled via the mod config, to allow computers to access the real world internet\n* Added command history to the shell.\n* Programs which spin in an infinite loop without yielding will no longer freeze minecraft\n* Help updates and bug fixes\n\nNew Features in ComputerCraft 1.0:\n\n* First Release!","wget.txt":"wget is a program for downloading files from the internet. This is useful for downloading programs created by other players.\nIf no filename is specified wget will try to determine the filename from the URL by stripping any anchors, parameters and trailing slashes and then taking everything remaining after the last slash.\nThe HTTP API must be enabled in ComputerCraft.cfg to use this program.\nex:\n\"wget http://pastebin.com/raw/CxaWmPrX test\" will download the file from the URL http://pastebin.com/raw/CxaWmPrX, and save it as \"test\".\n\"wget http://example.org/test.lua/?foo=bar#qzu\" will download the file from the URL http://example.org/test.lua/?foo=bar#qzu and save it as \"test.lua\"\n\"wget http://example.org/\" will download the file from the URL http://example.org and save it as \"example.org\"","vector.txt":"Functions in the 3D Vector Math API:\nvector.new( x,y,z )\n\nVectors returned by vector.new() have the following fields and methods:\nvector.x\nvector.y\nvector.z\nvector:add( vector )\nvector:sub( vector )\nvector:mul( number )\nvector:dot( vector )\nvector:cross( vector )\nvector:length()\nvector:normalize()\nvector:round()\nvector:tostring()\nThe +, - and * operators can also be used on vectors.","unequip.txt":"unequip is a program for Turtles and Pocket Computers. unequip will remove tools of peripherals from the specified side of the turtle. On a Pocket Computer you don't need to write a side.\n\nex:\n\"unequip left\" will remove the item on the left side of the turtle\n\"unequip\" on a Pocket Computer will remove the item from the Pocket Computer","type.txt":"type determines the type of a file or directory. Prints \"file\", \"directory\" or \"does not exist\".","textutils.txt":"Functions in the Text Utilities API:\ntextutils.slowPrint( text )\ntextutils.tabulate( table, table2, ... )\ntextutils.pagedTabulate( table, table2, ... )\ntextutils.formatTime( time, bTwentyFourHour )\ntextutils.serialize( table )\ntextutils.unserialize( string )\ntextutils.serializeJSON( table, [useNBTStyle] )\ntextutils.urlEncode( string )\ntextutils.complete( string, table )","peripheral.txt":"The peripheral API is for interacting with external peripheral devices. Type \"help peripherals\" to learn about the peripherals available.\n\nFunctions in the peripheral API:\nperipheral.getNames()\nperipheral.isPresent( name )\nperipheral.getType( name )\nperipheral.getMethods( name )\nperipheral.call( name, methodName, param1, param2, etc )\nperipheral.wrap( name )\nperipheral.find( type, [fnFilter] )\n\nEvents fired by the peripheral API:\n\"peripheral\" when a new peripheral is attached. Argument is the name.\n\"peripheral_detach\" when a peripheral is removed. Argument is the name.\nType \"help events\" to learn about the event system.","refuel.txt":"refuel is a program for Turtles. Refuel will consume items from the inventory as fuel for turtle.\n\nex:\n\"refuel\" will refuel with at most one fuel item\n\"refuel 10\" will refuel with at most 10 fuel items\n\"refuel all\" will refuel with as many fuel items as possible","turn.txt":"turn is a program for Turtles, used to turn the turtle around without programming. It accepts one or more commands as a direction and a number of turns. The \"go\" program can also be used for turning.\n\nex:\n\"turn left\" turns the turtle 90 degrees left.\n\"turn right 2\" turns the turtle 180 degrees right.\n\"turn left 2 right\" turns left 180 degrees, then right 90 degrees.","tunnel.txt":"tunnel is a program for Mining Turtles. Tunnel will mine a 3x2 tunnel of the depth specified.\n\nex:\n\"tunnel 20\" will tunnel a tunnel 20 blocks long.","excavate.txt":"excavate is a program for Mining Turtles. When excavate is run, the turtle will mine a rectangular shaft into the ground, collecting blocks as it goes, and return to the surface once bedrock is hit.\n\nex:\n\"excavate 3\" will mine a 3x3 shaft.","term.txt":"Functions in the Terminal API:\nterm.write( text )\nterm.blit( text, textColor, backgroundColor )\nterm.clear()\nterm.clearLine()\nterm.getCursorPos()\nterm.setCursorPos( x, y )\nterm.setCursorBlink( blink )\nterm.isColor()\nterm.setTextColor( color )\nterm.setBackgroundColor( color )\nterm.getTextColor()\nterm.getBackgroundColor()\nterm.getSize()\nterm.scroll( n )\nterm.redirect( object )\nterm.current()\nterm.setPaletteColor( color, r, g, b )\nterm.getPaletteColor( color )\n\nEvents emitted by the terminals:\n\"term_resize\", when the size of a terminal changes. This can happen in multitasking environments, or when the terminal out is being redirected by the \"monitor\" program.","multishell.txt":"multishell is the toplevel program on Advanced Computers which manages background tabs.\nType \"help shellapi\" for information about the shell lua api.","speakers.txt":"The Speaker is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Speaker is connected, peripheral.getType() will return \"speaker\".\n\nMethods exposed by the Speaker:\nplaySound( sResourceName, nVolume, nPitch )\nplayNote( sInstrumentName, nVolume, nPitch )\n\nResource name is the same as used by the /playsound command, such as \"minecraft:entity.cow.ambient\".\nInstruments are as follows: \"harp\", \"bass\", \"snare\", \"hat\", and \"basedrum\" with the addition of \"flute\", \"bell\", \"chime\", and \"guitar\" in Minecraft versions 1.12 and above.\nTicks is the amount of times a noteblock has been tuned (right clicked).","shell.txt":"shell is the toplevel program which interprets commands and runs program.\nType \"help shellapi\" for information about the shell lua api.","rednet.txt":"The rednet API provides a simple computer networking model using modems.\n\nFunctions in the rednet API:\nrednet.open( side )\nrednet.close( [side] )\nrednet.isOpen( [side] )\nrednet.send( receiverID, message, [protocol] ) -- Send to a specific computer\nrednet.broadcast( message, [protocol] ) -- Send to all computers\nrednet.receive( [protocol], [timeout] ) -- Returns: senderID, message, protocol\nrednet.host( protocol, hostname )\nrednet.unhost( protocol )\nrednet.lookup( protocol, [hostname] ) -- Returns: ID\n\nEvents fired by the rednet API:\n\"rednet_message\" when a message is received. Arguments are senderID, message, protocol\nType \"help events\" to learn about the event system.\n\nRednet is not the only way to use modems for networking. Interfacing with the modem directly using the peripheral API and listening for the \"modem_message\" event allows for lower level control, at the expense of powerful high level networking features.","disk.txt":"Functions in the disk API. These functions are for interacting with disk drives:\ndisk.isPresent( drive )\ndisk.setLabel( drive, label )\ndisk.getLabel( drive )\ndisk.hasData( drive )\ndisk.getMountPath( drive )\ndisk.hasAudio( drive )\ndisk.getAudioTitle( drive )\ndisk.playAudio( drive )\ndisk.stopAudio( )\ndisk.eject( drive )\ndisk.getID( drive )\n\nEvents fired by the disk API:\n\"disk\" when a disk or other item is inserted into a disk drive. Argument is the name of the drive\n\"disk_eject\" when a disk is removed from a disk drive. Argument is the name of the drive\nType \"help events\" to learn about the event system.","pastebin.txt":"pastebin is a program for uploading files to and downloading files from pastebin.com. This is useful for sharing programs with other players.\nThe HTTP API must be enabled in ComputerCraft.cfg to use this program.\n\nex:\n\"pastebin put foo\" will upload the file \"foo\" to pastebin.com, and print the URL.\n\"pastebin get xq5gc7LB foo\" will download the file from the URL http://pastebin.com/xq5gc7LB, and save it as \"foo\".\n\"pastebin run CxaWmPrX\" will download the file from the URL http://pastebin.com/CxaWmPrX, and immediately run it.","monitors.txt":"The Monitor is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Monitor is connected, peripheral.getType() will return \"monitor\". A wrapped monitor can be used with term.redirect() to send all terminal output to the monitor.\n\nMethods exposed by the Monitor:\nwrite( text )\nblit( text, textColor, backgroundColor )\nclear()\nclearLine()\ngetCursorPos()\nsetCursorPos( x, y )\nsetCursorBlink( blink )\nisColor()\nsetTextColor( color )\nsetBackgroundColor( color )\ngetTextColor()\ngetBackgroundColor()\ngetSize()\nscroll( n )\nsetPaletteColor( color, r, g, b )\ngetPaletteColor( color )\n\nEvents fired by the Monitor:\n\"monitor_touch\" when an Advanced Monitor is touched by the player. Arguments are name, x, y\n\"monitor_resize\" when the size of a Monitor changes. Argument is the name of the monitor.","keys.txt":"The keys API contains constants for all the key codes that can be returned by the \"key\" event:\n\nExample usage:\nlocal sEvent, nKey = os.pullEvent()\nif sEvent == \"key\" and nKey == keys.enter then\n   -- Do something  \nend\n\nSee http://www.minecraftwiki.net/wiki/Key_codes, or the source code, for a complete reference.","turtle.txt":"turtle is an api availiable on Turtles, which controls their movement.\nFunctions in the Turtle API:\nturtle.forward()\nturtle.back()\nturtle.up()\nturtle.down()\nturtle.turnLeft()\nturtle.turnRight()\nturtle.select( slotNum )\nturtle.getSelectedSlot()\nturtle.getItemCount( [slotNum] )\nturtle.getItemSpace( [slotNum] )\nturtle.getItemDetail( [slotNum] )\nturtle.equipLeft()\nturtle.equipRight()\nturtle.dig( [toolSide] )\nturtle.digUp( [toolSide] )\nturtle.digDown( [toolSide] )\nturtle.place()\nturtle.placeUp()\nturtle.placeDown()\nturtle.attack( [toolSide] )\nturtle.attackUp( [toolSide] )\nturtle.attackDown( [toolSide] )\nturtle.detect()\nturtle.detectUp()\nturtle.detectDown()\nturtle.compare()\nturtle.compareUp()\nturtle.compareDown()\nturtle.inspect()\nturtle.inspectUp()\nturtle.inspectDown()\nturtle.compareTo( slotNum )\nturtle.transferTo( slotNum, [quantity] )\nturtle.drop( [quantity] )\nturtle.dropUp( [quantity] )\nturtle.dropDown( [quantity] )\nturtle.suck( [quantity] )\nturtle.suckUp( [quantity] )\nturtle.suckDown( [quantity] )\nturtle.getFuelLevel()\nturtle.getFuelLimit()\nturtle.refuel( [quantity] )\nturtle.craft( [quantity] ) (requires Crafty Turtle)\n\nEvents fired by the Turtle API:\n\"turtle_inventory\" when any of the items in the inventory are changed. Use comparison operations to inspect the changes.","redstoneapi.txt":"Functions in the Redstone API:\nredstone.getSides( )\nredstone.getInput( side )\nredstone.setOutput( side, boolean )\nredstone.getOutput( side )\nredstone.getAnalogInput( side )\nredstone.setAnalogOutput( side, number )\nredstone.getAnalogOutput( side )\n\nFunctions in the Redstone API for working with bundled cables:\nredstone.getBundledInput( side )\nredstone.testBundledInput( side, color )\nredstone.setBundledOutput( side, colors )\nredstone.getBundledOutput( side )\nType \"help bundled\" for usage examples.\n\nEvents emitted by the redstone API:\n\"redstone\", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes\nType \"help events\" to learn about the event system.","redstone.txt":"The redstone program can be used to get, set or pulse redstone inputs and outputs from the computer.\n\nex:\n\"redstone probe\" will list all the redstone inputs to the computer\n\"redstone set left true\" turns on the left redstone output.\n\"redstone set right blue false\" turns off the blue wire in the bundled cable on the right redstone output.\n\"redstone pulse front 10 1\" emits 10 one second redstone pulses on the front redstone output.\n\nType \"help redstoneapi\" or \"help rs\" for information on the redstone Lua API.","lua.txt":"lua is an interactive prompt for the lua programming language. It's a useful tool for learning the language.","chat.txt":"Surf the rednet superhighway with \"chat\", the networked chat program for CraftOS! Host chatrooms and invite your friends! Requires a Wired or Wireless Modem on each computer. When running chat, type \"/help\" to see a list of available commands.\n\nex:\n\"chat host forgecraft\" will create a chatroom with the name \"forgecraft\"\n\"chat join forgecraft direwolf20\" will connect to the chatroom with the name \"forgecraft\", using the nickname \"direwolf20\"","settings.txt":"Functions in the Settings API:\nsettings.get( name, [default] )\nsettings.set( name, value )\nsettings.unset( name )\nsettings.load( path )\nsettings.save( path )\nsettings.clear()\nsettings.getNames()\n\nDefault Settings:\nshell.autocomplete - enables auto-completion in the Shell.\nlua.autocomplete - enables auto-completion in the Lua program.\nedit.autocomplete - enables auto-completion in the Edit program.\nedit.default_extension - sets the default file extension for files created with the Edit program\npaint.default_extension - sets the default file extension for files created with the Paint program\nbios.use_multishell - enables Multishell on Advanced Computers, Turtles, Pocket Computers and Command Computers.\nshell.allow_disk_startup - if a Disk Drive with a Disk inside that has a 'startup' script is attached to a computer, this setting allows to automatically run that script when the computer starts.\nshell.allow_startup - if there is a 'startup' script in a computer's root, this setting allow to automatically run that script when the computer runs.\nlist.show_hidden - determines, whether the List program will list hidden files or not.","gps.txt":"gps can be used to host a GPS server, or to determine a position using trilateration.\nType \"help gpsapi\" for help using GPS functions in lua programs.\n\nex:\n\"gps locate\" will connect to nearby GPS servers, and try to determine the position of the computer or turtle.\n\"gps host\" will try to determine the position, and host a GPS server if successful.\n\"gps host 10 20 30\" will host a GPS server, using the manually entered position 10,20,30. \n\nTake care when manually entering host positions. If the positions entered into multiple GPS hosts\nare not consistent, the results of locate calls will be incorrect.","list.txt":"ls will list all the directories and files in the current location. Use \"type\" to find out if an item is a file or a directory.","redirection.txt":"Redirection ComputerCraft Edition is the CraftOS version of a fun new puzzle game by Dan200, the author of ComputerCraft.\nPlay it on any Advanced Computer, then visit http://www.redirectiongame.com to play the full game!","math.txt":"math is a standard Lua5.1 API.\nRefer to http://www.lua.org/manual/5.1/ for more information.","programming.txt":"To learn the lua programming language, visit http://lua-users.org/wiki/TutorialDirectory.\n\nTo experiment with lua in CraftOS, run the \"lua\" program and start typing code.\nTo create programs, use \"edit\" to create files, then type their names in the shell to run them. If you name a program \"startup\" and place it in the root or on a disk drive, it will run automatically when the computer starts.\n\nTo terminate a program stuck in a loop, hold Ctrl+T for 1 second.\nTo quickly shutdown a computer, hold Ctrl+S for 1 second.\nTo quickly reboot a computer, hold Ctrl+R for 1 second.\n\nTo learn about the programming APIs availiable, type \"apis\" or \"help apis\".\nIf you get stuck, visit the forums at http://www.computercraft.info/ for advice and tutorials.","printers.txt":"The Printer is a peripheral device available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Printer is connected, peripheral.getType() will return \"printer\".\n\nMethods exposed by the Printer:\ngetInkLevel()\ngetPaperLevel()\nnewPage()\nsetPageTitle( title )\ngetPageSize()\nsetCursorPos( x, y )\ngetCursorPos()\nwrite( text )\nendPage()","coroutine.txt":"coroutine is a standard Lua5.1 API.\nRefer to http://www.lua.org/manual/5.1/ for more information.","edit.txt":"edit is a text editor for creating or modifying programs or text files. After creating a program with edit, type its filename in the shell to run it. You can open any of the builtin programs with edit to learn how to program.\n\nex:\n\"edit hello\" opens a file called \"hello\" for editing.","programs.txt":"programs lists all the programs on the rom of the computer.","delete.txt":"rm deletes a file or a directory and its contents.\n\nex:\n\"rm foo\" will delete the file foo.\n\"rm disk/*\" will delete the contents of a disk.","parallel.txt":"Functions in the Parallel API:\nparallel.waitForAny( function1, function2, ... )\nparallel.waitForAll( function1, function2, ... )\nThese methods provide an easy way to run multiple lua functions simultaneously.","credits.txt":"\nComputerCraft was created by Daniel \"dan200\" Ratcliffe, with additional code by Aaron \"Cloudy\" Mills.\nThanks to nitrogenfingers, GopherATL and RamiLego for program contributions.\nThanks to Mojang, the Forge team, and the MCP team.\nUses LuaJ from http://luaj.sourceforge.net/\n\nThe ComputerCraft 1.76 update was sponsored by MinecraftU and Deep Space.\nVisit http://www.minecraftu.org and http://www.deepspace.me/space-cadets to find out more.\n\nJoin the ComputerCraft community online at http://www.computercraft.info\nFollow @DanTwoHundred on Twitter!\n\nTo help contribute to ComputerCraft, browse the source code at https://github.com/dan200/ComputerCraft.\n\nGitHub Contributors:\n${gitcontributors}","paintutils.txt":"Functions in the Paint Utilities API:\npaintutils.drawPixel( x, y, colour )\npaintutils.drawLine( startX, startY, endX, endY, colour )\npaintutils.drawBox( startX, startY, endX, endY, colour )\npaintutils.drawFilledBox( startX, startY, endX, endY, colour )\npaintutils.loadImage( path )\npaintutils.drawImage( image, x, y )","fg.txt":"fg is a program for Advanced Computers which opens a new tab in the foreground.\n\nex:\n\"fg\" will open a foreground tab running the shell\n\"fg worm\" will open a foreground tab running the \"worm\" program","bundled.txt":"To set bundled outputs:\nc = colors.combine( colors.red, colors.blue )\nrs.setBundledOutput( \"left\", c )\n\nc = colors.combine( c, colors.green )\nrs.setBundledOutput( \"left\", c )\n\nc = colors.subtract( c, colors.blue )\nrs.setBundledOutput( \"left\", c )\n\nTo get bundled inputs:\nc = rs.getBundledInput( \"right\" )\nred = colors.test( c, colors.red )\n\nType \"help colors\" for the list of wire colors.","craft.txt":"craft is a program for Crafty Turtles. Craft will craft a stack of items using the current inventory.\n\nex:\n\"craft\" will craft as many items as possible\n\"craft 5\" will craft at most 5 times","exit.txt":"exit will exit the current shell.","bg.txt":"bg is a program for Advanced Computers which opens a new tab in the background.\n\nex:\n\"bg\" will open a background tab running the shell\n\"bg worm\" will open a background tab running the \"worm\" program","paint.txt":"paint is a program for creating images on Advanced Computers. Select colors from the color pallette on the right, and click on the canvas to draw. Press Ctrl to access the menu and save your pictures.\n\nex:\n\"edit mario\" opens an image called \"mario\" for editing.","move.txt":"mv moves a file or directory from one location to another.\n\nex:\n\"mv foo bar\" renames the file \"foo\" to \"bar\".\n\"mv foo bar/foo\" moves the file \"foo\" to a folder called \"bar\".\n\"mv disk/* disk2\" moves the contents of one disk to another","copy.txt":"cp copies a file or directory from one location to another.\n\nex:\n\"cp rom myrom\" copies \"rom\" to \"myrom\".\n\"cp rom mystuff/rom\" copies \"rom\" to \"mystuff/rom\".\n\"cp disk/* disk2\" copies the contents of one disk to another","string.txt":"string is a standard Lua5.1 API.\nRefer to http://www.lua.org/manual/5.1/ for more information.","go.txt":"go is a program for Turtles, used to control the turtle without programming. It accepts one or more commands as a direction followed by a distance.\n\nex:\n\"go forward\" moves the turtle 1 space forward.\n\"go forward 3\" moves the turtle 3 spaces forward.\n\"go forward 3 up left 2\" moves the turtle 3 spaces forward, 1 spaces up, then left 180 degrees.","os.txt":"Functions in the os (Operating System) API:\nos.version()\nos.getComputerID()\nos.getComputerLabel()\nos.setComputerLabel()\nos.run( environment, programpath, arguments )\nos.loadAPI( path )\nos.unloadAPI( name )\nos.pullEvent( [filter] )\nos.queueEvent( event, arguments )\nos.clock()\nos.startTimer( timeout )\nos.cancelTimer( token )\nos.sleep( timeout )\nos.time( [source] )\nos.day( [source] )\nos.epoch( [source] )\nos.setAlarm( time )\nos.cancelAlarm( token )\nos.shutdown()\nos.reboot()\n\nEvents emitted by the os API:\n\"timer\" when a timeout started by os.startTimer() completes. Argument is the token returned by os.startTimer().\n\"alarm\" when a time passed to os.setAlarm() is reached. Argument is the token returned by os.setAlarm().\nType \"help events\" to learn about the event system.","io.txt":"io is a standard Lua5.1 API, reimplemented for CraftOS. Not all the features are availiable.\nRefer to http://www.lua.org/manual/5.1/ for more information.","modems.txt":"Wired and Wireless Modems are peripheral devices available for CraftOS. Type \"help peripheral\" to learn about using the Peripheral API to connect with peripherals. When a Modem is connected, peripheral.getType() will return \"modem\".\n\nMethods exposed by Modems:\nopen( channel )\nisOpen( channel )\nclose( channel )\ncloseAll()\ntransmit( channel, replyChannel, message )\nisWireless()\n\nEvents fired by Modems:\n\"modem_message\" when a message is received on an open channel. Arguments are name, channel, replyChannel, message, distance","mkdir.txt":"mkdir creates a directory in the current location.\n\nex:\n\"mkdir foo\" creates a directory named \"foo\".\n\"mkdir ../foo\" creates a directory named \"foo\" in the directory above the current directory.","http.txt":"Functions in the HTTP API:\nhttp.checkURL( url )\nhttp.checkURLAsync( url )\nhttp.request( url, [postData], [headers] )\nhttp.get( url, [headers] )\nhttp.post( url, postData, [headers] )\n\nThe HTTP API may be disabled in ComputerCraft.cfg\nA period of time after a http.request() call is made, a \"http_success\" or \"http_failure\" event will be raised. Arguments are the url and a file handle if successful. Arguments are nil, an error message, and (optionally) a file handle if the request failed. http.get() and http.post() block until this event fires instead.","rs.txt":"Functions in the Redstone API:\nrs.getSides( )\nrs.getInput( side )\nrs.setOutput( side, boolean )\nrs.getOutput( side )\nrs.getAnalogInput( side )\nrs.setAnalogOutput( side, number )\nrs.getAnalogOutput( side )\n\nFunctions in the Redstone API for working with RedPower bundled cables:\nrs.getBundledInput( side )\nrs.testBundledInput( side, color )\nrs.setBundledOutput( side, colors )\nrs.getBundledOutput( side )\nType \"help bundled\" for usage examples.\n\nEvents emitted by the redstone API:\n\"redstone\", when the state of any redstone input changes. Use getInput() or getBundledInput() to inspect the changes\nType \"help events\" to learn about the event system.","help.txt":"help is the help tool you're currently using.\nType \"help index\" to see all help topics.\nType \"help\" to see the help intro.\nType \"help helpapi\" for information on the help Lua API.","drive.txt":"drive tells you which disk drive the current or specified directory is located in.\n\nex:\n\"drive\" tell you the disk drive of the current directory.\n\"drive foo\" tells you the disk drive of the subdirectory \"foo\"","id.txt":"id prints the unique identifier of this computer, or a Disk in an attached Disk Drive.\n\nex:\n\"id\" will print this Computers ID and label\n\"id left\" will print the ID and label of the disk in the Disk Drive on the left","exec.txt":"On a Command Computer, \"exec\" will execute a command as if entered on a command block. Use \"commands\" to list all the available commands.\n\nex:\n\"exec say Hello World\"\n\"exec setblock ~0 ~1 ~0 minecraft:dirt\"\n\nType \"help commandsapi\" for help using commands in lua programs.","gpsapi.txt":"Functions in the GPS API:\ngps.locate( timeout )\n\nThe locate function will send a signal to nearby gps servers, and wait for responses before the timeout. If it receives enough responses to determine this computers position then x, y and z co-ordinates will be returned, otherwise it will return nil. If GPS hosts do not have their positions configured correctly, results will be inaccurate.","clear.txt":"clear clears the screen.","alias.txt":"alias assigns shell commands to run other programs.\n\nex:\n\"alias dir ls\" will make the \"dir\" command run the \"ls\" program\n\"alias dir\" will remove the alias set on \"dir\"\n\"alias\" will list all current aliases.","colors.txt":"Functions in the colors api\n(used for redstone.setBundledOutput):\ncolors.combine( color1, color2, color3, ... )\ncolors.subtract( colors, color1, color2, ... )\ncolors.test( colors, color )\ncolors.rgb8( r, g, b )\n\nColor constants in the colors api, in ascending bit order:\ncolors.white, colors.orange, colors.magenta, colors.lightBlue, colors.yellow, colors.lime, colors.pink, colors.gray, colors.lightGray, colors.cyan, colors.purple, colors.blue, colors.brown, colors.green, colors.red, colors.black.","set.txt":"The set program can be used to inspect and change system settings.\n\nUsage:\n\"set\" will print all the system settings and their values\n\"set foo\" will print the value of the system setting \"foo\"\n\"set foo bar\" will set the value of the system setting \"foo\" to \"bar\"","fs.txt":"Functions in the Filesystem API:\nfs.list( path )\nfs.find( wildcard )\nfs.exists( path )\nfs.isDir( path )\nfs.isReadOnly( path )\nfs.getDir( path )\nfs.getName( path )\nfs.getSize( path )\nfs.getDrive( path )\nfs.getFreeSpace( path )\nfs.makeDir( path )\nfs.move( path, path )\nfs.copy( path, path )\nfs.delete( path )\nfs.combine( path, localpath )\nfs.open( path, mode )\nfs.complete( path, location )\nAvailable fs.open() modes are \"r\", \"w\", \"a\", \"rb\", \"wb\" and \"ab\".\n\nFunctions on files opened with mode \"r\":\nreadLine()\nreadAll()\nclose()\nread( number )\n\nFunctions on files opened with mode \"w\" or \"a\":\nwrite( string )\nwriteLine( string )\nflush()\nclose()\n\nFunctions on files opened with mode \"rb\":\nread()\nclose()\n\nFunctions on files opened with mode \"wb\" or \"ab\":\nwrite( byte )\nflush()\nclose()","equip.txt":"equip is a program for Turtles and Pocket Computer. equip will equip an item from the Turtle's inventory for use as a tool of peripheral. On a Pocket Computer you don't need to write a side.\n\nex:\n\"equip 5 left\" will equip the item from slot 5 of the turtle onto the left side of the turtle\n\"equip\" on a Pocket Computer will equip the first item from your inventory.","cd.txt":"cd changes the directory you're in.\n\nex:\n\"cd rom\" will move to \"rom\" folder.\n\"cd ..\" will move up one folder.\n\"cd /\" will move to the root."},"autorun":{".ignoreme":"--[[\nAlright then, don't ignore me. This file is to ensure the existence of the \"autorun\" folder, files placed in this folder\nusing resource packs will always run when computers startup.\n]]"},"apis":{"help.lua":"\nlocal sPath = \"/rom/help\"\n\nfunction path()\n    return sPath\nend\n\nfunction setPath( _sPath )\n    if type( _sPath ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sPath ) .. \")\", 2 )\n    end\n    sPath = _sPath\nend\n\nfunction lookup( _sTopic )\n    if type( _sTopic ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sTopic ) .. \")\", 2 )\n    end\n     -- Look on the path variable\n    for sPath in string.gmatch(sPath, \"[^:]+\") do\n        sPath = fs.combine( sPath, _sTopic )\n        if fs.exists( sPath ) and not fs.isDir( sPath ) then\n            return sPath\n        elseif fs.exists( sPath..\".txt\" ) and not fs.isDir( sPath..\".txt\" ) then\n            return sPath..\".txt\"\n        end\n    end\n\n    -- Not found\n    return nil\nend\n\nfunction topics()\n    -- Add index\n    local tItems = {\n        [ \"index\" ] = true\n    }\n\n    -- Add topics from the path\n    for sPath in string.gmatch(sPath, \"[^:]+\") do\n        if fs.isDir( sPath ) then\n            local tList = fs.list( sPath )\n            for n,sFile in pairs( tList ) do\n                if string.sub( sFile, 1, 1 ) ~= \".\" then\n                    if not fs.isDir( fs.combine( sPath, sFile ) ) then\n                        if #sFile > 4 and sFile:sub(-4) == \".txt\" then\n                            sFile = sFile:sub(1,-5)\n                        end\n                        tItems[ sFile ] = true\n                    end\n                end\n            end\n        end\n    end\n\n    -- Sort and return\n    local tItemList = {}\n    for sItem, b in pairs( tItems ) do\n        table.insert( tItemList, sItem )\n    end\n    table.sort( tItemList )\n    return tItemList\nend\n\nfunction completeTopic( sText )\n    if type( sText ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sText ) .. \")\", 2 )\n    end\n    local tTopics = topics()\n    local tResults = {}\n    for n=1,#tTopics do\n        local sTopic = tTopics[n]\n        if #sTopic > #sText and string.sub( sTopic, 1, #sText ) == sText then\n            table.insert( tResults, string.sub( sTopic, #sText + 1 ) )\n        end\n    end\n    return tResults\nend","textutils.lua":"\nfunction slowWrite( sText, nRate )\n    if nRate ~= nil and type( nRate ) ~= \"number\" then\n        error( \"bad argument #2 (expected number, got \" .. type( nRate ) .. \")\", 2 )\n    end\n    nRate = nRate or 20\n    if nRate < 0 then\n        error( \"Rate must be positive\", 2 )\n    end\n    local nSleep = 1 / nRate\n\n    sText = tostring( sText )\n    local x,y = term.getCursorPos()\n    local len = string.len( sText )\n\n    for n=1,len do\n        term.setCursorPos( x, y )\n        sleep( nSleep )\n        local nLines = write( string.sub( sText, 1, n ) )\n        local newX, newY = term.getCursorPos()\n        y = newY - nLines\n    end\nend\n\nfunction slowPrint( sText, nRate )\n    slowWrite( sText, nRate )\n    print()\nend\n\nfunction formatTime( nTime, bTwentyFourHour )\n    if type( nTime ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( nTime ) .. \")\", 2 )\n    end\n    if bTwentyFourHour ~= nil and type( bTwentyFourHour ) ~= \"boolean\" then\n        error( \"bad argument #2 (expected boolean, got \" .. type( bTwentyFourHour ) .. \")\", 2 )\n    end\n    local sTOD = nil\n    if not bTwentyFourHour then\n        if nTime >= 12 then\n            sTOD = \"PM\"\n        else\n            sTOD = \"AM\"\n        end\n        if nTime >= 13 then\n            nTime = nTime - 12\n        end\n    end\n\n    local nHour = math.floor(nTime)\n    local nMinute = math.floor((nTime - nHour)*60)\n    if sTOD then\n        return string.format( \"%d:%02d %s\", nHour, nMinute, sTOD )\n    else\n        return string.format( \"%d:%02d\", nHour, nMinute )\n    end\nend\n\nlocal function makePagedScroll( _term, _nFreeLines )\n    local nativeScroll = _term.scroll\n    local nFreeLines = _nFreeLines or 0\n    return function( _n )\n        for n=1,_n do\n            nativeScroll( 1 )\n\n            if nFreeLines <= 0 then\n                local w,h = _term.getSize()\n                _term.setCursorPos( 1, h )\n                _term.write( \"Press any key to continue\" )\n                os.pullEvent( \"key\" )\n                _term.clearLine()\n                _term.setCursorPos( 1, h )\n            else\n                nFreeLines = nFreeLines - 1\n            end\n        end\n    end\nend\n\nfunction pagedPrint( _sText, _nFreeLines )\n    if _nFreeLines ~= nil and type( _nFreeLines ) ~= \"number\" then\n        error( \"bad argument #2 (expected number, got \" .. type( _nFreeLines ) .. \")\", 2 )\n    end\n    -- Setup a redirector\n    local oldTerm = term.current()\n    local newTerm = {}\n    for k,v in pairs( oldTerm ) do\n        newTerm[k] = v\n    end\n    newTerm.scroll = makePagedScroll( oldTerm, _nFreeLines )\n    term.redirect( newTerm )\n\n    -- Print the text\n    local result\n    local ok, err = pcall( function()\n        if _sText ~= nil then\n            result = print( _sText )\n        else\n            result = print()\n        end\n    end )\n\n    -- Removed the redirector\n    term.redirect( oldTerm )\n\n    -- Propogate errors\n    if not ok then\n        error( err, 0 )\n    end\n    return result\nend\n\nlocal function tabulateCommon( bPaged, ... )\n    local tAll = { ... }\n    for k,v in ipairs( tAll ) do\n        if type( v ) ~= \"number\" and type( v ) ~= \"table\" then\n            error( \"bad argument #\"..k..\" (expected number or table, got \" .. type( v ) .. \")\", 3 )\n        end\n    end\n\n    local w,h = term.getSize()\n    local nMaxLen = w / 8\n    for n, t in ipairs( tAll ) do\n        if type(t) == \"table\" then\n            for nu, sItem in pairs(t) do\n                if type( sItem ) ~= \"string\" then\n                    error( \"bad argument #\"..n..\".\"..nu..\" (expected string, got \" .. type( sItem ) .. \")\", 3 )\n                end\n                nMaxLen = math.max( string.len( sItem ) + 1, nMaxLen )\n            end\n        end\n    end\n    local nCols = math.floor( w / nMaxLen )\n    local nLines = 0\n    local function newLine()\n        if bPaged and nLines >= (h-3) then\n            pagedPrint()\n        else\n            print()\n        end\n        nLines = nLines + 1\n    end\n\n    local function drawCols( _t )\n        local nCol = 1\n        for n, s in ipairs( _t ) do\n            if nCol > nCols then\n                nCol = 1\n                newLine()\n            end\n\n            local cx, cy = term.getCursorPos()\n            cx = 1 + ((nCol - 1) * nMaxLen)\n            term.setCursorPos( cx, cy )\n            term.write( s )\n\n            nCol = nCol + 1\n        end\n        print()\n    end\n    for n, t in ipairs( tAll ) do\n        if type(t) == \"table\" then\n            if #t > 0 then\n                drawCols( t )\n            end\n        elseif type(t) == \"number\" then\n            term.setTextColor( t )\n        end\n    end\nend\n\nfunction tabulate( ... )\n    tabulateCommon( false, ... )\nend\n\nfunction pagedTabulate( ... )\n    tabulateCommon( true, ... )\nend\n\nlocal g_tLuaKeywords = {\n    [ \"and\" ] = true,\n    [ \"break\" ] = true,\n    [ \"do\" ] = true,\n    [ \"else\" ] = true,\n    [ \"elseif\" ] = true,\n    [ \"end\" ] = true,\n    [ \"false\" ] = true,\n    [ \"for\" ] = true,\n    [ \"function\" ] = true,\n    [ \"if\" ] = true,\n    [ \"in\" ] = true,\n    [ \"local\" ] = true,\n    [ \"nil\" ] = true,\n    [ \"not\" ] = true,\n    [ \"or\" ] = true,\n    [ \"repeat\" ] = true,\n    [ \"return\" ] = true,\n    [ \"then\" ] = true,\n    [ \"true\" ] = true,\n    [ \"until\" ] = true,\n    [ \"while\" ] = true,\n}\n\nlocal function serializeImpl( t, tTracking, sIndent )\n    local sType = type(t)\n    if sType == \"table\" then\n        if tTracking[t] ~= nil then\n            error( \"Cannot serialize table with recursive entries\", 0 )\n        end\n        tTracking[t] = true\n\n        if next(t) == nil then\n            -- Empty tables are simple\n            return \"{}\"\n        else\n            -- Other tables take more work\n            local sResult = \"{\\n\"\n            local sSubIndent = sIndent .. \"  \"\n            local tSeen = {}\n            for k,v in ipairs(t) do\n                tSeen[k] = true\n                sResult = sResult .. sSubIndent .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\n            end\n            for k,v in pairs(t) do\n                if not tSeen[k] then\n                    local sEntry\n                    if type(k) == \"string\" and not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\n                        sEntry = k .. \" = \" .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\n                    else\n                        sEntry = \"[ \" .. serializeImpl( k, tTracking, sSubIndent ) .. \" ] = \" .. serializeImpl( v, tTracking, sSubIndent ) .. \",\\n\"\n                    end\n                    sResult = sResult .. sSubIndent .. sEntry\n                end\n            end\n            sResult = sResult .. sIndent .. \"}\"\n            return sResult\n        end\n\n    elseif sType == \"string\" then\n        return string.format( \"%q\", t )\n\n    elseif sType == \"number\" or sType == \"boolean\" or sType == \"nil\" then\n        return tostring(t)\n\n    else\n        error( \"Cannot serialize type \"..sType, 0 )\n\n    end\nend\n\nempty_json_array = {}\n\nlocal function serializeJSONImpl( t, tTracking, bNBTStyle )\n    local sType = type(t)\n    if t == empty_json_array then\n        return \"[]\"\n\n    elseif sType == \"table\" then\n        if tTracking[t] ~= nil then\n            error( \"Cannot serialize table with recursive entries\", 0 )\n        end\n        tTracking[t] = true\n\n        if next(t) == nil then\n            -- Empty tables are simple\n            return \"{}\"\n        else\n            -- Other tables take more work\n            local sObjectResult = \"{\"\n            local sArrayResult = \"[\"\n            local nObjectSize = 0\n            local nArraySize = 0\n            for k,v in pairs(t) do\n                if type(k) == \"string\" then\n                    local sEntry\n                    if bNBTStyle then\n                        sEntry = tostring(k) .. \":\" .. serializeJSONImpl( v, tTracking, bNBTStyle )\n                    else\n                        sEntry = string.format( \"%q\", k ) .. \":\" .. serializeJSONImpl( v, tTracking, bNBTStyle )\n                    end\n                    if nObjectSize == 0 then\n                        sObjectResult = sObjectResult .. sEntry\n                    else\n                        sObjectResult = sObjectResult .. \",\" .. sEntry\n                    end\n                    nObjectSize = nObjectSize + 1\n                end\n            end\n            for n,v in ipairs(t) do\n                local sEntry = serializeJSONImpl( v, tTracking, bNBTStyle )\n                if nArraySize == 0 then\n                    sArrayResult = sArrayResult .. sEntry\n                else\n                    sArrayResult = sArrayResult .. \",\" .. sEntry\n                end\n                nArraySize = nArraySize + 1\n            end\n            sObjectResult = sObjectResult .. \"}\"\n            sArrayResult = sArrayResult .. \"]\"\n            if nObjectSize > 0 or nArraySize == 0 then\n                return sObjectResult\n            else\n                return sArrayResult\n            end\n        end\n\n    elseif sType == \"string\" then\n        return string.format( \"%q\", t )\n\n    elseif sType == \"number\" or sType == \"boolean\" then\n        return tostring(t)\n\n    else\n        error( \"Cannot serialize type \"..sType, 0 )\n\n    end\nend\n\nfunction serialize( t )\n    local tTracking = {}\n    return serializeImpl( t, tTracking, \"\" )\nend\n\nfunction unserialize( s )\n    if type( s ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( s ) .. \")\", 2 )\n    end\n    local func = load( \"return \"..s, \"unserialize\", \"t\", {} )\n    if func then\n        local ok, result = pcall( func )\n        if ok then\n            return result\n        end\n    end\n    return nil\nend\n\nfunction serializeJSON( t, bNBTStyle )\n    if type( t ) ~= \"table\" and type( t ) ~= \"string\" and type( t ) ~= \"number\" and type( t ) ~= \"boolean\" then\n        error( \"bad argument #1 (expected table/string/number/boolean, got \" .. type( t ) .. \")\", 2 )\n    end\n    if bNBTStyle ~= nil and type( bNBTStyle ) ~= \"boolean\" then\n        error( \"bad argument #2 (expected boolean, got \" .. type( bNBTStyle ) .. \")\", 2 )\n    end\n    local tTracking = {}\n    return serializeJSONImpl( t, tTracking, bNBTStyle or false )\nend\n\nfunction urlEncode( str )\n    if type( str ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( str ) .. \")\", 2 )\n    end\n    if str then\n        str = string.gsub(str, \"\\n\", \"\\r\\n\")\n        str = string.gsub(str, \"([^A-Za-z0-9 %-%_%.])\", function(c)\n            local n = string.byte(c)\n            if n < 128 then\n                -- ASCII\n                return string.format(\"%%%02X\", n)\n            else\n                -- Non-ASCII (encode as UTF-8)\n                return\n                    string.format(\"%%%02X\", 192 + bit32.band( bit32.arshift(n,6), 31 ) ) ..\n                    string.format(\"%%%02X\", 128 + bit32.band( n, 63 ) )\n            end\n        end )\n        str = string.gsub(str, \" \", \"+\")\n    end\n    return str\nend\n\nlocal tEmpty = {}\nfunction complete( sSearchText, tSearchTable )\n    if type( sSearchText ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sSearchText ) .. \")\", 2 )\n    end\n    if tSearchTable ~= nil and type( tSearchTable ) ~= \"table\" then\n        error( \"bad argument #2 (expected table, got \" .. type( tSearchTable ) .. \")\", 2 )\n    end\n\n    if g_tLuaKeywords[sSearchText] then return tEmpty end\n    local nStart = 1\n    local nDot = string.find( sSearchText, \".\", nStart, true )\n    local tTable = tSearchTable or _ENV\n    while nDot do\n        local sPart = string.sub( sSearchText, nStart, nDot - 1 )\n        local value = tTable[ sPart ]\n        if type( value ) == \"table\" then\n            tTable = value\n            nStart = nDot + 1\n            nDot = string.find( sSearchText, \".\", nStart, true )\n        else\n            return tEmpty\n        end\n    end\n    local nColon = string.find( sSearchText, \":\", nStart, true )\n    if nColon then\n        local sPart = string.sub( sSearchText, nStart, nColon - 1 )\n        local value = tTable[ sPart ]\n        if type( value ) == \"table\" then\n            tTable = value\n            nStart = nColon + 1\n        else\n            return tEmpty\n        end\n    end\n\n    local sPart = string.sub( sSearchText, nStart )\n    local nPartLength = string.len( sPart )\n\n    local tResults = {}\n    local tSeen = {}\n    while tTable do\n        for k,v in pairs( tTable ) do\n            if not tSeen[k] and type(k) == \"string\" then\n                if string.find( k, sPart, 1, true ) == 1 then\n                    if not g_tLuaKeywords[k] and string.match( k, \"^[%a_][%a%d_]*$\" ) then\n                        local sResult = string.sub( k, nPartLength + 1 )\n                        if nColon then\n                            if type(v) == \"function\" then\n                                table.insert( tResults, sResult .. \"(\" )\n                            elseif type(v) == \"table\" then\n                                local tMetatable = getmetatable( v )\n                                if tMetatable and ( type( tMetatable.__call ) == \"function\" or  type( tMetatable.__call ) == \"table\" ) then\n                                    table.insert( tResults, sResult .. \"(\" )\n                                end\n                            end\n                        else\n                            if type(v) == \"function\" then\n                                sResult = sResult .. \"(\"\n                            elseif type(v) == \"table\" and next(v) ~= nil then\n                                sResult = sResult .. \".\"\n                            end\n                            table.insert( tResults, sResult )\n                        end\n                    end\n                end\n            end\n            tSeen[k] = true\n        end\n        local tMetatable = getmetatable( tTable )\n        if tMetatable and type( tMetatable.__index ) == \"table\" then\n            tTable = tMetatable.__index\n        else\n            tTable = nil\n        end\n    end\n\n    table.sort( tResults )\n    return tResults\nend\n\n-- GB versions\nserialise = serialize\nunserialise = unserialize\nserialiseJSON = serializeJSON","vector.lua":"\nlocal vector = {\n\tadd = function( self, o )\n\t\treturn vector.new(\n\t\t\tself.x + o.x,\n\t\t\tself.y + o.y,\n\t\t\tself.z + o.z\n\t\t)\n\tend,\n\tsub = function( self, o )\n\t\treturn vector.new(\n\t\t\tself.x - o.x,\n\t\t\tself.y - o.y,\n\t\t\tself.z - o.z\n\t\t)\n\tend,\n\tmul = function( self, m )\n\t\treturn vector.new(\n\t\t\tself.x * m,\n\t\t\tself.y * m,\n\t\t\tself.z * m\n\t\t)\n\tend,\n\tdiv = function( self, m )\n\t\treturn vector.new(\n\t\t\tself.x / m,\n\t\t\tself.y / m,\n\t\t\tself.z / m\n\t\t)\n\tend,\n\tunm = function( self )\n\t\treturn vector.new(\n\t\t\t-self.x,\n\t\t\t-self.y,\n\t\t\t-self.z\n\t\t)\n\tend,\n\tdot = function( self, o )\n\t\treturn self.x*o.x + self.y*o.y + self.z*o.z\n\tend,\n\tcross = function( self, o )\n\t\treturn vector.new(\n\t\t\tself.y*o.z - self.z*o.y,\n\t\t\tself.z*o.x - self.x*o.z,\n\t\t\tself.x*o.y - self.y*o.x\n\t\t)\n\tend,\n\tlength = function( self )\n\t\treturn math.sqrt( self.x*self.x + self.y*self.y + self.z*self.z )\n\tend,\n\tnormalize = function( self )\n\t\treturn self:mul( 1 / self:length() )\n\tend,\n\tround = function( self, nTolerance )\n\t    nTolerance = nTolerance or 1.0\n\t\treturn vector.new(\n\t\t\tmath.floor( (self.x + (nTolerance * 0.5)) / nTolerance ) * nTolerance,\n\t\t\tmath.floor( (self.y + (nTolerance * 0.5)) / nTolerance ) * nTolerance,\n\t\t\tmath.floor( (self.z + (nTolerance * 0.5)) / nTolerance ) * nTolerance\n\t\t)\n\tend,\n\ttostring = function( self )\n\t\treturn self.x..\",\"..self.y..\",\"..self.z\n\tend,\n}\n\nlocal vmetatable = {\n\t__index = vector,\n\t__add = vector.add,\n\t__sub = vector.sub,\n\t__mul = vector.mul,\n\t__div = vector.div,\n\t__unm = vector.unm,\n\t__tostring = vector.tostring,\n}\n\nfunction new( x, y, z )\n\tlocal v = {\n\t\tx = tonumber(x) or 0,\n\t\ty = tonumber(y) or 0,\n\t\tz = tonumber(z) or 0\n\t}\n\tsetmetatable( v, vmetatable )\n\treturn v\nend","command":{"commands.lua":"\nif not commands then\n\terror( \"Cannot load command API on normal computer\", 2 )\nend\nnative = commands.native or commands\n\nlocal function collapseArgs( bJSONIsNBT, ... )\n    local args = table.pack(...)\n    for i = 1, #args do\n        local arg = args[i]\n        if type(arg) == \"boolean\" or type(arg) == \"number\" or type(arg) == \"string\" then\n            args[i] = tostring(arg)\n        elseif type(arg) == \"table\" then\n            args[i] = textutils.serialiseJSON( arg, bJSONIsNBT )\n        else\n            error( \"Expected string, number, boolean or table\", 3 )\n        end\n    end\n\n    return table.concat(args, \" \")\nend\n\n-- Put native functions into the environment\nlocal env = _ENV\nfor k,v in pairs( native ) do\n    env[k] = v\nend\n\n-- Create wrapper functions for all the commands\nlocal tAsync = {}\nlocal tNonNBTJSONCommands = {\n    [ \"tellraw\" ] = true,\n    [ \"title\" ] = true\n}\nlocal tCommands = native.list()\nfor n,sCommandName in ipairs(tCommands) do\n    if env[ sCommandName ] == nil then\n        local bJSONIsNBT = (tNonNBTJSONCommands[ sCommandName ] == nil)\n        env[ sCommandName ] = function( ... )\n            local sCommand = collapseArgs( bJSONIsNBT, sCommandName, ... )\n            return native.exec( sCommand )\n        end\n        tAsync[ sCommandName ] = function( ... )\n            local sCommand = collapseArgs( bJSONIsNBT, sCommandName, ... )\n            return native.execAsync( sCommand )\n        end\n    end\nend\nenv.async = tAsync"},"gps.lua":"CHANNEL_GPS = 65534\n\nlocal function trilaterate( A, B, C )\n    local a2b = B.vPosition - A.vPosition\n    local a2c = C.vPosition - A.vPosition\n\n    if math.abs( a2b:normalize():dot( a2c:normalize() ) ) > 0.999 then\n        return nil\n    end\n\n    local d = a2b:length()\n    local ex = a2b:normalize( )\n    local i = ex:dot( a2c )\n    local ey = (a2c - (ex * i)):normalize()\n    local j = ey:dot( a2c )\n    local ez = ex:cross( ey )\n\n    local r1 = A.nDistance\n    local r2 = B.nDistance\n    local r3 = C.nDistance\n\n    local x = (r1*r1 - r2*r2 + d*d) / (2*d)\n    local y = (r1*r1 - r3*r3 - x*x + (x-i)*(x-i) + j*j) / (2*j)\n\n    local result = A.vPosition + (ex * x) + (ey * y)\n\n    local zSquared = r1*r1 - x*x - y*y\n    if zSquared > 0 then\n        local z = math.sqrt( zSquared )\n        local result1 = result + (ez * z)\n        local result2 = result - (ez * z)\n\n        local rounded1, rounded2 = result1:round( 0.01 ), result2:round( 0.01 )\n        if rounded1.x ~= rounded2.x or rounded1.y ~= rounded2.y or rounded1.z ~= rounded2.z then\n            return rounded1, rounded2\n        else\n            return rounded1\n        end\n    end\n    return result:round( 0.01 )\n\nend\n\nlocal function narrow( p1, p2, fix )\n    local dist1 = math.abs( (p1 - fix.vPosition):length() - fix.nDistance )\n    local dist2 = math.abs( (p2 - fix.vPosition):length() - fix.nDistance )\n\n    if math.abs(dist1 - dist2) < 0.01 then\n        return p1, p2\n    elseif dist1 < dist2 then\n        return p1:round( 0.01 )\n    else\n        return p2:round( 0.01 )\n    end\nend\n\nfunction locate( _nTimeout, _bDebug )\n    if _nTimeout ~= nil and type( _nTimeout ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( _nTimeout ) .. \")\", 2 )\n    end\n    if _bDebug ~= nil and type( _bDebug ) ~= \"boolean\" then\n        error( \"bad argument #2 (expected boolean, got \" .. type( _bDebug) .. \")\", 2 )\n    end\n    -- Let command computers use their magic fourth-wall-breaking special abilities\n    if commands then\n        return commands.getBlockPosition()\n    end\n\n    -- Find a modem\n    local sModemSide = nil\n    for n,sSide in ipairs( rs.getSides() ) do\n        if peripheral.getType( sSide ) == \"modem\" and peripheral.call( sSide, \"isWireless\" ) then\n            sModemSide = sSide\n            break\n        end\n    end\n\n    if sModemSide == nil then\n        if _bDebug then\n            print( \"No wireless modem attached\" )\n        end\n        return nil\n    end\n\n    if _bDebug then\n        print( \"Finding position...\" )\n    end\n\n    -- Open a channel\n    local modem = peripheral.wrap( sModemSide )\n    local bCloseChannel = false\n    if not modem.isOpen( os.getComputerID() ) then\n        modem.open( os.getComputerID() )\n        bCloseChannel = true\n    end\n\n    -- Send a ping to listening GPS hosts\n    modem.transmit( CHANNEL_GPS, os.getComputerID(), \"PING\" )\n\n    -- Wait for the responses\n    local tFixes = {}\n    local pos1, pos2 = nil, nil\n    local timeout = os.startTimer( _nTimeout or 2 )\n    while true do\n        local e, p1, p2, p3, p4, p5 = os.pullEvent()\n        if e == \"modem_message\" then\n            -- We received a reply from a modem\n            local sSide, sChannel, sReplyChannel, tMessage, nDistance = p1, p2, p3, p4, p5\n            if sSide == sModemSide and sChannel == os.getComputerID() and sReplyChannel == CHANNEL_GPS and nDistance then\n                -- Received the correct message from the correct modem: use it to determine position\n                if type(tMessage) == \"table\" and #tMessage == 3 and tonumber(tMessage[1]) and tonumber(tMessage[2]) and tonumber(tMessage[3]) then\n                    local tFix = { vPosition = vector.new( tMessage[1], tMessage[2], tMessage[3] ), nDistance = nDistance }\n                    if _bDebug then\n                        print( tFix.nDistance..\" metres from \"..tostring( tFix.vPosition ) )\n                    end\n                    if tFix.nDistance == 0 then\n                        pos1, pos2 = tFix.vPosition, nil\n                    else\n                        table.insert( tFixes, tFix )\n                        if #tFixes >= 3 then\n                            if not pos1 then\n                                pos1, pos2 = trilaterate( tFixes[1], tFixes[2], tFixes[#tFixes] )\n                            else\n                                pos1, pos2 = narrow( pos1, pos2, tFixes[#tFixes] )\n                            end\n                        end\n                    end\n                    if pos1 and not pos2 then\n                        break\n                    end\n                end\n            end\n\n        elseif e == \"timer\" then\n            -- We received a timeout\n            local timer = p1\n            if timer == timeout then\n                break\n            end\n\n        end\n    end\n\n    -- Close the channel, if we opened one\n    if bCloseChannel then\n        modem.close( os.getComputerID() )\n    end\n\n    -- Return the response\n    if pos1 and pos2 then\n        if _bDebug then\n            print( \"Ambiguous position\" )\n            print( \"Could be \"..pos1.x..\",\"..pos1.y..\",\"..pos1.z..\" or \"..pos2.x..\",\"..pos2.y..\",\"..pos2.z )\n        end\n        return nil\n    elseif pos1 then\n        if _bDebug then\n            print( \"Position is \"..pos1.x..\",\"..pos1.y..\",\"..pos1.z )\n        end\n        return pos1.x, pos1.y, pos1.z\n    else\n        if _bDebug then\n            print( \"Could not determine position\" )\n        end\n        return nil\n    end\nend","keys.lua":"\n-- Minecraft key code bindings\n-- See http://www.minecraftwiki.net/wiki/Key_codes for more info\n\nlocal tKeys = {\n    nil,\t \t\"one\", \t\t\"two\", \t\t\"three\", \t\"four\",\t\t\t-- 1\n    \"five\", \t\"six\", \t\t\"seven\", \t\"eight\", \t\"nine\",\t\t\t-- 6\n    \"zero\", \t\"minus\", \t\"equals\", \t\"backspace\",\"tab\",\t\t\t-- 11\n    \"q\", \t\t\"w\", \t\t\"e\", \t\t\"r\",\t\t\"t\",\t\t\t-- 16\n    \"y\",\t\t\"u\",\t\t\"i\",\t\t\"o\",\t\t\"p\",\t\t\t-- 21\n    \"leftBracket\",\"rightBracket\",\"enter\",\"leftCtrl\",\"a\",\t\t\t-- 26\n    \"s\",\t\t\"d\",\t\t\"f\",\t\t\"g\",\t\t\"h\",\t\t\t-- 31\n    \"j\",\t\t\"k\",\t\t\"l\",\t\t\"semiColon\",\"apostrophe\",\t-- 36\n    \"grave\",\t\"leftShift\",\"backslash\",\"z\",\t\t\"x\",\t\t\t-- 41\n    \"c\",\t\t\"v\",\t\t\"b\",\t\t\"n\",\t\t\"m\",\t\t\t-- 46\n    \"comma\",\t\"period\",\t\"slash\",\t\"rightShift\",\"multiply\",\t-- 51\n    \"leftAlt\",\t\"space\",\t\"capsLock\",\t\"f1\",\t\t\"f2\",\t\t\t-- 56\n    \"f3\",\t\t\"f4\",\t\t\"f5\",\t\t\"f6\",\t\t\"f7\",\t\t\t-- 61\n    \"f8\",\t\t\"f9\",\t\t\"f10\",\t\t\"numLock\",\t\"scrollLock\",\t-- 66\n    \"numPad7\",\t\"numPad8\",\t\"numPad9\",\t\"numPadSubtract\",\"numPad4\",\t-- 71\n    \"numPad5\",\t\"numPad6\",\t\"numPadAdd\",\"numPad1\",\t\"numPad2\",\t\t-- 76\n    \"numPad3\",\t\"numPad0\",\t\"numPadDecimal\",nil,\tnil,\t\t\t-- 81\n    nil,\t \t\"f11\",\t\t\"f12\",\t\tnil,\t\tnil,\t\t\t-- 86\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 91\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\t\"f13\",\t\t\t-- 96\n    \"f14\",\t\t\"f15\",\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 101\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 106\n    nil,\t\t\"kana\",\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 111\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 116\n    \"convert\",\tnil,\t\t\"noconvert\",nil,\t\t\"yen\",\t\t\t-- 121\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 126\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 131\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 136\n    \"numPadEquals\",nil,\t\tnil,\t\t\"circumflex\",\"at\",\t\t\t-- 141\n    \"colon\",\t\"underscore\",\"kanji\",\t\"stop\",\t\t\"ax\",\t\t\t-- 146\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 151\n    \"numPadEnter\",\"rightCtrl\",nil,      nil,\t\tnil,\t\t\t-- 156\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 161\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 166\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 171\n    nil,\t\tnil,\t\tnil,\t\t\"numPadComma\",nil,\t\t\t-- 176\n    \"numPadDivide\",nil,\t\tnil,\t\t\"rightAlt\",\tnil,\t\t\t-- 181\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 186\n    nil,\t\tnil,\t\tnil,\t\tnil,\t\tnil,\t\t\t-- 191\n    nil,\t\t\"pause\",\tnil,\t\t\"home\",\t\t\"up\",\t\t\t-- 196\n    \"pageUp\",\tnil,\t\t\"left\",\t\tnil,\t\t\"right\",\t\t-- 201\n    nil,\t\t\"end\",\t\t\"down\",\t\t\"pageDown\",\t\"insert\",\t\t-- 206\n    \"delete\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- 211\n}\n\nlocal keys = _ENV\nfor nKey, sKey in pairs( tKeys ) do\n    keys[sKey] = nKey\nend\nkeys[\"return\"] = keys.enter\n--backwards compatibility to earlier, typo prone, versions\nkeys.scollLock = keys.scrollLock\nkeys.cimcumflex = keys.circumflex\n\nfunction getName( _nKey )\n    if type( _nKey ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( _nKey ) .. \")\", 2 )\n    end\n    return tKeys[ _nKey ]\nend","disk.lua":"\nlocal function isDrive( name )\n    if type( name ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( name ) .. \")\", 3 )\n    end\n    return peripheral.getType( name ) == \"drive\"\nend\n\nfunction isPresent( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"isDiskPresent\" )\n    end\n    return false\nend\n\nfunction getLabel( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"getDiskLabel\" )\n    end\n    return nil\nend\n\nfunction setLabel( name, label )\n    if isDrive( name ) then\n        peripheral.call( name, \"setDiskLabel\", label )\n    end\nend\n\nfunction hasData( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"hasData\" )\n    end\n    return false\nend\n\nfunction getMountPath( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"getMountPath\" )\n    end\n    return nil\nend\n\nfunction hasAudio( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"hasAudio\" )\n    end\n    return false\nend\n\nfunction getAudioTitle( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"getAudioTitle\" )\n    end\n    return nil\nend\n\nfunction playAudio( name )\n    if isDrive( name ) then\n        peripheral.call( name, \"playAudio\" )\n    end\nend\n\nfunction stopAudio( name )\n    if not name then\n        for n,sName in ipairs( peripheral.getNames() ) do\n            stopAudio( sName )\n        end\n    else\n        if isDrive( name ) then\n            peripheral.call( name, \"stopAudio\" )\n        end\n    end\nend\n\nfunction eject( name )\n    if isDrive( name ) then\n        peripheral.call( name, \"ejectDisk\" )\n    end\nend\n\nfunction getID( name )\n    if isDrive( name ) then\n        return peripheral.call( name, \"getDiskID\" )\n    end\n    return nil\nend\n","peripheral.lua":"local native = peripheral\n\nfunction getNames()\n    local tResults = {}\n    for n,sSide in ipairs( rs.getSides() ) do\n        if native.isPresent( sSide ) then\n            table.insert( tResults, sSide )\n            if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\n                local tRemote = native.call( sSide, \"getNamesRemote\" )\n                for n,sName in ipairs( tRemote ) do\n                    table.insert( tResults, sName )\n                end\n            end\n        end\n    end\n    return tResults\nend\n\nfunction isPresent( _sSide )\n    if type( _sSide ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sSide ) .. \")\", 2 )\n    end\n    if native.isPresent( _sSide ) then\n        return true\n    end\n    for n,sSide in ipairs( rs.getSides() ) do\n        if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\n            if native.call( sSide, \"isPresentRemote\", _sSide )  then\n                return true\n            end\n        end\n    end\n    return false\nend\n\nfunction getType( _sSide )\n    if type( _sSide ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sSide ) .. \")\", 2 )\n    end\n    if native.isPresent( _sSide ) then\n        return native.getType( _sSide )\n    end\n    for n,sSide in ipairs( rs.getSides() ) do\n        if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\n            if native.call( sSide, \"isPresentRemote\", _sSide )  then\n                return native.call( sSide, \"getTypeRemote\", _sSide )\n            end\n        end\n    end\n    return nil\nend\n\nfunction getMethods( _sSide )\n    if type( _sSide ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sSide ) .. \")\", 2 )\n    end\n    if native.isPresent( _sSide ) then\n        return native.getMethods( _sSide )\n    end\n    for n,sSide in ipairs( rs.getSides() ) do\n        if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\n            if native.call( sSide, \"isPresentRemote\", _sSide )  then\n                return native.call( sSide, \"getMethodsRemote\", _sSide )\n            end\n        end\n    end\n    return nil\nend\n\nfunction call( _sSide, _sMethod, ... )\n    if type( _sSide ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sSide ) .. \")\", 2 )\n    end\n    if type( _sSide ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( _sMethod ) .. \")\", 2 )\n    end\n    if native.isPresent( _sSide ) then\n        return native.call( _sSide, _sMethod, ... )\n    end\n    for n,sSide in ipairs( rs.getSides() ) do\n        if native.getType( sSide ) == \"modem\" and not native.call( sSide, \"isWireless\" ) then\n            if native.call( sSide, \"isPresentRemote\", _sSide )  then\n                return native.call( sSide, \"callRemote\", _sSide, _sMethod, ... )\n            end\n        end\n    end\n    return nil\nend\n\nfunction wrap( _sSide )\n    if type( _sSide ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sSide ) .. \")\", 2 )\n    end\n    if peripheral.isPresent( _sSide ) then\n        local tMethods = peripheral.getMethods( _sSide )\n        local tResult = {}\n        for n,sMethod in ipairs( tMethods ) do\n            tResult[sMethod] = function( ... )\n                return peripheral.call( _sSide, sMethod, ... )\n            end\n        end\n        return tResult\n    end\n    return nil\nend\n\nfunction find( sType, fnFilter )\n    if type( sType ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sType ) .. \")\", 2 )\n    end\n    if fnFilter ~= nil and type( fnFilter ) ~= \"function\" then\n        error( \"bad argument #2 (expected function, got \" .. type( fnFilter ) .. \")\", 2 )\n    end\n    local tResults = {}\n    for n,sName in ipairs( peripheral.getNames() ) do\n        if peripheral.getType( sName ) == sType then\n            local wrapped = peripheral.wrap( sName )\n            if fnFilter == nil or fnFilter( sName, wrapped ) then\n                table.insert( tResults, wrapped )\n            end\n        end\n    end\n    return table.unpack( tResults )\nend","paintutils.lua":"\nlocal function drawPixelInternal( xPos, yPos )\n    term.setCursorPos( xPos, yPos )\n    term.write(\" \")\nend\n\nlocal tColourLookup = {}\nfor n=1,16 do\n    tColourLookup[ string.byte( \"0123456789abcdef\",n,n ) ] = 2^(n-1)\nend\n\nlocal function parseLine( tImageArg, sLine )\n    local tLine = {}\n    for x=1,sLine:len() do\n        tLine[x] = tColourLookup[ string.byte(sLine,x,x) ] or 0\n    end\n    table.insert( tImageArg, tLine )\nend\n\nfunction parseImage( sRawData )\n    if type( sRawData ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sRawData ) .. \")\" )\n    end\n    local tImage = {}\n    for sLine in ( sRawData .. \"\\n\" ):gmatch( \"(.-)\\n\" ) do -- read each line like original file handling did\n        parseLine( tImage, sLine )\n    end\n    return tImage\nend\n\nfunction loadImage( sPath )\n    if type( sPath ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sPath ) .. \")\", 2 )\n    end\n\n    if fs.exists( sPath ) then\n        local file = io.open( sPath, \"r\" )\n        local sContent = file:read(\"*a\")\n        file:close()\n        return parseImage( sContent ) -- delegate image parse to parseImage\n    end\n    return nil\nend\n\nfunction drawPixel( xPos, yPos, nColour )\n    if type( xPos ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( xPos ) .. \")\", 2 ) end\n    if type( yPos ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( yPos ) .. \")\", 2 ) end\n    if nColour ~= nil and type( nColour ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( nColour ) .. \")\", 2 ) end\n    if nColour then\n        term.setBackgroundColor( nColour )\n    end\n    drawPixelInternal( xPos, yPos )\nend\n\nfunction drawLine( startX, startY, endX, endY, nColour )\n    if type( startX ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( startX ) .. \")\", 2 ) end\n    if type( startY ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( startY ) .. \")\", 2 ) end\n    if type( endX ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( endX ) .. \")\", 2 ) end\n    if type( endY ) ~= \"number\" then error( \"bad argument #4 (expected number, got \" .. type( endY ) .. \")\", 2 ) end\n    if nColour ~= nil and type( nColour ) ~= \"number\" then error( \"bad argument #5 (expected number, got \" .. type( nColour ) .. \")\", 2 ) end\n\n    startX = math.floor(startX)\n    startY = math.floor(startY)\n    endX = math.floor(endX)\n    endY = math.floor(endY)\n\n    if nColour then\n        term.setBackgroundColor( nColour )\n    end\n    if startX == endX and startY == endY then\n        drawPixelInternal( startX, startY )\n        return\n    end\n\n    local minX = math.min( startX, endX )\n    local maxX, minY, maxY\n    if minX == startX then\n        minY = startY\n        maxX = endX\n        maxY = endY\n    else\n        minY = endY\n        maxX = startX\n        maxY = startY\n    end\n\n    -- TODO: clip to screen rectangle?\n\n    local xDiff = maxX - minX\n    local yDiff = maxY - minY\n\n    if xDiff > math.abs(yDiff) then\n        local y = minY\n        local dy = yDiff / xDiff\n        for x=minX,maxX do\n            drawPixelInternal( x, math.floor( y + 0.5 ) )\n            y = y + dy\n        end\n    else\n        local x = minX\n        local dx = xDiff / yDiff\n        if maxY >= minY then\n            for y=minY,maxY do\n                drawPixelInternal( math.floor( x + 0.5 ), y )\n                x = x + dx\n            end\n        else\n            for y=minY,maxY,-1 do\n                drawPixelInternal( math.floor( x + 0.5 ), y )\n                x = x - dx\n            end\n        end\n    end\nend\n\nfunction drawBox( startX, startY, endX, endY, nColour )\n    if type( startX ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( startX ) .. \")\", 2 ) end\n    if type( startY ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( startY ) .. \")\", 2 ) end\n    if type( endX ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( endX ) .. \")\", 2 ) end\n    if type( endY ) ~= \"number\" then error( \"bad argument #4 (expected number, got \" .. type( endY ) .. \")\", 2 ) end\n    if nColour ~= nil and type( nColour ) ~= \"number\" then error( \"bad argument #5 (expected number, got \" .. type( nColour ) .. \")\", 2 ) end\n\n    startX = math.floor(startX)\n    startY = math.floor(startY)\n    endX = math.floor(endX)\n    endY = math.floor(endY)\n\n    if nColour then\n        term.setBackgroundColor( nColour )\n    end\n    if startX == endX and startY == endY then\n        drawPixelInternal( startX, startY )\n        return\n    end\n\n    local minX = math.min( startX, endX )\n    local maxX, minY, maxY\n    if minX == startX then\n        minY = startY\n        maxX = endX\n        maxY = endY\n    else\n        minY = endY\n        maxX = startX\n        maxY = startY\n    end\n\n    for x=minX,maxX do\n        drawPixelInternal( x, minY )\n        drawPixelInternal( x, maxY )\n    end\n\n    if (maxY - minY) >= 2 then\n        for y=(minY+1),(maxY-1) do\n            drawPixelInternal( minX, y )\n            drawPixelInternal( maxX, y )\n        end\n    end\nend\n\nfunction drawFilledBox( startX, startY, endX, endY, nColour )\n    if type( startX ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( startX ) .. \")\", 2 ) end\n    if type( startY ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( startY ) .. \")\", 2 ) end\n    if type( endX ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( endX ) .. \")\", 2 ) end\n    if type( endY ) ~= \"number\" then error( \"bad argument #4 (expected number, got \" .. type( endY ) .. \")\", 2 ) end\n    if nColour ~= nil and type( nColour ) ~= \"number\" then error( \"bad argument #5 (expected number, got \" .. type( nColour ) .. \")\", 2 ) end\n\n    startX = math.floor(startX)\n    startY = math.floor(startY)\n    endX = math.floor(endX)\n    endY = math.floor(endY)\n\n    if nColour then\n        term.setBackgroundColor( nColour )\n    end\n    if startX == endX and startY == endY then\n        drawPixelInternal( startX, startY )\n        return\n    end\n\n    local minX = math.min( startX, endX )\n    local maxX, minY, maxY\n    if minX == startX then\n        minY = startY\n        maxX = endX\n        maxY = endY\n    else\n        minY = endY\n        maxX = startX\n        maxY = startY\n    end\n\n    for x=minX,maxX do\n        for y=minY,maxY do\n            drawPixelInternal( x, y )\n        end\n    end\nend\n\nfunction drawImage( tImage, xPos, yPos )\n    if type( tImage ) ~= \"table\" then error( \"bad argument #1 (expected table, got \" .. type( tImage ) .. \")\", 2 ) end\n    if type( xPos ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( xPos ) .. \")\", 2 ) end\n    if type( yPos ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( yPos ) .. \")\", 2 ) end\n    for y=1,#tImage do\n        local tLine = tImage[y]\n        for x=1,#tLine do\n            if tLine[x] > 0 then\n                term.setBackgroundColor( tLine[x] )\n                drawPixelInternal( x + xPos - 1, y + yPos - 1 )\n            end\n        end\n    end\nend","io.lua":"-- Definition for the IO API\nlocal typeOf = _G.type\n\n--- If we return nil then close the file, as we've reached the end.\n-- We use this weird wrapper function as we wish to preserve the varargs\nlocal function checkResult(handle, ...)\n    if ... == nil and handle._autoclose and not handle._closed then handle:close() end\n    return ...\nend\n\nlocal handleMetatable\nhandleMetatable = {\n    __name = \"FILE*\",\n    __tostring = function(self)\n        if self._closed then\n            return \"file (closed)\"\n        else\n            local hash = tostring(self._handle):match(\"table: (%x+)\")\n            return \"file (\" .. hash .. \")\"\n        end\n    end,\n    __index = {\n        close = function(self)\n            if typeOf(self) ~= \"table\" or getmetatable(self) ~= handleMetatable then\n                error(\"bad argument #1 (FILE expected, got \" .. typeOf(self) .. \")\", 2)\n            end\n            if self._closed then error(\"attempt to use a closed file\", 2) end\n\n            local handle = self._handle\n            if handle.close then\n                self._closed = true\n                handle.close()\n                return true\n            else\n                return nil, \"attempt to close standard stream\"\n            end\n        end,\n        flush = function(self)\n            if typeOf(self) ~= \"table\" or getmetatable(self) ~= handleMetatable then\n                error(\"bad argument #1 (FILE expected, got \" .. typeOf(self) .. \")\", 2)\n            end\n            if self._closed then error(\"attempt to use a closed file\", 2) end\n\n            local handle = self._handle\n            if handle.flush then handle.flush() end\n        end,\n        lines = function(self, ...)\n            if typeOf(self) ~= \"table\" or getmetatable(self) ~= handleMetatable then\n                error(\"bad argument #1 (FILE expected, got \" .. typeOf(self) .. \")\", 2)\n            end\n            if self._closed then error(\"attempt to use a closed file\", 2) end\n\n            local handle = self._handle\n            if not handle.read then return nil, \"file is not readable\" end\n\n            local args = table.pack(...)\n            return function() return checkResult(self, self:read(table.unpack(args, 1, args.n))) end\n        end,\n        read = function(self, ...)\n            if typeOf(self) ~= \"table\" or getmetatable(self) ~= handleMetatable then\n                error(\"bad argument #1 (FILE expected, got \" .. typeOf(self) .. \")\", 2)\n            end\n            if self._closed then error(\"attempt to use a closed file\", 2) end\n\n            local handle = self._handle\n            if not handle.read and not handle.readLine then return nil, \"Not opened for reading\" end\n\n            local n = select('#', ...)\n            local output = {}\n            for i = 1, n do\n                local arg = select(i, ...)\n                local res\n                if typeOf(arg) == \"number\" then\n                    if handle.read then res = handle.read(arg) end\n                elseif typeOf(arg) == \"string\" then\n                    local format = arg:gsub(\"^%*\", \"\"):sub(1, 1)\n\n                    if format == \"l\" then\n                        if handle.readLine then res = handle.readLine() end\n                    elseif format == \"L\" and handle.readLine then\n                        if handle.readLine then res = handle.readLine(true) end\n                    elseif format == \"a\" then\n                        if handle.readAll then res = handle.readAll() or \"\" end\n                    elseif format == \"n\" then\n                        res = nil -- Skip this format as we can't really handle it\n                    else\n                        error(\"bad argument #\" .. i .. \" (invalid format)\", 2)\n                    end\n                else\n                    error(\"bad argument #\" .. i .. \" (expected string, got \" .. typeOf(arg) .. \")\", 2)\n                end\n\n                output[i] = res\n                if not res then break end\n            end\n\n            -- Default to \"l\" if possible\n            if n == 0 and handle.readLine then return handle.readLine() end\n            return table.unpack(output, 1, n)\n        end,\n        seek = function(self, whence, offset)\n            if typeOf(self) ~= \"table\" or getmetatable(self) ~= handleMetatable then\n                error(\"bad argument #1 (FILE expected, got \" .. typeOf(self) .. \")\", 2)\n            end\n            if self._closed then error(\"attempt to use a closed file\", 2) end\n\n            local handle = self._handle\n            if not handle.seek then return nil, \"file is not seekable\" end\n\n            -- It's a tail call, so error positions are preserved\n            return handle.seek(whence, offset)\n        end,\n        setvbuf = function(self, mode, size) end,\n        write = function(self, ...)\n            if typeOf(self) ~= \"table\" or getmetatable(self) ~= handleMetatable then\n                error(\"bad argument #1 (FILE expected, got \" .. typeOf(self) .. \")\", 2)\n            end\n            if self._closed then error(\"attempt to use a closed file\", 2) end\n\n            local handle = self._handle\n            if not handle.write then return nil, \"file is not writable\" end\n\n            local n = select(\"#\", ...)\n            for i = 1, n do handle.write(select(i, ...)) end\n            return self\n        end,\n    },\n}\n\nlocal defaultInput = setmetatable({\n    _handle = { readLine = _G.read }\n}, handleMetatable)\n\nlocal defaultOutput = setmetatable({\n    _handle = { write = _G.write }\n}, handleMetatable)\n\nlocal defaultError = setmetatable({\n    _handle = {\n        write = function(...)\n            local oldColour\n            if term.isColour() then\n                oldColour = term.getTextColour()\n                term.setTextColour(colors.red)\n            end\n            _G.write(...)\n            if term.isColour() then term.setTextColour(oldColour) end\n        end,\n    }\n}, handleMetatable)\n\nlocal currentInput = defaultInput\nlocal currentOutput = defaultOutput\n\nstdin = defaultInput\nstdout = defaultOutput\nstderr = defaultError\n\nfunction close(_file)\n    if _file == nil then return currentOutput:close() end\n\n    if typeOf(_file) ~= \"table\" or getmetatable(_file) ~= handleMetatable then\n        error(\"bad argument #1 (FILE expected, got \" .. typeOf(_file) .. \")\", 2)\n    end\n    return _file:close()\nend\n\nfunction flush()\n    return currentOutput:flush()\nend\n\nfunction input(_arg)\n    if typeOf(_arg) == \"string\" then\n        local res, err = open(_arg, \"rb\")\n        if not res then error(err, 2) end\n        currentInput = res\n    elseif typeOf(_arg) == \"table\" and getmetatable(_arg) == handleMetatable then\n        currentInput = _arg\n    elseif _arg ~= nil then\n        error(\"bad argument #1 (FILE expected, got \" .. typeOf(_arg) .. \")\", 2)\n    end\n\n    return currentInput\nend\n\nfunction lines(_sFileName)\n    if _sFileName ~= nil and typeOf(_sFileName) ~= \"string\" then\n        error(\"bad argument #1 (expected string, got \" .. typeOf(_sFileName) .. \")\", 2)\n    end\n    if _sFileName then\n        local ok, err = open(_sFileName, \"rb\")\n        if not ok then error(err, 2) end\n\n        -- We set this magic flag to mark this file as being opened by io.lines and so should be\n        -- closed automatically\n        ok._autoclose = true\n        return ok:lines()\n    else\n        return currentInput:lines()\n    end\nend\n\nfunction open(_sPath, _sMode)\n    if typeOf(_sPath) ~= \"string\" then\n        error(\"bad argument #1 (expected string, got \" .. typeOf(_sPath) .. \")\", 2)\n    end\n    if _sMode ~= nil and typeOf(_sMode) ~= \"string\" then\n        error(\"bad argument #2 (expected string, got \" .. typeOf(_sMode) .. \")\", 2)\n    end\n\n    local sMode = _sMode and _sMode:gsub(\"%+\", \"\") or \"rb\"\n    local file, err = fs.open(_sPath, sMode)\n    if not file then return nil, err end\n\n    return setmetatable({ _handle = file }, handleMetatable)\nend\n\nfunction output(_arg)\n    if typeOf(_arg) == \"string\" then\n        local res, err = open(_arg, \"w\")\n        if not res then error(err, 2) end\n        currentOutput = res\n    elseif typeOf(_arg) == \"table\" and getmetatable(_arg) == handleMetatable then\n        currentOutput = _arg\n    elseif _arg ~= nil then\n        error(\"bad argument #1 (FILE expected, got \" .. typeOf(_arg) .. \")\", 2)\n    end\n\n    return currentOutput\nend\n\nfunction read(...)\n    return currentInput:read(...)\nend\n\nfunction type(handle)\n    if typeOf(handle) == \"table\" and getmetatable(handle) == handleMetatable then\n        if handle._closed then\n            return \"closed file\"\n        else\n            return \"file\"\n        end\n    end\n    return nil\nend\n\nfunction write(...)\n    return currentOutput:write(...)\nend","colors.lua":"-- Colors\nwhite = 1\norange = 2\nmagenta = 4\nlightBlue = 8\nyellow = 16\nlime = 32\npink = 64\ngray = 128\nlightGray = 256\ncyan = 512\npurple = 1024\nblue = 2048\nbrown = 4096\ngreen = 8192\nred = 16384\nblack = 32768\n\nfunction combine( ... )\n    local r = 0\n    for n,c in ipairs( { ... } ) do\n        if type( c ) ~= \"number\" then\n            error( \"bad argument #\"..n..\" (expected number, got \" .. type( c ) .. \")\", 2 )\n        end\n        r = bit32.bor(r,c)\n    end\n    return r\nend\n\nfunction subtract( colors, ... )\n    if type( colors ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( colors ) .. \")\", 2 )\n    end\n    local r = colors\n    for n,c in ipairs( { ... } ) do\n        if type( c ) ~= \"number\" then\n            error( \"bad argument #\"..tostring( n+1 )..\" (expected number, got \" .. type( c ) .. \")\", 2 )\n        end\n        r = bit32.band(r, bit32.bnot(c))\n    end\n    return r\nend\n\nfunction test( colors, color )\n    if type( colors ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( colors ) .. \")\", 2 )\n    end\n    if type( color ) ~= \"number\" then\n        error( \"bad argument #2 (expected number, got \" .. type( color ) .. \")\", 2 )\n    end\n    return bit32.band(colors, color) == color\nend\n\nfunction packRGB( r, g, b )\n    if type( r ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( r ) .. \")\", 2 )\n    end\n    if type( g ) ~= \"number\" then\n        error( \"bad argument #2 (expected number, got \" .. type( g ) .. \")\", 2 )\n    end\n    if type( b ) ~= \"number\" then\n        error( \"bad argument #3 (expected number, got \" .. type( b ) .. \")\", 2 )\n    end\n    return\n        bit32.band( r * 255, 0xFF ) * 2^16 +\n        bit32.band( g * 255, 0xFF ) * 2^8 +\n        bit32.band( b * 255, 0xFF )\nend\n\nfunction unpackRGB( rgb )\n    if type( rgb ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( rgb ) .. \")\", 2 )\n    end\n    return\n        bit32.band( bit32.rshift( rgb, 16 ), 0xFF ) / 255,\n        bit32.band( bit32.rshift( rgb, 8 ), 0xFF ) / 255,\n        bit32.band( rgb, 0xFF ) / 255\nend\n\nfunction rgb8( r, g, b )\n    if g == nil and b == nil then\n        return unpackRGB( r )\n    else\n        return packRGB( r, g, b )\n    end\nend","parallel.lua":"\nlocal function create( ... )\n    local tFns = table.pack(...)\n    local tCos = {}\n    for i = 1, tFns.n, 1 do\n        local fn = tFns[i]\n        if type( fn ) ~= \"function\" then\n            error( \"bad argument #\" .. i .. \" (expected function, got \" .. type( fn ) .. \")\", 3 )\n        end\n\n        tCos[i] = coroutine.create(fn)\n    end\n\n    return tCos\nend\n\nlocal function runUntilLimit( _routines, _limit )\n    local count = #_routines\n    local living = count\n\n    local tFilters = {}\n    local eventData = { n = 0 }\n    while true do\n        for n=1,count do\n            local r = _routines[n]\n            if r then\n                if tFilters[r] == nil or tFilters[r] == eventData[1] or eventData[1] == \"terminate\" then\n                    local ok, param = coroutine.resume( r, table.unpack( eventData, 1, eventData.n ) )\n                    if not ok then\n                        error( param, 0 )\n                    else\n                        tFilters[r] = param\n                    end\n                    if coroutine.status( r ) == \"dead\" then\n                        _routines[n] = nil\n                        living = living - 1\n                        if living <= _limit then\n                            return n\n                        end\n                    end\n                end\n            end\n        end\n        for n=1,count do\n            local r = _routines[n]\n            if r and coroutine.status( r ) == \"dead\" then\n                _routines[n] = nil\n                living = living - 1\n                if living <= _limit then\n                    return n\n                end\n            end\n        end\n        eventData = table.pack( os.pullEventRaw() )\n    end\nend\n\nfunction waitForAny( ... )\n    local routines = create( ... )\n    return runUntilLimit( routines, #routines - 1 )\nend\n\nfunction waitForAll( ... )\n    local routines = create( ... )\n    runUntilLimit( routines, 0 )\nend","term.lua":"\nlocal native = (term.native and term.native()) or term\nlocal redirectTarget = native\n\nlocal function wrap( _sFunction )\n    return function( ... )\n        return redirectTarget[ _sFunction ]( ... )\n    end\nend\n\nlocal term = {}\n\nterm.redirect = function( target )\n    if type( target ) ~= \"table\" then\n        error( \"bad argument #1 (expected table, got \" .. type( target ) .. \")\", 2 )\n    end\n    if target == term then\n        error( \"term is not a recommended redirect target, try term.current() instead\", 2 )\n    end\n    for k,v in pairs( native ) do\n        if type( k ) == \"string\" and type( v ) == \"function\" then\n            if type( target[k] ) ~= \"function\" then\n                target[k] = function()\n                    error( \"Redirect object is missing method \"..k..\".\", 2 )\n                end\n            end\n        end\n    end\n    local oldRedirectTarget = redirectTarget\n    redirectTarget = target\n    return oldRedirectTarget\nend\n\nterm.current = function()\n    return redirectTarget\nend\n\nterm.native = function()\n    -- NOTE: please don't use this function unless you have to.\n    -- If you're running in a redirected or multitasked enviorment, term.native() will NOT be\n    -- the current terminal when your program starts up. It is far better to use term.current()\n    return native\nend\n\n-- Some methods shouldn't go through redirects, so we move them to the main\n-- term API.\nfor _, method in ipairs { \"nativePaletteColor\", \"nativePaletteColour\"} do\n    term[method] = native[method]\n    native[method] = nil\nend\n\nfor k,v in pairs( native ) do\n    if type( k ) == \"string\" and type( v ) == \"function\" and term[k] == nil then\n        term[k] = wrap( k )\n    end\nend\n\nlocal env = _ENV\nfor k,v in pairs( term ) do\n    env[k] = v\nend","window.lua":"\nlocal tHex = {\n    [ colors.white ] = \"0\",\n    [ colors.orange ] = \"1\",\n    [ colors.magenta ] = \"2\",\n    [ colors.lightBlue ] = \"3\",\n    [ colors.yellow ] = \"4\",\n    [ colors.lime ] = \"5\",\n    [ colors.pink ] = \"6\",\n    [ colors.gray ] = \"7\",\n    [ colors.lightGray ] = \"8\",\n    [ colors.cyan ] = \"9\",\n    [ colors.purple ] = \"a\",\n    [ colors.blue ] = \"b\",\n    [ colors.brown ] = \"c\",\n    [ colors.green ] = \"d\",\n    [ colors.red ] = \"e\",\n    [ colors.black ] = \"f\",\n}\n\nlocal type = type\nlocal string_rep = string.rep\nlocal string_sub = string.sub\nlocal table_unpack = table.unpack\n\nfunction create( parent, nX, nY, nWidth, nHeight, bStartVisible )\n    if type( parent ) ~= \"table\" then error( \"bad argument #1 (expected table, got \" .. type( parent ) .. \")\", 2 ) end\n    if type( nX ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( nX ) .. \")\", 2 ) end\n    if type( nY ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( nY ) .. \")\", 2 ) end\n    if type( nWidth ) ~= \"number\" then error( \"bad argument #4 (expected number, got \" .. type( nWidth ) .. \")\", 2 ) end\n    if type( nHeight ) ~= \"number\" then error( \"bad argument #5 (expected number, got \" .. type( nHeight ) .. \")\", 2 ) end\n    if bStartVisible ~= nil and type( bStartVisible ) ~= \"boolean\" then error( \"bad argument #6 (expected boolean, got \" .. type( bStartVisible ) .. \")\", 2 ) end\n\n    if parent == term then\n        error( \"term is not a recommended window parent, try term.current() instead\", 2 )\n    end\n\n    local sEmptySpaceLine\n    local tEmptyColorLines = {}\n    local function createEmptyLines( nWidth )\n        sEmptySpaceLine = string_rep( \" \", nWidth )\n        for n=0,15 do\n            local nColor = 2^n\n            local sHex = tHex[nColor]\n            tEmptyColorLines[nColor] = string_rep( sHex, nWidth )\n        end\n    end\n\n    createEmptyLines( nWidth )\n\n    -- Setup\n    local bVisible = (bStartVisible ~= false)\n    local nCursorX = 1\n    local nCursorY = 1\n    local bCursorBlink = false\n    local nTextColor = colors.white\n    local nBackgroundColor = colors.black\n    local tLines = {}\n    local tPalette = {}\n    do\n        local sEmptyText = sEmptySpaceLine\n        local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\n        local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\n        for y=1,nHeight do\n            tLines[y] = {\n                text = sEmptyText,\n                textColor = sEmptyTextColor,\n                backgroundColor = sEmptyBackgroundColor,\n            }\n        end\n\n        for i=0,15 do\n            local c = 2 ^ i\n            tPalette[c] = { parent.getPaletteColour( c ) }\n        end\n    end\n\n    -- Helper functions\n    local function updateCursorPos()\n        if nCursorX >= 1 and nCursorY >= 1 and\n           nCursorX <= nWidth and nCursorY <= nHeight then\n            parent.setCursorPos( nX + nCursorX - 1, nY + nCursorY - 1 )\n        else\n            parent.setCursorPos( 0, 0 )\n        end\n    end\n\n    local function updateCursorBlink()\n        parent.setCursorBlink( bCursorBlink )\n    end\n\n    local function updateCursorColor()\n        parent.setTextColor( nTextColor )\n    end\n\n    local function redrawLine( n )\n        local tLine = tLines[ n ]\n        parent.setCursorPos( nX, nY + n - 1 )\n        parent.blit( tLine.text, tLine.textColor, tLine.backgroundColor )\n    end\n\n    local function redraw()\n        for n=1,nHeight do\n            redrawLine( n )\n        end\n    end\n\n    local function updatePalette()\n        for k,v in pairs( tPalette ) do\n            parent.setPaletteColour( k, v[1], v[2], v[3] )\n        end\n    end\n\n    local function internalBlit( sText, sTextColor, sBackgroundColor )\n        local nStart = nCursorX\n        local nEnd = nStart + #sText - 1\n        if nCursorY >= 1 and nCursorY <= nHeight then\n            if nStart <= nWidth and nEnd >= 1 then\n                -- Modify line\n                local tLine = tLines[ nCursorY ]\n                if nStart == 1 and nEnd == nWidth then\n                    tLine.text = sText\n                    tLine.textColor = sTextColor\n                    tLine.backgroundColor = sBackgroundColor\n                else\n                    local sClippedText, sClippedTextColor, sClippedBackgroundColor\n                    if nStart < 1 then\n                        local nClipStart = 1 - nStart + 1\n                        local nClipEnd = nWidth - nStart + 1\n                        sClippedText = string_sub( sText, nClipStart, nClipEnd )\n                        sClippedTextColor = string_sub( sTextColor, nClipStart, nClipEnd )\n                        sClippedBackgroundColor = string_sub( sBackgroundColor, nClipStart, nClipEnd )\n                    elseif nEnd > nWidth then\n                        local nClipEnd = nWidth - nStart + 1\n                        sClippedText = string_sub( sText, 1, nClipEnd )\n                        sClippedTextColor = string_sub( sTextColor, 1, nClipEnd )\n                        sClippedBackgroundColor = string_sub( sBackgroundColor, 1, nClipEnd )\n                    else\n                        sClippedText = sText\n                        sClippedTextColor = sTextColor\n                        sClippedBackgroundColor = sBackgroundColor\n                    end\n\n                    local sOldText = tLine.text\n                    local sOldTextColor = tLine.textColor\n                    local sOldBackgroundColor = tLine.backgroundColor\n                    local sNewText, sNewTextColor, sNewBackgroundColor\n                    if nStart > 1 then\n                        local nOldEnd = nStart - 1\n                        sNewText = string_sub( sOldText, 1, nOldEnd ) .. sClippedText\n                        sNewTextColor = string_sub( sOldTextColor, 1, nOldEnd ) .. sClippedTextColor\n                        sNewBackgroundColor = string_sub( sOldBackgroundColor, 1, nOldEnd ) .. sClippedBackgroundColor\n                    else\n                        sNewText = sClippedText\n                        sNewTextColor = sClippedTextColor\n                        sNewBackgroundColor = sClippedBackgroundColor\n                    end\n                    if nEnd < nWidth then\n                        local nOldStart = nEnd + 1\n                        sNewText = sNewText .. string_sub( sOldText, nOldStart, nWidth )\n                        sNewTextColor = sNewTextColor .. string_sub( sOldTextColor, nOldStart, nWidth )\n                        sNewBackgroundColor = sNewBackgroundColor .. string_sub( sOldBackgroundColor, nOldStart, nWidth )\n                    end\n\n                    tLine.text = sNewText\n                    tLine.textColor = sNewTextColor\n                    tLine.backgroundColor = sNewBackgroundColor\n                end\n\n                -- Redraw line\n                if bVisible then\n                    redrawLine( nCursorY )\n                end\n            end\n        end\n\n        -- Move and redraw cursor\n        nCursorX = nEnd + 1\n        if bVisible then\n            updateCursorColor()\n            updateCursorPos()\n        end\n    end\n\n    -- Terminal implementation\n    local window = {}\n\n    function window.write( sText )\n        sText = tostring( sText )\n        internalBlit( sText, string_rep( tHex[ nTextColor ], #sText ), string_rep( tHex[ nBackgroundColor ], #sText ) )\n    end\n\n    function window.blit( sText, sTextColor, sBackgroundColor )\n        if type( sText ) ~= \"string\" then error( \"bad argument #1 (expected string, got \" .. type( sText ) .. \")\", 2 ) end\n        if type( sTextColor ) ~= \"string\" then error( \"bad argument #2 (expected string, got \" .. type( sTextColor ) .. \")\", 2 ) end\n        if type( sBackgroundColor ) ~= \"string\" then error( \"bad argument #3 (expected string, got \" .. type( sBackgroundColor ) .. \")\", 2 ) end\n        if #sTextColor ~= #sText or #sBackgroundColor ~= #sText then\n            error( \"Arguments must be the same length\", 2 )\n        end\n        internalBlit( sText, sTextColor, sBackgroundColor )\n    end\n\n    function window.clear()\n        local sEmptyText = sEmptySpaceLine\n        local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\n        local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\n        for y=1,nHeight do\n            tLines[y] = {\n                text = sEmptyText,\n                textColor = sEmptyTextColor,\n                backgroundColor = sEmptyBackgroundColor,\n            }\n        end\n        if bVisible then\n            redraw()\n            updateCursorColor()\n            updateCursorPos()\n        end\n    end\n\n    function window.clearLine()\n        if nCursorY >= 1 and nCursorY <= nHeight then\n            local sEmptyText = sEmptySpaceLine\n            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\n            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\n            tLines[ nCursorY ] = {\n                text = sEmptyText,\n                textColor = sEmptyTextColor,\n                backgroundColor = sEmptyBackgroundColor,\n            }\n            if bVisible then\n                redrawLine( nCursorY )\n                updateCursorColor()\n                updateCursorPos()\n            end\n        end\n    end\n\n    function window.getCursorPos()\n        return nCursorX, nCursorY\n    end\n\n    function window.setCursorPos( x, y )\n        if type( x ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( x ) .. \")\", 2 ) end\n        if type( y ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( y ) .. \")\", 2 ) end\n        nCursorX = math.floor( x )\n        nCursorY = math.floor( y )\n        if bVisible then\n            updateCursorPos()\n        end\n    end\n\n    function window.setCursorBlink( blink )\n        if type( blink ) ~= \"boolean\" then error( \"bad argument #1 (expected boolean, got \" .. type( blink ) .. \")\", 2 ) end\n        bCursorBlink = blink\n        if bVisible then\n            updateCursorBlink()\n        end\n    end\n\n    function window.getCursorBlink()\n        return bCursorBlink\n    end\n\n    local function isColor()\n        return parent.isColor()\n    end\n\n    function window.isColor()\n        return isColor()\n    end\n\n    function window.isColour()\n        return isColor()\n    end\n\n    local function setTextColor( color )\n        if type( color ) ~= \"number\" then\n            error( \"bad argument #1 (expected number, got \" .. type( color ) .. \")\", 2 )\n        elseif tHex[color] == nil then\n            error( \"Invalid color (got \" .. color .. \")\" , 2 )\n        end\n        nTextColor = color\n        if bVisible then\n            updateCursorColor()\n        end\n    end\n\n    window.setTextColor = setTextColor\n    window.setTextColour = setTextColor\n\n    function window.setPaletteColour( colour, r, g, b )\n        if type( colour ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( colour ) .. \")\", 2 ) end\n\n        if tHex[colour] == nil then\n            error( \"Invalid color (got \" .. colour .. \")\" , 2 )\n        end\n\n        local tCol\n        if type(r) == \"number\" and g == nil and b == nil then\n            tCol = { colours.unpackRGB( r ) }\n            tPalette[ colour ] = tCol\n        else\n            if type( r ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( r ) .. \")\", 2 ) end\n            if type( g ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( g ) .. \")\", 2 ) end\n            if type( b ) ~= \"number\" then error( \"bad argument #4 (expected number, got \" .. type( b ) .. \")\", 2 ) end\n\n            tCol = tPalette[ colour ]\n            tCol[1] = r\n            tCol[2] = g\n            tCol[3] = b\n        end\n\n        if bVisible then\n            return parent.setPaletteColour( colour, tCol[1], tCol[2], tCol[3] )\n        end\n    end\n\n    window.setPaletteColor = window.setPaletteColour\n\n    function window.getPaletteColour( colour )\n        if type( colour ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( colour ) .. \")\", 2 ) end\n        if tHex[colour] == nil then\n            error( \"Invalid color (got \" .. colour .. \")\" , 2 )\n        end\n        local tCol = tPalette[ colour ]\n        return tCol[1], tCol[2], tCol[3]\n    end\n\n    window.getPaletteColor = window.getPaletteColour\n\n    local function setBackgroundColor( color )\n        if type( color ) ~= \"number\" then\n            error( \"bad argument #1 (expected number, got \" .. type( color ) .. \")\", 2 )\n        elseif tHex[color] == nil then\n            error( \"Invalid color (got \" .. color .. \")\", 2 )\n        end\n        nBackgroundColor = color\n    end\n\n    window.setBackgroundColor = setBackgroundColor\n    window.setBackgroundColour = setBackgroundColor\n\n    function window.getSize()\n        return nWidth, nHeight\n    end\n\n    function window.scroll( n )\n        if type( n ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( n ) .. \")\", 2 ) end\n        if n ~= 0 then\n            local tNewLines = {}\n            local sEmptyText = sEmptySpaceLine\n            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\n            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\n            for newY=1,nHeight do\n                local y = newY + n\n                if y >= 1 and y <= nHeight then\n                    tNewLines[newY] = tLines[y]\n                else\n                    tNewLines[newY] = {\n                        text = sEmptyText,\n                        textColor = sEmptyTextColor,\n                        backgroundColor = sEmptyBackgroundColor,\n                    }\n                end\n            end\n            tLines = tNewLines\n            if bVisible then\n                redraw()\n                updateCursorColor()\n                updateCursorPos()\n            end\n        end\n    end\n\n    function window.getTextColor()\n        return nTextColor\n    end\n\n    function window.getTextColour()\n        return nTextColor\n    end\n\n    function window.getBackgroundColor()\n        return nBackgroundColor\n    end\n\n    function window.getBackgroundColour()\n        return nBackgroundColor\n    end\n\n    -- Other functions\n    function window.setVisible( bVis )\n        if type( bVis ) ~= \"boolean\" then error( \"bad argument #1 (expected boolean, got \" .. type( bVis ) .. \")\", 2 ) end\n        if bVisible ~= bVis then\n            bVisible = bVis\n            if bVisible then\n                window.redraw()\n            end\n        end\n    end\n\n    function window.redraw()\n        if bVisible then\n            redraw()\n            updatePalette()\n            updateCursorBlink()\n            updateCursorColor()\n            updateCursorPos()\n        end\n    end\n\n    function window.restoreCursor()\n        if bVisible then\n            updateCursorBlink()\n            updateCursorColor()\n            updateCursorPos()\n        end\n    end\n\n    function window.getPosition()\n        return nX, nY\n    end\n\n    function window.reposition( nNewX, nNewY, nNewWidth, nNewHeight )\n        if type( nNewX ) ~= \"number\" then error( \"bad argument #1 (expected number, got \" .. type( nNewX ) .. \")\", 2 ) end\n        if type( nNewY ) ~= \"number\" then error( \"bad argument #2 (expected number, got \" .. type( nNewY ) .. \")\", 2 ) end\n        if nNewWidth ~= nil or nNewHeight ~= nil  then\n            if type( nNewWidth ) ~= \"number\" then error( \"bad argument #3 (expected number, got \" .. type( nNewWidth ) .. \")\", 2 ) end\n            if type( nNewHeight ) ~= \"number\" then error( \"bad argument #4 (expected number, got \" .. type( nNewHeight ) .. \")\", 2 ) end\n        end\n\n        nX = nNewX\n        nY = nNewY\n        if nNewWidth and nNewHeight then\n            local tNewLines = {}\n            createEmptyLines( nNewWidth )\n            local sEmptyText = sEmptySpaceLine\n            local sEmptyTextColor = tEmptyColorLines[ nTextColor ]\n            local sEmptyBackgroundColor = tEmptyColorLines[ nBackgroundColor ]\n            for y=1,nNewHeight do\n                if y > nHeight then\n                    tNewLines[y] = {\n                        text = sEmptyText,\n                        textColor = sEmptyTextColor,\n                        backgroundColor = sEmptyBackgroundColor\n                    }\n                else\n                    local tOldLine = tLines[y]\n                    if nNewWidth == nWidth then\n                        tNewLines[y] = tOldLine\n                    elseif nNewWidth < nWidth then\n                        tNewLines[y] = {\n                            text = string_sub( tOldLine.text, 1, nNewWidth ),\n                            textColor = string_sub( tOldLine.textColor, 1, nNewWidth ),\n                            backgroundColor = string_sub( tOldLine.backgroundColor, 1, nNewWidth ),\n                        }\n                    else\n                        tNewLines[y] = {\n                            text = tOldLine.text .. string_sub( sEmptyText, nWidth + 1, nNewWidth ),\n                            textColor = tOldLine.textColor .. string_sub( sEmptyTextColor, nWidth + 1, nNewWidth ),\n                            backgroundColor = tOldLine.backgroundColor .. string_sub( sEmptyBackgroundColor, nWidth + 1, nNewWidth ),\n                        }\n                    end\n                end\n            end\n            nWidth = nNewWidth\n            nHeight = nNewHeight\n            tLines = tNewLines\n        end\n        if bVisible then\n            window.redraw()\n        end\n    end\n\n    if bVisible then\n        window.redraw()\n    end\n    return window\nend","colours.lua":"-- Colours (for lovers of british spelling)\nlocal colours = _ENV\nfor k,v in pairs(colors) do\n\tcolours[k] = v\nend\n\ncolours.grey = colors.gray\ncolours.gray = nil\n\ncolours.lightGrey = colors.lightGray\ncolours.lightGray = nil","turtle":{"turtle.lua":"\nif not turtle then\n    error( \"Cannot load turtle API on computer\", 2 )\nend\nnative = turtle.native or turtle\n\nlocal function addCraftMethod( object )\n    if peripheral.getType( \"left\" ) == \"workbench\" then\n        object.craft = function( ... )\n            return peripheral.call( \"left\", \"craft\", ... )\n        end\n    elseif peripheral.getType( \"right\" ) == \"workbench\" then\n        object.craft = function( ... )\n            return peripheral.call( \"right\", \"craft\", ... )\n        end\n    else\n        object.craft = nil\n    end\nend\n\n-- Put commands into environment table\nlocal env = _ENV\nfor k,v in pairs( native ) do\n    if k == \"equipLeft\" or k == \"equipRight\" then\n        env[k] = function( ... )\n            local result, err = v( ... )\n            addCraftMethod( turtle )\n            return result, err\n        end\n    else\n        env[k] = v\n    end\nend\naddCraftMethod( env )"},"settings.lua":"\nlocal tSettings = {}\n\nfunction set( sName, value )\n    if type( sName ) ~= \"string\" then error( \"bad argument #1 (expected string, got \" .. type( sName ) .. \")\", 2 ) end\n\n    local sValueTy = type(value)\n    if sValueTy ~= \"number\" and sValueTy ~= \"string\" and sValueTy ~= \"boolean\" and sValueTy ~= \"table\" then\n        error( \"bad argument #2 (expected value, got \" .. sValueTy .. \")\", 2 )\n    end\n    if sValueTy == \"table\" then\n        -- Ensure value is serializeable\n        value = textutils.unserialize( textutils.serialize(value) )\n    end\n    tSettings[ sName ] = value\nend\n\nlocal copy\nfunction copy( value )\n    if type(value) == \"table\" then\n        local result = {}\n        for k,v in pairs(value) do\n            result[k] = copy(v)\n        end\n        return result\n    else\n        return value\n    end\nend\n\nfunction get( sName, default )\n    if type(sName) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sName ) .. \")\", 2 )\n    end\n    local result = tSettings[ sName ]\n    if result ~= nil then\n        return copy(result)\n    else\n        return default\n    end\nend\n\nfunction unset( sName )\n    if type(sName) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sName ) .. \")\", 2 )\n    end\n    tSettings[ sName ] = nil\nend\n\nfunction clear()\n    tSettings = {}\nend\n\nfunction getNames()\n    local result = {}\n    for k,v in pairs( tSettings ) do\n        result[ #result + 1 ] = k\n    end\n    table.sort(result)\n    return result\nend\n\nfunction load( sPath )\n    if type(sPath) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sPath ) .. \")\", 2 )\n    end\n    local file = fs.open( sPath, \"r\" )\n    if not file then\n        return false\n    end\n\n    local sText = file.readAll()\n    file.close()\n\n    local tFile = textutils.unserialize( sText )\n    if type(tFile) ~= \"table\" then\n        return false\n    end\n\n    for k,v in pairs(tFile) do\n        if type(k) == \"string\" and\n           (type(v) == \"string\" or type(v) == \"number\" or type(v) == \"boolean\" or type(v) == \"table\") then\n            set( k, v )\n        end\n    end\n\n    return true\nend\n\nfunction save( sPath )\n    if type(sPath) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sPath ) .. \")\", 2 )\n    end\n    local file = fs.open( sPath, \"w\" )\n    if not file then\n        return false\n    end\n\n    file.write( textutils.serialize( tSettings ) )\n    file.close()\n\n    return true\nend","rednet.lua":"\nCHANNEL_BROADCAST = 65535\nCHANNEL_REPEAT = 65533\n\nlocal tReceivedMessages = {}\nlocal tReceivedMessageTimeouts = {}\nlocal tHostnames = {}\n\nfunction open( sModem )\n    if type( sModem ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sModem ) .. \")\", 2 )\n    end\n    if peripheral.getType( sModem ) ~= \"modem\" then\n        error( \"No such modem: \"..sModem, 2 )\n    end\n    peripheral.call( sModem, \"open\", os.getComputerID() )\n    peripheral.call( sModem, \"open\", CHANNEL_BROADCAST )\nend\n\nfunction close( sModem )\n    if sModem then\n        -- Close a specific modem\n        if type( sModem ) ~= \"string\" then\n            error( \"bad argument #1 (expected string, got \" .. type( sModem ) .. \")\", 2 )\n        end\n        if peripheral.getType( sModem ) ~= \"modem\" then\n            error( \"No such modem: \"..sModem, 2 )\n        end\n        peripheral.call( sModem, \"close\", os.getComputerID() )\n        peripheral.call( sModem, \"close\", CHANNEL_BROADCAST )\n    else\n        -- Close all modems\n        for n,sModem in ipairs( peripheral.getNames() ) do\n            if isOpen( sModem ) then\n                close( sModem )\n            end\n        end\n    end\nend\n\nfunction isOpen( sModem )\n    if sModem then\n        -- Check if a specific modem is open\n        if type( sModem ) ~= \"string\" then\n            error( \"bad argument #1 (expected string, got \" .. type( sModem ) .. \")\", 2 )\n        end\n        if peripheral.getType( sModem ) == \"modem\" then\n            return peripheral.call( sModem, \"isOpen\", os.getComputerID() ) and peripheral.call( sModem, \"isOpen\", CHANNEL_BROADCAST )\n        end\n    else\n        -- Check if any modem is open\n        for n,sModem in ipairs( peripheral.getNames() ) do\n            if isOpen( sModem ) then\n                return true\n            end\n        end\n    end\n    return false\nend\n\nfunction send( nRecipient, message, sProtocol )\n    if type( nRecipient ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( nRecipient ) .. \")\", 2 )\n    end\n    if sProtocol ~= nil and type( sProtocol ) ~= \"string\" then\n        error( \"bad argument #3 (expected string, got \" .. type( sProtocol ) .. \")\", 2 )\n    end\n    -- Generate a (probably) unique message ID\n    -- We could do other things to guarantee uniqueness, but we really don't need to\n    -- Store it to ensure we don't get our own messages back\n    local nMessageID = math.random( 1, 2147483647 )\n    tReceivedMessages[ nMessageID ] = true\n    tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = nMessageID\n\n    -- Create the message\n    local nReplyChannel = os.getComputerID()\n    local tMessage = {\n        nMessageID = nMessageID,\n        nRecipient = nRecipient,\n        message = message,\n        sProtocol = sProtocol,\n    }\n\n    if nRecipient == os.getComputerID() then\n        -- Loopback to ourselves\n        os.queueEvent( \"rednet_message\", nReplyChannel, message, sProtocol )\n\n    else\n        -- Send on all open modems, to the target and to repeaters\n        local sent = false\n        for n,sModem in ipairs( peripheral.getNames() ) do\n            if isOpen( sModem ) then\n                peripheral.call( sModem, \"transmit\", nRecipient, nReplyChannel, tMessage );\n                peripheral.call( sModem, \"transmit\", CHANNEL_REPEAT, nReplyChannel, tMessage );\n                sent = true\n            end\n        end\n    end\nend\n\nfunction broadcast( message, sProtocol )\n    if sProtocol ~= nil and type( sProtocol ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( sProtocol ) .. \")\", 2 )\n    end\n    send( CHANNEL_BROADCAST, message, sProtocol )\nend\n\nfunction receive( sProtocolFilter, nTimeout )\n    -- The parameters used to be ( nTimeout ), detect this case for backwards compatibility\n    if type(sProtocolFilter) == \"number\" and nTimeout == nil then\n        sProtocolFilter, nTimeout = nil, sProtocolFilter\n    end\n    if sProtocolFilter ~= nil and type( sProtocolFilter ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sProtocolFilter ) .. \")\", 2 )\n    end\n    if nTimeout ~= nil and type( nTimeout ) ~= \"number\" then\n        error( \"bad argument #2 (expected number, got \" .. type( nTimeout ) .. \")\", 2 )\n    end\n\n    -- Start the timer\n    local timer = nil\n    local sFilter = nil\n    if nTimeout then\n        timer = os.startTimer( nTimeout )\n        sFilter = nil\n    else\n        sFilter = \"rednet_message\"\n    end\n\n    -- Wait for events\n    while true do\n        local sEvent, p1, p2, p3 = os.pullEvent( sFilter )\n        if sEvent == \"rednet_message\" then\n            -- Return the first matching rednet_message\n            local nSenderID, message, sProtocol = p1, p2, p3\n            if sProtocolFilter == nil or sProtocol == sProtocolFilter then\n                return nSenderID, message, sProtocol\n            end\n        elseif sEvent == \"timer\" then\n            -- Return nil if we timeout\n            if p1 == timer then\n                return nil\n            end\n        end\n    end\nend\n\nfunction host( sProtocol, sHostname )\n    if type( sProtocol ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sProtocol ) .. \")\", 2 )\n    end\n    if type( sHostname ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( sHostname ) .. \")\", 2 )\n    end\n    if sHostname == \"localhost\" then\n        error( \"Reserved hostname\", 2 )\n    end\n    if tHostnames[ sProtocol ] ~= sHostname then\n        if lookup( sProtocol, sHostname ) ~= nil then\n            error( \"Hostname in use\", 2 )\n        end\n        tHostnames[ sProtocol ] = sHostname\n    end\nend\n\nfunction unhost( sProtocol )\n    if type( sProtocol ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sProtocol ) .. \")\", 2 )\n    end\n    tHostnames[ sProtocol ] = nil\nend\n\nfunction lookup( sProtocol, sHostname )\n    if type( sProtocol ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sProtocol ) .. \")\", 2 )\n    end\n    if sHostname ~= nil and type( sHostname ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( sHostname ) .. \")\", 2 )\n    end\n\n    -- Build list of host IDs\n    local tResults = nil\n    if sHostname == nil then\n        tResults = {}\n    end\n\n    -- Check localhost first\n    if tHostnames[ sProtocol ] then\n        if sHostname == nil then\n            table.insert( tResults, os.getComputerID() )\n        elseif sHostname == \"localhost\" or sHostname == tHostnames[ sProtocol ] then\n            return os.getComputerID()\n        end\n    end\n\n    if not isOpen() then\n        if tResults then\n            return table.unpack( tResults )\n        end\n        return nil\n    end\n\n    -- Broadcast a lookup packet\n    broadcast( {\n        sType = \"lookup\",\n        sProtocol = sProtocol,\n        sHostname = sHostname,\n    }, \"dns\" )\n\n    -- Start a timer\n    local timer = os.startTimer( 2 )\n\n    -- Wait for events\n    while true do\n        local event, p1, p2, p3 = os.pullEvent()\n        if event == \"rednet_message\" then\n            -- Got a rednet message, check if it's the response to our request\n            local nSenderID, tMessage, sMessageProtocol = p1, p2, p3\n            if sMessageProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup response\" then\n                if tMessage.sProtocol == sProtocol then\n                    if sHostname == nil then\n                        table.insert( tResults, nSenderID )\n                    elseif tMessage.sHostname == sHostname then\n                        return nSenderID\n                    end\n                end\n            end\n        else\n            -- Got a timer event, check it's the end of our timeout\n            if p1 == timer then\n                break\n            end\n        end\n    end\n    if tResults then\n        return table.unpack( tResults )\n    end\n    return nil\nend\n\nlocal bRunning = false\nfunction run()\n    if bRunning then\n        error( \"rednet is already running\", 2 )\n    end\n    bRunning = true\n\n    while bRunning do\n        local sEvent, p1, p2, p3, p4 = os.pullEventRaw()\n        if sEvent == \"modem_message\" then\n            -- Got a modem message, process it and add it to the rednet event queue\n            local sModem, nChannel, nReplyChannel, tMessage = p1, p2, p3, p4\n            if isOpen( sModem ) and ( nChannel == os.getComputerID() or nChannel == CHANNEL_BROADCAST ) then\n                if type( tMessage ) == \"table\" and tMessage.nMessageID then\n                    if not tReceivedMessages[ tMessage.nMessageID ] then\n                        tReceivedMessages[ tMessage.nMessageID ] = true\n                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = tMessage.nMessageID\n                        os.queueEvent( \"rednet_message\", nReplyChannel, tMessage.message, tMessage.sProtocol )\n                    end\n                end\n            end\n\n        elseif sEvent == \"rednet_message\" then\n            -- Got a rednet message (queued from above), respond to dns lookup\n            local nSenderID, tMessage, sProtocol = p1, p2, p3\n            if sProtocol == \"dns\" and type(tMessage) == \"table\" and tMessage.sType == \"lookup\" then\n                local sHostname = tHostnames[ tMessage.sProtocol ]\n                if sHostname ~= nil and (tMessage.sHostname == nil or tMessage.sHostname == sHostname) then\n                    rednet.send( nSenderID, {\n                        sType = \"lookup response\",\n                        sHostname = sHostname,\n                        sProtocol = tMessage.sProtocol,\n                    }, \"dns\" )\n                end\n            end\n\n        elseif sEvent == \"timer\" then\n            -- Got a timer event, use it to clear the event queue\n            local nTimer = p1\n            local nMessage = tReceivedMessageTimeouts[ nTimer ]\n            if nMessage then\n                tReceivedMessageTimeouts[ nTimer ] = nil\n                tReceivedMessages[ nMessage ] = nil\n            end\n        end\n    end\nend"},"startup.lua":"\n-- Setup paths\nlocal sPath = \".:/rom/programs\"\nif term.isColor() then\n    sPath = sPath..\":/rom/programs/advanced\"\nend\nif turtle then\n    sPath = sPath..\":/rom/programs/turtle\"\nelse\n    sPath = sPath..\":/rom/programs/rednet:/rom/programs/fun\"\n    if term.isColor() then\n        sPath = sPath..\":/rom/programs/fun/advanced\"\n    end\nend\nif pocket then\n    sPath = sPath..\":/rom/programs/pocket\"\nend\nif commands then\n    sPath = sPath..\":/rom/programs/command\"\nend\nif http then\n    sPath = sPath..\":/rom/programs/http\"\nend\nshell.setPath( sPath )\nhelp.setPath( \"/rom/help\" )\n\n-- Setup aliases\nshell.setAlias( \"ls\", \"list\" )\nshell.setAlias( \"dir\", \"list\" )\nshell.setAlias( \"cp\", \"copy\" )\nshell.setAlias( \"mv\", \"move\" )\nshell.setAlias( \"rm\", \"delete\" )\nshell.setAlias( \"clr\", \"clear\" )\nshell.setAlias( \"rs\", \"redstone\" )\nshell.setAlias( \"sh\", \"shell\" )\nif term.isColor() then\n    shell.setAlias( \"background\", \"bg\" )\n    shell.setAlias( \"foreground\", \"fg\" )\nend\n\n-- Setup completion functions\nlocal function completeMultipleChoice( sText, tOptions, bAddSpaces )\n    local tResults = {}\n    for n=1,#tOptions do\n        local sOption = tOptions[n]\n        if #sOption + (bAddSpaces and 1 or 0) > #sText and string.sub( sOption, 1, #sText ) == sText then\n            local sResult = string.sub( sOption, #sText + 1 )\n            if bAddSpaces then\n                table.insert( tResults, sResult .. \" \" )\n            else\n                table.insert( tResults, sResult )\n            end\n        end\n    end\n    return tResults\nend\nlocal function completePeripheralName( sText, bAddSpaces )\n    return completeMultipleChoice( sText, peripheral.getNames(), bAddSpaces )\nend\nlocal tRedstoneSides = redstone.getSides()\nlocal function completeSide( sText, bAddSpaces )\n    return completeMultipleChoice( sText, tRedstoneSides, bAddSpaces )\nend\nlocal function completeFile( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return fs.complete( sText, shell.dir(), true, false )\n    end\nend\nlocal function completeDir( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return fs.complete( sText, shell.dir(), false, true )\n    end\nend\nlocal function completeEither( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return fs.complete( sText, shell.dir(), true, true )\n    end\nend\nlocal function completeEitherEither( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        local tResults = fs.complete( sText, shell.dir(), true, true )\n        for n=1,#tResults do\n            local sResult = tResults[n]\n            if string.sub( sResult, #sResult, #sResult ) ~= \"/\" then\n                tResults[n] = sResult .. \" \"\n            end\n        end\n        return tResults\n    elseif nIndex == 2 then\n        return fs.complete( sText, shell.dir(), true, true )\n    end\nend\nlocal function completeProgram( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return shell.completeProgram( sText )\n    end\nend\nlocal function completeHelp( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return help.completeTopic( sText )\n    end\nend\nlocal function completeAlias( shell, nIndex, sText, tPreviousText )\n    if nIndex == 2 then\n        return shell.completeProgram( sText )\n    end\nend\nlocal function completePeripheral( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completePeripheralName( sText )\n    end\nend\nlocal tGPSOptions = { \"host\", \"host \", \"locate\" }\nlocal function completeGPS( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, tGPSOptions )\n    end\nend\nlocal tLabelOptions = { \"get\", \"get \", \"set \", \"clear\", \"clear \" }\nlocal function completeLabel( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, tLabelOptions )\n    elseif nIndex == 2 then\n        return completePeripheralName( sText )\n    end\nend\nlocal function completeMonitor( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completePeripheralName( sText, true )\n    elseif nIndex == 2 then\n        return shell.completeProgram( sText )\n    end\nend\nlocal tRedstoneOptions = { \"probe\", \"set \", \"pulse \" }\nlocal function completeRedstone( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, tRedstoneOptions )\n    elseif nIndex == 2 then\n        return completeSide( sText )\n    end\nend\nlocal tDJOptions = { \"play\", \"play \", \"stop \" }\nlocal function completeDJ( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, tDJOptions )\n    elseif nIndex == 2 then\n        return completePeripheralName( sText )\n    end\nend\nlocal tPastebinOptions = { \"put \", \"get \", \"run \" }\nlocal function completePastebin( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, tPastebinOptions )\n    elseif nIndex == 2 then\n        if tPreviousText[2] == \"put\" then\n            return fs.complete( sText, shell.dir(), true, false )\n        end\n    end\nend\nlocal tChatOptions = { \"host \", \"join \" }\nlocal function completeChat( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, tChatOptions )\n    end\nend\nlocal function completeSet( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 then\n        return completeMultipleChoice( sText, settings.getNames(), true )\n    end\nend\nlocal tCommands\nif commands then\n    tCommands = commands.list()\nend\nlocal function completeExec( shell, nIndex, sText, tPreviousText )\n    if nIndex == 1 and commands then\n        return completeMultipleChoice( sText, tCommands, true )\n    end\nend\nshell.setCompletionFunction( \"rom/programs/alias.lua\", completeAlias )\nshell.setCompletionFunction( \"rom/programs/cd.lua\", completeDir )\nshell.setCompletionFunction( \"rom/programs/copy.lua\", completeEitherEither )\nshell.setCompletionFunction( \"rom/programs/delete.lua\", completeEither )\nshell.setCompletionFunction( \"rom/programs/drive.lua\", completeDir )\nshell.setCompletionFunction( \"rom/programs/edit.lua\", completeFile )\nshell.setCompletionFunction( \"rom/programs/eject.lua\", completePeripheral )\nshell.setCompletionFunction( \"rom/programs/gps.lua\", completeGPS )\nshell.setCompletionFunction( \"rom/programs/help.lua\", completeHelp )\nshell.setCompletionFunction( \"rom/programs/id.lua\", completePeripheral )\nshell.setCompletionFunction( \"rom/programs/label.lua\", completeLabel )\nshell.setCompletionFunction( \"rom/programs/list.lua\", completeDir )\nshell.setCompletionFunction( \"rom/programs/mkdir.lua\", completeFile )\nshell.setCompletionFunction( \"rom/programs/monitor.lua\", completeMonitor )\nshell.setCompletionFunction( \"rom/programs/move.lua\", completeEitherEither )\nshell.setCompletionFunction( \"rom/programs/redstone.lua\", completeRedstone )\nshell.setCompletionFunction( \"rom/programs/rename.lua\", completeEitherEither )\nshell.setCompletionFunction( \"rom/programs/shell.lua\", completeProgram )\nshell.setCompletionFunction( \"rom/programs/type.lua\", completeEither )\nshell.setCompletionFunction( \"rom/programs/set.lua\", completeSet )\nshell.setCompletionFunction( \"rom/programs/advanced/bg.lua\", completeProgram )\nshell.setCompletionFunction( \"rom/programs/advanced/fg.lua\", completeProgram )\nshell.setCompletionFunction( \"rom/programs/fun/dj.lua\", completeDJ )\nshell.setCompletionFunction( \"rom/programs/fun/advanced/paint.lua\", completeFile )\nshell.setCompletionFunction( \"rom/programs/http/pastebin.lua\", completePastebin )\nshell.setCompletionFunction( \"rom/programs/rednet/chat.lua\", completeChat )\nshell.setCompletionFunction( \"rom/programs/command/exec.lua\", completeExec )\n\nif turtle then\n    local tGoOptions = { \"left\", \"right\", \"forward\", \"back\", \"down\", \"up\" }\n    local function completeGo( shell, nIndex, sText )\n        return completeMultipleChoice( sText, tGoOptions, true)\n    end\n    local tTurnOptions = { \"left\", \"right\" }\n    local function completeTurn( shell, nIndex, sText )\n            return completeMultipleChoice( sText, tTurnOptions, true )\n    end\n    local tEquipOptions = { \"left\", \"right\" }\n    local function completeEquip( shell, nIndex, sText )\n        if nIndex == 2 then\n            return completeMultipleChoice( sText, tEquipOptions )\n        end\n    end\n    local function completeUnequip( shell, nIndex, sText )\n        if nIndex == 1 then\n            return completeMultipleChoice( sText, tEquipOptions )\n        end\n    end\n    shell.setCompletionFunction( \"rom/programs/turtle/go.lua\", completeGo )\n    shell.setCompletionFunction( \"rom/programs/turtle/turn.lua\", completeTurn )\n    shell.setCompletionFunction( \"rom/programs/turtle/equip.lua\", completeEquip )\n    shell.setCompletionFunction( \"rom/programs/turtle/unequip.lua\", completeUnequip )\nend\n\n\n-- Run autorun files\nif fs.exists( \"/rom/autorun\" ) and fs.isDir( \"/rom/autorun\" ) then\n    local tFiles = fs.list( \"/rom/autorun\" )\n    table.sort( tFiles )\n    for n, sFile in ipairs( tFiles ) do\n        if string.sub( sFile, 1, 1 ) ~= \".\" then\n            local sPath = \"/rom/autorun/\"..sFile\n            if not fs.isDir( sPath ) then\n                shell.run( sPath )\n            end\n        end\n    end\nend\n\nlocal function findStartups( sBaseDir )\n    local tStartups = nil\n    local sBasePath = \"/\" .. fs.combine( sBaseDir, \"startup\" )\n    local sStartupNode = shell.resolveProgram( sBasePath )\n    if sStartupNode then\n        tStartups = { sStartupNode }\n    end\n    -- It's possible that there is a startup directory and a startup.lua file, so this has to be\n    -- executed even if a file has already been found.\n    if fs.isDir( sBasePath ) then\n        if tStartups == nil then\n            tStartups = {}\n        end\n        for _,v in pairs( fs.list( sBasePath ) ) do\n            local sPath = \"/\" .. fs.combine( sBasePath, v )\n            if not fs.isDir( sPath ) then\n                tStartups[ #tStartups + 1 ] = sPath\n            end\n        end\n    end\n    return tStartups\nend\n\n-- Run the user created startup, either from disk drives or the root\nlocal tUserStartups = nil\nif settings.get( \"shell.allow_startup\" ) then\n    tUserStartups = findStartups( \"/\" )\nend\nif settings.get( \"shell.allow_disk_startup\" ) then\n    for n,sName in pairs( peripheral.getNames() ) do\n        if disk.isPresent( sName ) and disk.hasData( sName ) then\n            local startups = findStartups( disk.getMountPath( sName ) )\n            if startups then\n                tUserStartups = startups\n                break\n            end\n        end\n    end\nend\nif tUserStartups then\n    for _,v in pairs( tUserStartups ) do\n        shell.run( v )\n    end\nend","programs":{"apis.lua":"\nlocal tApis = {}\nfor k,v in pairs( _G ) do\n    if type(k) == \"string\" and type(v) == \"table\" and k ~= \"_G\" then\n        table.insert( tApis, k )\n    end\nend\ntable.insert( tApis, \"shell\" )\ntable.insert( tApis, \"package\" )\nif multishell then\n    table.insert( tApis, \"multishell\" )\nend\ntable.sort( tApis )\n\ntextutils.pagedTabulate( tApis )","clear.lua":"term.clear()\nterm.setCursorPos( 1, 1 )","list.lua":"\nlocal tArgs = { ... }\n\n-- Get all the files in the directory\nlocal sDir = shell.dir()\nif tArgs[1] ~= nil then\n    sDir = shell.resolve( tArgs[1] )\nend\n\nif not fs.isDir( sDir ) then\n    printError( \"Not a directory\" )\n    return\nend\n\n-- Sort into dirs/files, and calculate column count\nlocal tAll = fs.list( sDir )\nlocal tFiles = {}\nlocal tDirs = {}\n\nlocal bShowHidden = settings.get( \"list.show_hidden\" )\nfor n, sItem in pairs( tAll ) do\n    if bShowHidden or string.sub( sItem, 1, 1 ) ~= \".\" then\n        local sPath = fs.combine( sDir, sItem )\n        if fs.isDir( sPath ) then\n            table.insert( tDirs, sItem )\n        else\n            table.insert( tFiles, sItem )\n        end\n    end\nend\ntable.sort( tDirs )\ntable.sort( tFiles )\n\nif term.isColour() then\n    textutils.pagedTabulate( colors.green, tDirs, colors.white, tFiles )\nelse\n    textutils.pagedTabulate( tDirs, tFiles )\nend","drive.lua":"local tArgs = { ... }\n\n-- Get where a directory is mounted\nlocal sPath = shell.dir()\nif tArgs[1] ~= nil then\n    sPath = shell.resolve( tArgs[1] )\nend\n\nif fs.exists( sPath ) then\n    write( fs.getDrive( sPath ) .. \" (\" )\n    local nSpace = fs.getFreeSpace( sPath )\n    if nSpace >= 1000 * 1000 then\n        print( (math.floor( nSpace / (100 * 1000) ) / 10) .. \"MB remaining)\" )\n    elseif nSpace >= 1000 then\n        print( (math.floor( nSpace / 100 ) / 10) .. \"KB remaining)\" )\n    else\n        print( nSpace .. \"B remaining)\" )\n    end\nelse\n    print( \"No such path\" )\nend","redstone.lua":"\nlocal tArgs = { ... }\n\nlocal function printUsage()\n    print( \"Usages:\" )\n    print( \"redstone probe\" )\n    print( \"redstone set <side> <value>\" )\n    print( \"redstone set <side> <color> <value>\" )\n    print( \"redstone pulse <side> <count> <period>\" )\nend\n\nlocal sCommand = tArgs[1]\nif sCommand == \"probe\" then\n    -- \"redstone probe\"\n    -- Regular input\n    print( \"Redstone inputs: \" )\n\n    local count = 0\n    local bundledCount = 0\n    for n,sSide in ipairs( redstone.getSides() ) do\n        if redstone.getBundledInput( sSide ) > 0 then\n            bundledCount = bundledCount + 1\n        end\n        if redstone.getInput( sSide ) then\n            if count > 0 then\n                io.write( \", \" )\n            end\n            io.write( sSide )\n            count = count + 1\n        end\n    end\n    if count > 0 then\n        print( \".\" )\n    else\n        print( \"None.\" )\n    end\n\n    -- Bundled input\n    if bundledCount > 0 then\n        print()\n        print( \"Bundled inputs:\" )\n        for i,sSide in ipairs( redstone.getSides() ) do\n            local nInput = redstone.getBundledInput( sSide )\n            if nInput ~= 0 then\n                write( sSide..\": \" )\n                local count = 0\n                for sColour,nColour in pairs( colors ) do\n                    if type( nColour ) == \"number\" and colors.test( nInput, nColour ) then\n                        if count > 0 then\n                            write( \", \" )\n                        end\n                        if term.isColour() then\n                            term.setTextColour( nColour )\n                        end\n                        write( sColour )\n                        if term.isColour() then\n                            term.setTextColour( colours.white )\n                        end\n                        count = count + 1\n                    end\n                end\n                print( \".\" )\n            end\n        end\n    end\n\nelseif sCommand == \"pulse\" then\n    -- \"redstone pulse\"\n    local sSide = tArgs[2]\n    local nCount = tonumber( tArgs[3] ) or 1\n    local nPeriod = tonumber( tArgs[4] ) or 0.5\n    for n=1,nCount do\n        redstone.setOutput( sSide, true )\n        sleep( nPeriod / 2 )\n        redstone.setOutput( sSide, false )\n        sleep( nPeriod / 2 )\n    end\n\nelseif sCommand == \"set\" then\n    -- \"redstone set\"\n    local sSide = tArgs[2]\n    if #tArgs > 3 then\n        -- Bundled cable output\n        local sColour = tArgs[3]\n        local nColour = colors[sColour] or colours[sColour]\n        if type(nColour) ~= \"number\" then\n            printError( \"No such color\" )\n            return\n        end\n\n        local sValue = tArgs[4]\n        if sValue == \"true\" then\n            rs.setBundledOutput( sSide, colors.combine( rs.getBundledOutput( sSide ), nColour ) )\n        elseif sValue == \"false\" then\n            rs.setBundledOutput( sSide, colors.subtract( rs.getBundledOutput( sSide ), nColour ) )\n        else\n            print( \"Value must be boolean\" )\n        end\n    else\n        -- Regular output\n        local sValue = tArgs[3]\n        local nValue = tonumber(sValue)\n        if sValue == \"true\" then\n            rs.setOutput( sSide, true )\n        elseif sValue == \"false\" then\n            rs.setOutput( sSide, false )\n        elseif nValue and nValue >= 0 and nValue <= 15 then\n            rs.setAnalogOutput( sSide, nValue )\n        else\n            print( \"Value must be boolean or 0-15\" )\n        end\n    end\n\nelse\n    -- Something else\n    printUsage()\n\nend","alias.lua":"\nlocal tArgs = { ... }\nif #tArgs > 2 then\n    print( \"Usage: alias <alias> <program>\" )\n    return\nend\n\nlocal sAlias = tArgs[1]\nlocal sProgram = tArgs[2]\n\nif sAlias and sProgram then\n    -- Set alias\n    shell.setAlias( sAlias, sProgram )\nelseif sAlias then\n    -- Clear alias\n    shell.clearAlias( sAlias )\nelse\n    -- List aliases\n    local tAliases = shell.aliases()\n    local tList = {}\n    for sAlias, sCommand in pairs( tAliases ) do\n        table.insert( tList, sAlias..\":\"..sCommand )\n    end\n    table.sort( tList )\n    textutils.pagedTabulate( tList )\nend","command":{"commands.lua":"\nif not commands then\n    printError( \"Requires a Command Computer.\" )\n    return\nend\n\nlocal tCommands = commands.list()\ntable.sort( tCommands )\n\nif term.isColor() then\n    term.setTextColor( colors.green )\nend\nprint( \"Available commands:\" )\nterm.setTextColor( colors.white )\n\ntextutils.pagedTabulate( tCommands )","exec.lua":"\nlocal tArgs = { ... }\nif not commands then\n    printError( \"Requires a Command Computer.\" )\n    return\nend\nif #tArgs == 0 then\n    printError( \"Usage: exec <command>\" )\n    return\nend\n\nlocal function printSuccess( text )\n    if term.isColor() then\n        term.setTextColor( colors.green )\n    end\n    print( text )\n    term.setTextColor( colors.white )\nend\n\nlocal sCommand = string.lower( tArgs[1] )\nfor n=2,#tArgs do\n    sCommand = sCommand .. \" \" .. tArgs[n]\nend\n\nlocal bResult, tOutput = commands.exec( sCommand )\nif bResult then\n    printSuccess( \"Success\" )\n    if #tOutput > 0 then\n        for n=1,#tOutput do\n            print( tOutput[n] )\n        end\n    end\nelse\n    printError( \"Failed\" )\n    if #tOutput > 0 then\n        for n=1,#tOutput do\n            print( tOutput[n] )\n        end\n    end\nend"},"reboot.lua":"if term.isColour() then\n    term.setTextColour( colours.yellow )\nend\nprint( \"Goodbye\" )\nterm.setTextColour( colours.white )\n\nsleep( 1 )\nos.reboot()","exit.lua":"shell.exit()","rename.lua":"local tArgs = { ... }\nif #tArgs < 2 then\n    print( \"Usage: rename <source> <destination>\" )\n    return\nend\n\nlocal sSource = shell.resolve( tArgs[1] )\nlocal sDest = shell.resolve( tArgs[2] )\n\nif fs.exists( sDest ) then\n    printError( \"Destination exists\" )\nend\n\nfs.move( sSource, sDest )","mkdir.lua":"local tArgs = { ... }\nif #tArgs < 1 then\n    print( \"Usage: mkdir <path>\" )\n    return\nend\n\nlocal sNewDir = shell.resolve( tArgs[1] )\n\nif fs.exists( sNewDir ) and not fs.isDir(sNewDir) then\n    printError( \"Destination exists\" )\n    return\nend\n\nfs.makeDir( sNewDir )\n","cd.lua":"\nlocal tArgs = { ... }\nif #tArgs < 1 then\n    print( \"Usage: cd <path>\" )\n    return\nend\n\nlocal sNewDir = shell.resolve( tArgs[1] )\nif fs.isDir( sNewDir ) then\n    shell.setDir( sNewDir )\nelse\n    print( \"Not a directory\" )\n    return\nend","label.lua":"\nlocal function printUsage()\n    print( \"Usages:\" )\n    print( \"label get\" )\n    print( \"label get <drive>\" )\n    print( \"label set <text>\" )\n    print( \"label set <drive> <text>\" )\n    print( \"label clear\" )\n    print( \"label clear <drive>\" )\nend\n\nlocal function checkDrive( sDrive )\n    if peripheral.getType( sDrive ) == \"drive\" then\n        -- Check the disk exists\n        local bData = disk.hasData( sDrive )\n        if not bData then\n            print( \"No disk in \"..sDrive..\" drive\" )\n            return false\n        end\n    else\n        print( \"No disk drive named \"..sDrive )\n        return false\n    end\n    return true\nend\n\nlocal function get( sDrive )\n    if sDrive ~= nil then\n        if checkDrive( sDrive ) then\n            local sLabel = disk.getLabel( sDrive )\n            if sLabel then\n                print( \"Disk label is \\\"\"..sLabel..\"\\\"\" )\n            else\n                print( \"No Disk label\" )\n            end\n        end\n    else\n        local sLabel = os.getComputerLabel()\n        if sLabel then\n            print( \"Computer label is \\\"\"..sLabel..\"\\\"\" )\n        else\n            print( \"No Computer label\" )\n        end\n    end\nend\n\nlocal function set( sDrive, sText )\n    if sDrive ~= nil then\n        if checkDrive( sDrive ) then\n            disk.setLabel( sDrive, sText )\n            local sLabel = disk.getLabel( sDrive )\n            if sLabel then\n                print( \"Disk label set to \\\"\"..sLabel..\"\\\"\" )\n            else\n                print( \"Disk label cleared\" )\n            end\n        end\n    else\n        os.setComputerLabel( sText )\n        local sLabel = os.getComputerLabel()\n        if sLabel then\n            print( \"Computer label set to \\\"\"..sLabel..\"\\\"\" )\n        else\n            print( \"Computer label cleared\" )\n        end\n    end\nend\n\nlocal tArgs = { ... }\nlocal sCommand = tArgs[1]\nif sCommand == \"get\" then\n    -- Get a label\n    if #tArgs == 1 then\n        get( nil )\n    elseif #tArgs == 2 then\n        get( tArgs[2] )\n    else\n        printUsage()\n    end\nelseif sCommand == \"set\" then\n    -- Set a label\n    if #tArgs == 2 then\n        set( nil, tArgs[2] )\n    elseif #tArgs == 3 then\n        set( tArgs[2], tArgs[3] )\n    else\n        printUsage()\n    end\nelseif sCommand == \"clear\" then\n    -- Clear a label\n    if #tArgs == 1 then\n        set( nil, nil )\n    elseif #tArgs == 2 then\n        set( tArgs[2], nil )\n    else\n        printUsage()\n    end\nelse\n    printUsage()\nend","copy.lua":"\nlocal tArgs = { ... }\nif #tArgs < 2 then\n    print( \"Usage: cp <source> <destination>\" )\n    return\nend\n\nlocal sSource = shell.resolve( tArgs[1] )\nlocal sDest = shell.resolve( tArgs[2] )\nlocal tFiles = fs.find( sSource )\nif #tFiles > 0 then\n    for n,sFile in ipairs( tFiles ) do\n        if fs.isDir( sDest ) then\n            fs.copy( sFile, fs.combine( sDest, fs.getName(sFile) ) )\n        elseif #tFiles == 1 then\n            if fs.exists( sDest ) then\n                 printError( \"Destination exists\" )\n            else\n                 fs.copy( sFile, sDest )\n            end\n        else\n            printError( \"Cannot overwrite file multiple times\" )\n            return\n        end\n    end\nelse\n    printError( \"No matching files\" )\nend","set.lua":"\nlocal tArgs = { ... }\nif #tArgs == 0 then\n    -- \"set\"\n    local x,y = term.getCursorPos()\n    local tSettings = {}\n    for n,sName in ipairs( settings.getNames() ) do\n        tSettings[n] = textutils.serialize(sName) .. \" is \" .. textutils.serialize(settings.get(sName))\n    end\n    textutils.pagedPrint(table.concat(tSettings,\"\\n\"),y-3)\n\nelseif #tArgs == 1 then\n    -- \"set foo\"\n    local sName = tArgs[1]\n    print( textutils.serialize(sName) .. \" is \" .. textutils.serialize(settings.get(sName)) )\n\nelse\n    -- \"set foo bar\"\n    local sName = tArgs[1]\n    local sValue = tArgs[2]\n    local value\n    if sValue == \"true\" then\n        value = true\n    elseif sValue == \"false\" then\n        value = false\n    elseif sValue == \"nil\" then\n        value = nil\n    elseif tonumber(sValue) then\n        value = tonumber(sValue)\n    else\n        value = sValue\n    end\n\n    local oldValue = settings.get( sValue )\n    if value ~= nil then\n        settings.set( sName, value )\n        print( textutils.serialize(sName) .. \" set to \" .. textutils.serialize(value) )\n    else\n        settings.unset( sName )\n        print( textutils.serialize(sName) .. \" unset\" )\n    end\n    if value ~= oldValue then\n        settings.save( \".settings\" )\n    end\nend","http":{"pastebin.lua":"\nlocal function printUsage()\n    print( \"Usages:\" )\n    print( \"pastebin put <filename>\" )\n    print( \"pastebin get <code> <filename>\" )\n    print( \"pastebin run <code> <arguments>\" )\nend\n\nlocal tArgs = { ... }\nif #tArgs < 2 then\n    printUsage()\n    return\nend\n\nif not http then\n    printError( \"Pastebin requires http API\" )\n    printError( \"Set http_enable to true in ComputerCraft.cfg\" )\n    return\nend\n\nlocal function get(paste)\n    write( \"Connecting to pastebin.com... \" )\n    -- Add a cache buster so that spam protection is re-checked\n    local cacheBuster = (\"%x\"):format(math.random(0, 2^30))\n    local response, err = http.get(\n        \"https://pastebin.com/raw/\"..textutils.urlEncode( paste )..\"?cb=\"..cacheBuster\n    )\n\n    if response then\n        -- If spam protection is activated, we get redirected to /paste with Content-Type: text/html\n        local headers = response.getResponseHeaders()\n        if not headers[\"Content-Type\"] or not headers[\"Content-Type\"]:find( \"^text/plain\" ) then\n            io.stderr:write( \"Failed.\\n\" )\n            print( \"Pastebin blocked the download due to spam protection. Please complete the captcha in a web browser: https://pastebin.com/\"..textutils.urlEncode( paste ) )\n            return\n        end\n\n        print( \"Success.\" )\n\n        local sResponse = response.readAll()\n        response.close()\n        return sResponse\n    else\n        io.stderr:write( \"Failed.\\n\" )\n        print(err)\n    end\nend\n\nlocal sCommand = tArgs[1]\nif sCommand == \"put\" then\n    -- Upload a file to pastebin.com\n    -- Determine file to upload\n    local sFile = tArgs[2]\n    local sPath = shell.resolve( sFile )\n    if not fs.exists( sPath ) or fs.isDir( sPath ) then\n        print( \"No such file\" )\n        return\n    end\n\n    -- Read in the file\n    local sName = fs.getName( sPath )\n    local file = fs.open( sPath, \"r\" )\n    local sText = file.readAll()\n    file.close()\n\n    -- POST the contents to pastebin\n    write( \"Connecting to pastebin.com... \" )\n    local key = \"0ec2eb25b6166c0c27a394ae118ad829\"\n    local response = http.post(\n        \"https://pastebin.com/api/api_post.php\",\n        \"api_option=paste&\"..\n        \"api_dev_key=\"..key..\"&\"..\n        \"api_paste_format=lua&\"..\n        \"api_paste_name=\"..textutils.urlEncode(sName)..\"&\"..\n        \"api_paste_code=\"..textutils.urlEncode(sText)\n    )\n\n    if response then\n        print( \"Success.\" )\n\n        local sResponse = response.readAll()\n        response.close()\n\n        local sCode = string.match( sResponse, \"[^/]+$\" )\n        print( \"Uploaded as \"..sResponse )\n        print( \"Run \\\"pastebin get \"..sCode..\"\\\" to download anywhere\" )\n\n    else\n        print( \"Failed.\" )\n    end\n\nelseif sCommand == \"get\" then\n    -- Download a file from pastebin.com\n    if #tArgs < 3 then\n        printUsage()\n        return\n    end\n\n    -- Determine file to download\n    local sCode = tArgs[2]\n    local sFile = tArgs[3]\n    local sPath = shell.resolve( sFile )\n    if fs.exists( sPath ) then\n        print( \"File already exists\" )\n        return\n    end\n\n    -- GET the contents from pastebin\n    local res = get(sCode)\n    if res then\n        local file = fs.open( sPath, \"w\" )\n        file.write( res )\n        file.close()\n\n        print( \"Downloaded as \"..sFile )\n    end\nelseif sCommand == \"run\" then\n    local sCode = tArgs[2]\n\n    local res = get(sCode)\n    if res then\n        local func, err = load(res, sCode, \"t\", _ENV)\n        if not func then\n            printError( err )\n            return\n        end\n        local success, msg = pcall(func, select(3, ...))\n        if not success then\n            printError( msg )\n        end\n    end\nelse\n    printUsage()\n    return\nend","wget.lua":"\nlocal function printUsage()\n    print( \"Usage:\" )\n    print( \"wget <url> [filename]\" )\nend\n\nlocal tArgs = { ... }\nif #tArgs < 1 then\n    printUsage()\n    return\nend\n\nif not http then\n    printError( \"wget requires http API\" )\n    printError( \"Set http_enable to true in ComputerCraft.cfg\" )\n    return\nend\n\nlocal function getFilename( sUrl )\n    sUrl = sUrl:gsub( \"[#?].*\" , \"\" ):gsub( \"/+$\" , \"\" )\n    return sUrl:match( \"/([^/]+)$\" )\nend\n\nlocal function get( sUrl )\n    write( \"Connecting to \" .. sUrl .. \"... \" )\n\n    local response = http.get( sUrl , nil , true )\n    if not response then\n        print( \"Failed.\" )\n        return nil\n    end\n\n    print( \"Success.\" )\n\n    local sResponse = response.readAll()\n    response.close()\n    return sResponse\nend\n\n-- Determine file to download\nlocal sUrl = tArgs[1]\n\n--Check if the URL is valid\nlocal ok, err = http.checkURL( sUrl )\nif not ok then\n    printError( err or \"Invalid URL.\" )\n    return\nend\n\nlocal sFile = tArgs[2] or getFilename( sUrl )\nlocal sPath = shell.resolve( sFile )\nif fs.exists( sPath ) then\n    print( \"File already exists\" )\n    return\nend\n\n-- Do the get\nlocal res = get( sUrl )\nif res then\n    local file = fs.open( sPath, \"wb\" )\n    file.write( res )\n    file.close()\n\n    print( \"Downloaded as \"..sFile )\nend"},"pocket":{"falling.lua":"--[[\nFalling - Based on Tetris by Alexey Pajitnov\nThis version written by Gopher, at the request of Dan200, for\nComputerCraft v1.6. No particular rights are reserved.\n--]]\n\nlocal function colorass(c,bw)\n  return term.isColor() and c or bw\nend\n\nlocal block_s1= {\n    {\n      { 1,0,0,0, },\n      { 1,1,0,0, },\n      { 0,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,0,0,0, },\n      { 0,1,1,0, },\n      { 1,1,0,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"{}\"),\n    fg=colorass(colors.blue,colors.black),\n    bg=colorass(colors.cyan,colors.white),\n  }\nlocal block_s2= {\n    {\n      { 0,1,0,0, },\n      { 1,1,0,0, },\n      { 1,0,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,0,0,0, },\n      { 1,1,0,0, },\n      { 0,1,1,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"{}\"),\n    fg=colorass(colors.green,colors.black),\n    bg=colorass(colors.lime,colors.white),\n  }\nlocal block_line = {\n    {\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n    },\n    {\n      { 0,0,0,0, },\n      { 1,1,1,1, },\n      { 0,0,0,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"[]\"),\n    fg=colorass(colors.pink,colors.black),\n    bg=colorass(colors.red,colors.white),\n  }\nlocal block_square = {\n    {\n      { 1,1,0,0, },\n      { 1,1,0,0, },\n      { 0,0,0,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"[]\"),\n    fg=colorass(colors.lightBlue,colors.black),\n    bg=colorass(colors.blue,colors.white),\n  }\nlocal block_L1 = {\n    {\n      { 1,1,0,0, },\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,0,0,0, },\n      { 1,1,1,0, },\n      { 1,0,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n      { 0,1,1,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,0,1,0, },\n      { 1,1,1,0, },\n      { 0,0,0,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"()\"),\n    fg=colorass(colors.orange,colors.black),\n    bg=colorass(colors.yellow,colors.white),\n  }\nlocal block_L2 = {\n    {\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n      { 1,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,0,0,0, },\n      { 1,1,1,0, },\n      { 0,0,1,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,1,1,0, },\n      { 0,1,0,0, },\n      { 0,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 1,0,0,0, },\n      { 1,1,1,0, },\n      { 0,0,0,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"()\"),\n    fg=colorass(colors.brown,colors.black),\n    bg=colorass(colors.orange,colors.white),\n  }\nlocal block_T = {\n    {\n      { 0,1,0,0, },\n      { 1,1,0,0, },\n      { 0,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,0,0,0, },\n      { 1,1,1,0, },\n      { 0,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,1,0,0, },\n      { 0,1,1,0, },\n      { 0,1,0,0, },\n      { 0,0,0,0, },\n    },\n    {\n      { 0,1,0,0, },\n      { 1,1,1,0, },\n      { 0,0,0,0, },\n      { 0,0,0,0, },\n    },\n    ch=colorass(\"  \",\"<>\"),\n    fg=colorass(colors.cyan,colors.black),\n    bg=colorass(colors.purple,colors.white),\n  }\n\nlocal blocks={ block_line, block_square, block_s1, block_s2, block_L1, block_L2, block_T}\n\nlocal points={4,10,30,120}\n\nlocal function lpad(text,amt)\n  text=tostring(text)\n  return string.rep(\" \",amt-#text)..text\nend\n\nlocal width,height=term.getSize()\n\nif height<19 or width<26 then\n  print(\"Your screen is too small to play :(\")\n  return\nend\n\n\nlocal speedsByLevel={\n  1.2,\n  1.0,\n   .8,\n   .65,\n   .5,\n   .4,\n   .3,\n   .25,\n   .2,\n   .15,\n   .1,\n   .05,}\n\nlocal level=1\n\nlocal function playGame()\n  local score=0\n  local lines=0\n  local initialLevel=level\n  local next=blocks[math.random(1,#blocks)]\n\n  local pit={}\n\n\n  local heightAdjust=0\n\n  if height<=19 then\n    heightAdjust=1\n  end\n\n\n\n  local function drawScreen()\n    term.setTextColor(colors.white)\n    term.setBackgroundColor(colors.black)\n    term.clear()\n\n    term.setTextColor(colors.black)\n    term.setBackgroundColor(colorass(colors.lightGray, colors.white))\n    term.setCursorPos(22,2)\n    term.write(\"Score\") --score\n    term.setCursorPos(22,5)\n    term.write(\"Level\")  --level\n    term.setCursorPos(22,8)\n    term.write(\"Lines\")  --lines\n    term.setCursorPos(22,12)\n    term.write(\"Next\") --next\n\n    term.setCursorPos(21,1)\n    term.write(\"      \")\n    term.setCursorPos(21,2)\n    term.write(\" \") --score\n    term.setCursorPos(21,3)\n    term.write(\" \")\n    term.setCursorPos(21,4)\n    term.write(\"      \")\n    term.setCursorPos(21,5)\n    term.write(\" \")  --level\n    term.setCursorPos(21,6)\n    term.write(\" \")\n    term.setCursorPos(21,7)\n    term.write(\"      \")\n    term.setCursorPos(21,8)\n    term.write(\" \")  --lines\n    term.setCursorPos(21,9)\n    term.write(\" \")\n    term.setCursorPos(21,10)\n    term.write(\"      \")\n    term.setCursorPos(21,11)\n    term.write(\"      \")\n    term.setCursorPos(21,12)\n    term.write(\" \") --next\n    term.setCursorPos(26,12)\n    term.write(\" \") --next\n    term.setCursorPos(21,13)\n    term.write(\"      \")\n    term.setCursorPos(21,14)\n    term.write(\" \")\n    term.setCursorPos(21,15)\n    term.write(\" \")\n    term.setCursorPos(21,16)\n    term.write(\" \")\n    term.setCursorPos(21,17)\n    term.write(\" \")\n    term.setCursorPos(21,18)\n    term.write(\" \")\n    term.setCursorPos(21,19)\n    term.write(\"      \")\n    term.setCursorPos(21,20)\n    term.write(\"      \")\n  end\n\n  local function updateNumbers()\n    term.setTextColor(colors.white)\n    term.setBackgroundColor(colors.black)\n\n    term.setCursorPos(22,3)\n    term.write(lpad(score,5)) --score\n    term.setCursorPos(22,6)\n    term.write(lpad(level,5))  --level\n    term.setCursorPos(22,9)\n    term.write(lpad(lines,5))  --lines\n  end\n\n  local function drawBlockAt(block,xp,yp,rot)\n    term.setTextColor(block.fg)\n    term.setBackgroundColor(block.bg)\n    for y=1,4 do\n      for x=1,4 do\n        if block[rot][y][x]==1 then\n          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)\n          term.write(block.ch)\n        end\n      end\n    end\n  end\n\n  local function eraseBlockAt(block,xp,yp,rot)\n    term.setTextColor(colors.white)\n    term.setBackgroundColor(colors.black)\n    for y=1,4 do\n      for x=1,4 do\n        if block[rot][y][x]==1 then\n          term.setCursorPos((xp+x)*2-3,yp+y-1-heightAdjust)\n          term.write(\"  \")\n        end\n      end\n    end\n  end\n\n  local function testBlockAt(block,xp,yp,rot)\n    for y=1,4 do\n      local ty=yp+y-1\n      for x=1,4 do\n        local tx=xp+x-1\n        if block[rot][y][x]==1 then\n          if tx>10 or tx<1 or ty>20 or pit[ty][tx]~=0 then\n            return true\n          end\n        end\n      end\n    end\n  end\n\n  local function pitBlock(block,xp,yp,rot)\n    for y=1,4 do\n      for x=1,4 do\n        if block[rot][y][x]==1 then\n          pit[yp+y-1][xp+x-1]=block\n        end\n      end\n    end\n  end\n\n\n  local function clearPit()\n    for row=1,20 do\n      pit[row]={}\n      for col=1,10 do\n        pit[row][col]=0\n      end\n    end\n  end\n\n\n\n  drawScreen()\n  updateNumbers()\n\n  --declare & init the pit\n  clearPit()\n\n\n\n  local halt=false\n  local dropSpeed=speedsByLevel[math.min(level,12)]\n\n\n  local curBlock=next\n  next=blocks[math.random(1,7)]\n\n  local curX, curY, curRot=4, 1, 1\n  local dropTimer=os.startTimer(dropSpeed)\n\n  drawBlockAt(next,11.5,15+heightAdjust,1)\n  drawBlockAt(curBlock,curX,curY,curRot)\n\n  local function redrawPit()\n    for r=1+heightAdjust,20 do\n      term.setCursorPos(1,r-heightAdjust)\n      for c=1,10 do\n        if pit[r][c]==0 then\n          term.setTextColor(colors.black)\n          term.setBackgroundColor(colors.black)\n          term.write(\"  \")\n        else\n          term.setTextColor(pit[r][c].fg)\n          term.setBackgroundColor(pit[r][c].bg)\n          term.write(pit[r][c].ch)\n        end\n      end\n    end\n  end\n\n  local function hidePit()\n    for r=1+heightAdjust,20 do\n      term.setCursorPos(1,r-heightAdjust)\n      term.setTextColor(colors.black)\n      term.setBackgroundColor(colors.black)\n      term.write(\"                    \")\n    end\n  end\n\n  local function msgBox(message)\n    local x=math.floor((17-#message)/2)\n    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\n    term.setTextColor(colors.black)\n    term.setCursorPos(x,9)\n    term.write(\"+\"..string.rep(\"-\",#message+2)..\"+\")\n    term.setCursorPos(x,10)\n    term.write(\"|\")\n    term.setCursorPos(x+#message+3,10)\n    term.write(\"|\")\n    term.setCursorPos(x,11)\n    term.write(\"+\"..string.rep(\"-\",#message+2)..\"+\")\n    term.setTextColor(colors.white)\n    term.setBackgroundColor(colors.black)\n    term.setCursorPos(x+1,10)\n    term.write(\" \"..message..\" \")\n  end\n\n  local function clearRows()\n    local rows={}\n    for r=1,20 do\n      local count=0\n      for c=1,10 do\n        if pit[r][c]~=0 then\n          count=count+1\n        else\n          break\n        end\n      end\n      if count==10 then\n        rows[#rows+1]=r\n      end\n    end\n\n    if #rows>0 then\n      for i=1,4 do\n        sleep(.1)\n        for r=1,#rows do\n          r=rows[r]\n          term.setCursorPos(1,r-heightAdjust)\n          for c=1,10 do\n            term.setTextColor(pit[r][c].bg)\n            term.setBackgroundColor(pit[r][c].fg)\n            term.write(pit[r][c].ch)\n          end\n        end\n        sleep(.1)\n        for r=1,#rows do\n          r=rows[r]\n          term.setCursorPos(1,r-heightAdjust)\n          for c=1,10 do\n            term.setTextColor(pit[r][c].fg)\n            term.setBackgroundColor(pit[r][c].bg)\n            term.write(pit[r][c].ch)\n          end\n        end\n      end\n      --now remove the rows and drop everythign else\n      term.setBackgroundColor(colors.black)\n      for r=1,#rows do\n        r=rows[r]\n        term.setCursorPos(1,r-heightAdjust)\n        term.write(\"                    \")\n      end\n      sleep(.25)\n      for r=1,#rows do\n        table.remove(pit,rows[r])\n        table.insert(pit,1,{0,0,0,0,0,0,0,0,0,0})\n      end\n      redrawPit()\n      lines=lines+#rows\n      score=score+points[#rows]*math.min(level,20)\n      level=math.floor(lines/10)+initialLevel\n      dropSpeed=speedsByLevel[math.min(level,12)]\n      updateNumbers()\n    end\n    sleep(.25)\n  end\n\n  local function blockFall()\n    local result = false\n    if testBlockAt(curBlock,curX,curY+1,curRot) then\n      pitBlock(curBlock,curX,curY,curRot)\n      --detect rows that clear\n      clearRows()\n\n      curBlock=next\n      curX=4\n      curY=1\n      curRot=1\n      if testBlockAt(curBlock,curX,curY,curRot) then\n        halt=true\n      end\n      drawBlockAt(curBlock,curX,curY,curRot)\n      eraseBlockAt(next,11.5,15+heightAdjust,1)\n      next=blocks[math.random(1,7)]\n      drawBlockAt(next,11.5,15+heightAdjust,1)\n      return true\n    else\n      eraseBlockAt(curBlock,curX,curY,curRot)\n      curY=curY+1\n      drawBlockAt(curBlock,curX,curY,curRot)\n      return false\n    end\n  end\n\n\n  while not halt do\n    local e={os.pullEvent()}\n    if e[1]==\"timer\" then\n      if e[2]==dropTimer then\n        blockFall()\n        dropTimer=os.startTimer(dropSpeed)\n      end\n    elseif e[1]==\"key\" then\n      local key=e[2]\n      local dx,dy,dr=0,0,0\n      if key==keys.left or key==keys.a then\n        dx=-1\n      elseif key==keys.right or key==keys.d then\n        dx=1\n      elseif key==keys.up or key==keys.w then\n        dr=1\n      elseif key==keys.down or key==keys.s then\n        while not blockFall() do end\n        dropTimer=os.startTimer(dropSpeed)\n      elseif key==keys.space then\n        hidePit()\n        msgBox(\"Paused\")\n        while ({os.pullEvent(\"key\")})[2]~=keys.space do end\n        redrawPit()\n        drawBlockAt(curBlock,curX,curY,curRot)\n        dropTimer=os.startTimer(dropSpeed)\n      end\n      if dx+dr~=0 then\n        if not testBlockAt(curBlock,curX+dx,curY+dy,(dr>0 and curRot%#curBlock+dr or curRot)) then\n          eraseBlockAt(curBlock,curX,curY,curRot)\n          curX=curX+dx\n          curY=curY+dy\n          curRot=dr==0 and curRot or (curRot%#curBlock+dr)\n          drawBlockAt(curBlock,curX,curY,curRot)\n        end\n      end\n    elseif e[1]==\"term_resize\" then\n      local w,h=term.getSize()\n      if h==20 then\n        heightAdjust=0\n      else\n        heightAdjust=1\n      end\n      redrawPit()\n      drawBlockAt(curBlock,curX,curY,curRot)\n    end\n  end\n\n  msgBox(\"Game Over!\")\n  while true do\n    local _,k=os.pullEvent(\"key\")\n    if k==keys.space or k==keys.enter then\n      break\n    end\n  end\n\n  level = math.min(level,9)\nend\n\n\nlocal selected=1\nlocal playersDetected=false\n\nlocal function drawMenu()\n  term.setBackgroundColor(colors.black)\n  term.setTextColor(colorass(colors.red,colors.white))\n  term.clear()\n\n  local cx,cy=math.floor(width/2),math.floor(height/2)\n\n  term.setCursorPos(cx-6,cy-2)\n  term.write(\"F A L L I N G\")\n\n  if playersDetected then\n    if selected==0 then\n      term.setTextColor(colorass(colors.blue,colors.black))\n      term.setBackgroundColor(colorass(colors.gray,colors.white))\n    else\n      term.setTextColor(colorass(colors.lightBlue,colors.white))\n      term.setBackgroundColor(colors.black)\n    end\n    term.setCursorPos(cx-12,cy)\n    term.write(\" Play head-to-head game! \")\n  end\n\n  term.setCursorPos(cx-10,cy+1)\n  if selected==1 then\n    term.setTextColor(colorass(colors.blue,colors.black))\n    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\n  else\n    term.setTextColor(colorass(colors.lightBlue,colors.white))\n    term.setBackgroundColor(colors.black)\n  end\n  term.write(\" Play from level: <\" .. level .. \"> \")\n\n  term.setCursorPos(cx-3,cy+3)\n  if selected==2 then\n    term.setTextColor(colorass(colors.blue,colors.black))\n    term.setBackgroundColor(colorass(colors.lightGray,colors.white))\n  else\n    term.setTextColor(colorass(colors.lightBlue,colors.white))\n    term.setBackgroundColor(colors.black)\n  end\n  term.write(\" Quit \")\nend\n\n\nlocal function runMenu()\n  drawMenu()\n\n  while true do\n    local event={os.pullEvent()}\n    if event[1]==\"key\" then\n      local key=event[2]\n      if key==keys.right or key==keys.d and selected==1 then\n        level=math.min(level+1,9)\n        drawMenu()\n      elseif key==keys.left or key==keys.a and selected==1 then\n        level=math.max(level-1,1)\n        drawMenu()\n      elseif key>=keys.one and key<=keys.nine and selected==1 then\n        level=(key-keys.one) + 1\n        drawMenu()\n      elseif key==keys.up or key==keys.w then\n        selected=selected-1\n        if selected==0 then\n          selected=2\n        end\n        drawMenu()\n      elseif key==keys.down or key==keys.s then\n        selected=selected%2+1\n        drawMenu()\n      elseif key==keys.enter or key==keys.space then\n        break --begin play!\n      end\n    end\n  end\nend\n\nwhile true do\n  runMenu()\n  if selected==2 then\n    break\n  end\n\n  playGame()\nend\n\n\nterm.setTextColor(colors.white)\nterm.setBackgroundColor(colors.black)\nterm.clear()\nterm.setCursorPos(1,1)","equip.lua":"local ok, err = pcall( pocket.equipBack )\nif not ok then\n    printError( \"Nothing to equip\" )\nelse\n    print( \"Item equipped\" )\nend","unequip.lua":"local ok, err = pcall( pocket.unequipBack )\nif not ok then\n    printError( \"Nothing to unequip\" )\nelse\n    print( \"Item unequipped\" )\nend"},"help.lua":"local tArgs = { ... }\nlocal sTopic\nif #tArgs > 0 then\n    sTopic = tArgs[1]\nelse\n    sTopic = \"intro\"\nend\n\nif sTopic == \"index\" then\n    print( \"Help topics availiable:\" )\n    local tTopics = help.topics()\n    textutils.pagedTabulate( tTopics )\n    return\nend\n\nlocal sFile = help.lookup( sTopic )\nlocal file = ((sFile ~= nil) and io.open( sFile )) or nil\nif file then\n    local sContents = file:read(\"*a\")\n    file:close()\n\n    local _, nHeight = term.getSize()\n    textutils.pagedPrint( sContents, nHeight - 3 )\nelse\n    print( \"No help available\" )\nend","advanced":{"bg.lua":"\nif not shell.openTab then\n    printError( \"Requires multishell\" )\n    return\nend\n\nlocal tArgs = { ... }\nif #tArgs > 0 then\n    shell.openTab( table.unpack( tArgs ) )\nelse\n    shell.openTab( \"shell\" )\nend","multishell.lua":"\n-- Setup process switching\nlocal parentTerm = term.current()\nlocal w,h = parentTerm.getSize()\n\nlocal tProcesses = {}\nlocal nCurrentProcess = nil\nlocal nRunningProcess = nil\nlocal bShowMenu = false\nlocal bWindowsResized = false\nlocal nScrollPos = 1\nlocal bScrollRight = false\n\nlocal function selectProcess( n )\n    if nCurrentProcess ~= n then\n        if nCurrentProcess then\n            local tOldProcess = tProcesses[ nCurrentProcess ]\n            tOldProcess.window.setVisible( false )\n        end\n        nCurrentProcess = n\n        if nCurrentProcess then\n            local tNewProcess = tProcesses[ nCurrentProcess ]\n            tNewProcess.window.setVisible( true )\n            tNewProcess.bInteracted = true\n        end\n    end\nend\n\nlocal function setProcessTitle( n, sTitle )\n    tProcesses[ n ].sTitle = sTitle\nend\n\nlocal function resumeProcess( nProcess, sEvent, ... )\n    local tProcess = tProcesses[ nProcess ]\n    local sFilter = tProcess.sFilter\n    if sFilter == nil or sFilter == sEvent or sEvent == \"terminate\" then\n        local nPreviousProcess = nRunningProcess\n        nRunningProcess = nProcess\n        term.redirect( tProcess.terminal )\n        local ok, result = coroutine.resume( tProcess.co, sEvent, ... )\n        tProcess.terminal = term.current()\n        if ok then\n            tProcess.sFilter = result\n        else\n            printError( result )\n        end\n        nRunningProcess = nPreviousProcess\n    end\nend\n\nlocal function launchProcess( bFocus, tProgramEnv, sProgramPath, ... )\n    local tProgramArgs = table.pack( ... )\n    local nProcess = #tProcesses + 1\n    local tProcess = {}\n    tProcess.sTitle = fs.getName( sProgramPath )\n    if bShowMenu then\n        tProcess.window = window.create( parentTerm, 1, 2, w, h-1, false )\n    else\n        tProcess.window = window.create( parentTerm, 1, 1, w, h, false )\n    end\n    tProcess.co = coroutine.create( function()\n        os.run( tProgramEnv, sProgramPath, table.unpack( tProgramArgs, 1, tProgramArgs.n ) )\n        if not tProcess.bInteracted then\n            term.setCursorBlink( false )\n            print( \"Press any key to continue\" )\n            os.pullEvent( \"char\" )\n        end\n    end )\n    tProcess.sFilter = nil\n    tProcess.terminal = tProcess.window\n    tProcess.bInteracted = false\n    tProcesses[ nProcess ] = tProcess\n    if bFocus then\n        selectProcess( nProcess )\n    end\n    resumeProcess( nProcess )\n    return nProcess\nend\n\nlocal function cullProcess( nProcess )\n    local tProcess = tProcesses[ nProcess ]\n    if coroutine.status( tProcess.co ) == \"dead\" then\n        if nCurrentProcess == nProcess then\n            selectProcess( nil )\n        end\n        table.remove( tProcesses, nProcess )\n        if nCurrentProcess == nil then\n            if nProcess > 1 then\n                selectProcess( nProcess - 1 )\n            elseif #tProcesses > 0 then\n                selectProcess( 1 )\n            end\n        end\n        if nScrollPos ~= 1 then\n            nScrollPos = nScrollPos - 1\n        end\n        return true\n    end\n    return false\nend\n\nlocal function cullProcesses()\n    local culled = false\n    for n=#tProcesses,1,-1 do\n        culled = culled or cullProcess( n )\n    end\n    return culled\nend\n\n-- Setup the main menu\nlocal menuMainTextColor, menuMainBgColor, menuOtherTextColor, menuOtherBgColor\nif parentTerm.isColor() then\n    menuMainTextColor, menuMainBgColor = colors.yellow, colors.black\n    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray\nelse\n    menuMainTextColor, menuMainBgColor = colors.white, colors.black\n    menuOtherTextColor, menuOtherBgColor = colors.black, colors.gray\nend\n\nlocal function redrawMenu()\n    if bShowMenu then\n        -- Draw menu\n        parentTerm.setCursorPos( 1, 1 )\n        parentTerm.setBackgroundColor( menuOtherBgColor )\n        parentTerm.clearLine()\n        local nCharCount = 0\n        local nSize = parentTerm.getSize()\n        if nScrollPos ~= 1 then\n            parentTerm.setTextColor( menuOtherTextColor )\n            parentTerm.setBackgroundColor( menuOtherBgColor )\n            parentTerm.write( \"<\" )\n            nCharCount = 1\n        end\n        for n=nScrollPos,#tProcesses do\n            if n == nCurrentProcess then\n                parentTerm.setTextColor( menuMainTextColor )\n                parentTerm.setBackgroundColor( menuMainBgColor )\n            else\n                parentTerm.setTextColor( menuOtherTextColor )\n                parentTerm.setBackgroundColor( menuOtherBgColor )\n            end\n            parentTerm.write( \" \" .. tProcesses[n].sTitle .. \" \" )\n            nCharCount = nCharCount + #tProcesses[n].sTitle + 2\n        end\n        if nCharCount > nSize then\n            parentTerm.setTextColor( menuOtherTextColor )\n            parentTerm.setBackgroundColor( menuOtherBgColor )\n            parentTerm.setCursorPos( nSize, 1 )\n            parentTerm.write( \">\" )\n            bScrollRight = true\n        else\n            bScrollRight = false\n        end\n\n        -- Put the cursor back where it should be\n        local tProcess = tProcesses[ nCurrentProcess ]\n        if tProcess then\n            tProcess.window.restoreCursor()\n        end\n    end\nend\n\nlocal function resizeWindows()\n    local windowY, windowHeight\n    if bShowMenu then\n        windowY = 2\n        windowHeight = h-1\n    else\n        windowY = 1\n        windowHeight = h\n    end\n    for n=1,#tProcesses do\n        local tProcess = tProcesses[n]\n        local window = tProcess.window\n        local x,y = tProcess.window.getCursorPos()\n        if y > windowHeight then\n            tProcess.window.scroll( y - windowHeight )\n            tProcess.window.setCursorPos( x, windowHeight )\n        end\n        tProcess.window.reposition( 1, windowY, w, windowHeight )\n    end\n    bWindowsResized = true\nend\n\nlocal function setMenuVisible( bVis )\n    if bShowMenu ~= bVis then\n        bShowMenu = bVis\n        resizeWindows()\n        redrawMenu()\n    end\nend\n\nlocal multishell = {}\n\nfunction multishell.getFocus()\n    return nCurrentProcess\nend\n\nfunction multishell.setFocus( n )\n    if type( n ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( n ) .. \")\", 2 )\n    end\n    if n >= 1 and n <= #tProcesses then\n        selectProcess( n )\n        redrawMenu()\n        return true\n    end\n    return false\nend\n\nfunction multishell.getTitle( n )\n    if type( n ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( n ) .. \")\", 2 )\n    end\n    if n >= 1 and n <= #tProcesses then\n        return tProcesses[n].sTitle\n    end\n    return nil\nend\n\nfunction multishell.setTitle( n, sTitle )\n    if type( n ) ~= \"number\" then\n        error( \"bad argument #1 (expected number, got \" .. type( n ) .. \")\", 2 )\n    end\n    if type( sTitle ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( sTitle ) .. \")\", 2 )\n    end\n    if n >= 1 and n <= #tProcesses then\n        setProcessTitle( n, sTitle )\n        redrawMenu()\n    end\nend\n\nfunction multishell.getCurrent()\n    return nRunningProcess\nend\n\nfunction multishell.launch( tProgramEnv, sProgramPath, ... )\n    if type( tProgramEnv ) ~= \"table\" then\n        error( \"bad argument #1 (expected table, got \" .. type( tProgramEnv ) .. \")\", 2 )\n    end\n    if type( sProgramPath ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( sProgramPath ) .. \")\", 2 )\n    end\n    local previousTerm = term.current()\n    setMenuVisible( (#tProcesses + 1) >= 2 )\n    local nResult = launchProcess( false, tProgramEnv, sProgramPath, ... )\n    redrawMenu()\n    term.redirect( previousTerm )\n    return nResult\nend\n\nfunction multishell.getCount()\n    return #tProcesses\nend\n\n-- Begin\nparentTerm.clear()\nsetMenuVisible( false )\nlaunchProcess( true, {\n    [\"shell\"] = shell,\n    [\"multishell\"] = multishell,\n}, \"/rom/programs/shell.lua\" )\n\n-- Run processes\nwhile #tProcesses > 0 do\n    -- Get the event\n    local tEventData = table.pack( os.pullEventRaw() )\n    local sEvent = tEventData[1]\n    if sEvent == \"term_resize\" then\n        -- Resize event\n        w,h = parentTerm.getSize()\n        resizeWindows()\n        redrawMenu()\n\n    elseif sEvent == \"char\" or sEvent == \"key\" or sEvent == \"key_up\" or sEvent == \"paste\" or sEvent == \"terminate\" then\n        -- Keyboard event\n        -- Passthrough to current process\n        resumeProcess( nCurrentProcess, table.unpack( tEventData, 1, tEventData.n ) )\n        if cullProcess( nCurrentProcess ) then\n            setMenuVisible( #tProcesses >= 2 )\n            redrawMenu()\n        end\n\n    elseif sEvent == \"mouse_click\" then\n        -- Click event\n        local button, x, y = tEventData[2], tEventData[3], tEventData[4]\n        if bShowMenu and y == 1 then\n            -- Switch process\n            if x == 1 and nScrollPos ~= 1 then\n                nScrollPos = nScrollPos - 1\n                redrawMenu()\n            elseif bScrollRight and x == term.getSize() then\n                nScrollPos = nScrollPos + 1\n                redrawMenu()\n            else\n                local tabStart = 1\n                if nScrollPos ~= 1 then\n                    tabStart = 2\n                end\n                for n=nScrollPos,#tProcesses do\n                    local tabEnd = tabStart + string.len( tProcesses[n].sTitle ) + 1\n                    if x >= tabStart and x <= tabEnd then\n                        selectProcess( n )\n                        redrawMenu()\n                        break\n                    end\n                    tabStart = tabEnd + 1\n                end\n            end\n        else\n            -- Passthrough to current process\n            resumeProcess( nCurrentProcess, sEvent, button, x, (bShowMenu and y-1) or y )\n            if cullProcess( nCurrentProcess ) then\n                setMenuVisible( #tProcesses >= 2 )\n                redrawMenu()\n            end\n        end\n\n    elseif sEvent == \"mouse_drag\" or sEvent == \"mouse_up\" or sEvent == \"mouse_scroll\" then\n        -- Other mouse event\n        local p1, x, y = tEventData[2], tEventData[3], tEventData[4]\n        if bShowMenu and sEvent == \"mouse_scroll\" and y == 1 then\n            if p1 == -1 and nScrollPos ~= 1 then\n                nScrollPos = nScrollPos - 1\n                redrawMenu()\n            elseif bScrollRight and p1 == 1 then\n                nScrollPos = nScrollPos + 1\n                redrawMenu()\n            end\n        elseif not (bShowMenu and y == 1) then\n            -- Passthrough to current process\n            resumeProcess( nCurrentProcess, sEvent, p1, x, (bShowMenu and y-1) or y )\n            if cullProcess( nCurrentProcess ) then\n                setMenuVisible( #tProcesses >= 2 )\n                redrawMenu()\n            end\n        end\n\n    else\n        -- Other event\n        -- Passthrough to all processes\n        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event\n        for n=1,nLimit do\n            resumeProcess( n, table.unpack( tEventData, 1, tEventData.n ) )\n        end\n        if cullProcesses() then\n            setMenuVisible( #tProcesses >= 2 )\n            redrawMenu()\n        end\n    end\n\n    if bWindowsResized then\n        -- Pass term_resize to all processes\n        local nLimit = #tProcesses -- Storing this ensures any new things spawned don't get the event\n        for n=1,nLimit do\n            resumeProcess( n, \"term_resize\" )\n        end\n        bWindowsResized = false\n        if cullProcesses() then\n            setMenuVisible( #tProcesses >= 2 )\n            redrawMenu()\n        end\n    end\nend\n\n-- Shutdown\nterm.redirect( parentTerm )","fg.lua":"\nif not shell.openTab then\n    printError( \"Requires multishell\" )\n    return\nend\n\nlocal tArgs = { ... }\nif #tArgs > 0 then\n    local nTask = shell.openTab( table.unpack( tArgs ) )\n    if nTask then\n        shell.switchTab( nTask )\n    end\nelse\n    local nTask = shell.openTab( \"shell\" )\n    if nTask then\n        shell.switchTab( nTask )\n    end\nend"},"monitor.lua":"local function printUsage()\n    print( \"Usage: monitor <name> <program> <arguments>\" )\n    return\nend\n\nlocal tArgs = { ... }\nif #tArgs < 2 then\n    printUsage()\n    return\nend\n\nlocal sName = tArgs[1]\nif peripheral.getType( sName ) ~= \"monitor\" then\n    print( \"No monitor named \".. sName )\n    return\nend\n\nlocal sProgram = tArgs[2]\nlocal sPath = shell.resolveProgram( sProgram )\nif sPath == nil then\n    print( \"No such program: \"..sProgram )\n    return\nend\n\nprint( \"Running \"..sProgram..\" on monitor \"..sName )\n\nlocal monitor = peripheral.wrap( sName )\nlocal previousTerm = term.redirect( monitor )\n\nlocal co = coroutine.create( function()\n    shell.run( sProgram, table.unpack( tArgs, 3 ) )\nend )\n\nlocal function resume( ... )\n    local ok, param = coroutine.resume( co, ... )\n    if not ok then\n        printError( param )\n    end\n    return param\nend\n\nlocal ok, param = pcall( function()\n    local sFilter = resume()\n    while coroutine.status( co ) ~= \"dead\" do\n        local tEvent = table.pack( os.pullEventRaw() )\n        if sFilter == nil or tEvent[1] == sFilter or tEvent[1] == \"terminate\" then\n            sFilter = resume( table.unpack( tEvent, 1, tEvent.n ) )\n        end\n        if coroutine.status( co ) ~= \"dead\" and (sFilter == nil or sFilter == \"mouse_click\") then\n            if tEvent[1] == \"monitor_touch\" and tEvent[2] == sName then\n                sFilter = resume( \"mouse_click\", 1, table.unpack( tEvent, 3, tEvent.n ) )\n            end\n        end\n        if coroutine.status( co ) ~= \"dead\" and (sFilter == nil or sFilter == \"term_resize\") then\n            if tEvent[1] == \"monitor_resize\" and tEvent[2] == sName then\n                sFilter = resume( \"term_resize\" )\n            end\n        end\n    end\nend )\n\nterm.redirect( previousTerm )\nif not ok then\n    printError( param )\nend","lua.lua":"\nlocal tArgs = { ... }\nif #tArgs > 0 then\n    print( \"This is an interactive Lua prompt.\" )\n    print( \"To run a lua program, just type its name.\" )\n    return\nend\n\nlocal bRunning = true\nlocal tCommandHistory = {}\nlocal tEnv = {\n    [\"exit\"] = function()\n        bRunning = false\n    end,\n    [\"_echo\"] = function( ... )\n        return ...\n    end,\n}\nsetmetatable( tEnv, { __index = _ENV } )\n\nif term.isColour() then\n    term.setTextColour( colours.yellow )\nend\nprint( \"Interactive Lua prompt.\" )\nprint( \"Call exit() to exit.\" )\nterm.setTextColour( colours.white )\n\nwhile bRunning do\n    --if term.isColour() then\n    --    term.setTextColour( colours.yellow )\n    --end\n    write( \"lua> \" )\n    --term.setTextColour( colours.white )\n\n    local s = read( nil, tCommandHistory, function( sLine )\n        if settings.get( \"lua.autocomplete\" ) then\n            local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.:]+$\" )\n            if nStartPos then\n                sLine = string.sub( sLine, nStartPos )\n            end\n            if #sLine > 0 then\n                return textutils.complete( sLine, tEnv )\n            end\n        end\n        return nil\n    end )\n    if s:match(\"%S\") and tCommandHistory[#tCommandHistory] ~= s then\n        table.insert( tCommandHistory, s )\n    end\n\n    local nForcePrint = 0\n    local func, e = load( s, \"lua\", \"t\", tEnv )\n    local func2, e2 = load( \"return _echo(\"..s..\");\", \"lua\", \"t\", tEnv )\n    if not func then\n        if func2 then\n            func = func2\n            e = nil\n            nForcePrint = 1\n        end\n    else\n        if func2 then\n            func = func2\n        end\n    end\n\n    if func then\n        local tResults = table.pack( pcall( func ) )\n        if tResults[1] then\n            local n = 1\n            while n < tResults.n or (n <= nForcePrint) do\n                local value = tResults[ n + 1 ]\n                if type( value ) == \"table\" then\n                    local metatable = getmetatable( value )\n                    if type(metatable) == \"table\" and type(metatable.__tostring) == \"function\" then\n                        print( tostring( value ) )\n                    else\n                        local ok, serialised = pcall( textutils.serialise, value )\n                        if ok then\n                            print( serialised )\n                        else\n                            print( tostring( value ) )\n                        end\n                    end\n                else\n                    print( tostring( value ) )\n                end\n                n = n + 1\n            end\n        else\n            printError( tResults[2] )\n        end\n    else\n        printError( e )\n    end\n\nend","programs.lua":"\nlocal bAll = false\nlocal tArgs = { ... }\nif #tArgs > 0 and tArgs[1] == \"all\" then\n    bAll = true\nend\n\nlocal tPrograms = shell.programs( bAll )\ntextutils.pagedTabulate( tPrograms )","gps.lua":"\nlocal function printUsage()\n    print( \"Usages:\" )\n    print( \"gps host\" )\n    print( \"gps host <x> <y> <z>\" )\n    print( \"gps locate\" )\nend\n\nlocal tArgs = { ... }\nif #tArgs < 1 then\n    printUsage()\n    return\nend\n\n local sCommand = tArgs[1]\nif sCommand == \"locate\" then\n    -- \"gps locate\"\n    -- Just locate this computer (this will print the results)\n    gps.locate( 2, true )\n\nelseif sCommand == \"host\" then\n    -- \"gps host\"\n    -- Act as a GPS host\n    if pocket then\n        print( \"GPS Hosts must be stationary\" )\n        return\n    end\n\n    -- Find a modem\n    local sModemSide = nil\n    for n,sSide in ipairs( rs.getSides() ) do\n        if peripheral.getType( sSide ) == \"modem\" and peripheral.call( sSide, \"isWireless\" ) then\n            sModemSide = sSide\n            break\n        end\n    end\n\n    if sModemSide == nil then\n        print( \"No wireless modems found. 1 required.\" )\n        return\n    end\n\n    -- Determine position\n    local x,y,z\n    if #tArgs >= 4 then\n        -- Position is manually specified\n        x = tonumber(tArgs[2])\n        y = tonumber(tArgs[3])\n        z = tonumber(tArgs[4])\n        if x == nil or y == nil or z == nil then\n            printUsage()\n            return\n        end\n        print( \"Position is \"..x..\",\"..y..\",\"..z )\n    else\n        -- Position is to be determined using locate\n        x,y,z = gps.locate( 2, true )\n        if x == nil then\n            print( \"Run \\\"gps host <x> <y> <z>\\\" to set position manually\" )\n            return\n        end\n    end\n\n    -- Open a channel\n    local modem = peripheral.wrap( sModemSide )\n    print( \"Opening channel on modem \"..sModemSide )\n    modem.open( gps.CHANNEL_GPS )\n\n    -- Serve requests indefinately\n    local nServed = 0\n    while true do\n        local e, p1, p2, p3, p4, p5 = os.pullEvent( \"modem_message\" )\n        if e == \"modem_message\" then\n            -- We received a message from a modem\n            local sSide, sChannel, sReplyChannel, sMessage, nDistance = p1, p2, p3, p4, p5\n            if sSide == sModemSide and sChannel == gps.CHANNEL_GPS and sMessage == \"PING\" and nDistance then\n                -- We received a ping message on the GPS channel, send a response\n                modem.transmit( sReplyChannel, gps.CHANNEL_GPS, { x, y, z } )\n\n                -- Print the number of requests handled\n                nServed = nServed + 1\n                if nServed > 1 then\n                    local x,y = term.getCursorPos()\n                    term.setCursorPos(1,y-1)\n                end\n                print( nServed..\" GPS requests served\" )\n            end\n        end\n    end\nelse\n    -- \"gps somethingelse\"\n    -- Error\n    printUsage()\nend","type.lua":"\nlocal tArgs = { ... }\nif #tArgs < 1 then\n    print( \"Usage: type <path>\" )\n    return\nend\n\nlocal sPath = shell.resolve( tArgs[1] )\nif fs.exists( sPath ) then\n    if fs.isDir( sPath ) then\n        print( \"directory\" )\n    else\n        print( \"file\" )\n    end\nelse\n    print( \"No such path\" )\nend\n","turtle":{"refuel.lua":"\nlocal tArgs = { ... }\nlocal nLimit = 1\nif #tArgs > 1 then\n    print( \"Usage: refuel [number]\" )\n    return\nelseif #tArgs > 0 then\n    if tArgs[1] == \"all\" then\n        nLimit = 64 * 16\n    else\n        nLimit = tonumber( tArgs[1] )\n    end\nend\n\nif turtle.getFuelLevel() ~= \"unlimited\" then\n    for n=1,16 do\n        local nCount = turtle.getItemCount(n)\n        if nLimit > 0 and nCount > 0 and turtle.getFuelLevel() < turtle.getFuelLimit() then\n            local nBurn = math.min( nLimit, nCount )\n            turtle.select( n )\n            if turtle.refuel( nBurn ) then\n                local nNewCount = turtle.getItemCount(n)\n                nLimit = nLimit - (nCount - nNewCount)\n            end\n        end\n    end\n    print( \"Fuel level is \"..turtle.getFuelLevel() )\n    if turtle.getFuelLevel() == turtle.getFuelLimit() then\n        print( \"Fuel limit reached\" )\n    end\nelse\n    print( \"Fuel level is unlimited\" )\nend","dance.lua":"\nlocal tMoves = {\n    function()\n        turtle.up()\n        turtle.down()\n    end,\n    function()\n        turtle.up()\n        turtle.turnLeft()\n        turtle.turnLeft()\n        turtle.turnLeft()\n        turtle.turnLeft()\n        turtle.down()\n    end,\n    function()\n        turtle.up()\n        turtle.turnRight()\n        turtle.turnRight()\n        turtle.turnRight()\n        turtle.turnRight()\n        turtle.down()\n    end,\n    function()\n        turtle.turnLeft()\n        turtle.turnLeft()\n        turtle.turnLeft()\n        turtle.turnLeft()\n    end,\n    function()\n        turtle.turnRight()\n        turtle.turnRight()\n        turtle.turnRight()\n        turtle.turnRight()\n    end,\n    function()\n        turtle.turnLeft()\n        turtle.back()\n        turtle.back()\n        turtle.turnRight()\n        turtle.turnRight()\n        turtle.back()\n        turtle.back()\n        turtle.turnLeft()\n    end,\n    function()\n        turtle.turnRight()\n        turtle.back()\n        turtle.back()\n        turtle.turnLeft()\n        turtle.turnLeft()\n        turtle.back()\n        turtle.back()\n        turtle.turnRight()\n    end,\n    function()\n        turtle.back()\n        turtle.turnLeft()\n        turtle.back()\n        turtle.turnLeft()\n        turtle.back()\n        turtle.turnLeft()\n        turtle.back()\n        turtle.turnLeft()\n    end,\n    function()\n        turtle.back()\n        turtle.turnRight()\n        turtle.back()\n        turtle.turnRight()\n        turtle.back()\n        turtle.turnRight()\n        turtle.back()\n        turtle.turnRight()\n    end,\n}\n\ntextutils.slowWrite( \"Preparing to get down.\" )\ntextutils.slowPrint( \"..\", 0.75 )\n\nlocal sAudio = nil\nfor n,sName in pairs( peripheral.getNames() ) do\n    if disk.hasAudio( sName ) then\n        disk.playAudio( sName )\n        print( \"Jamming to \"..disk.getAudioTitle( sName ) )\n        sAudio = sName\n        break\n    end\nend\n\nprint( \"Press any key to stop the groove\" )\n\nparallel.waitForAny(\n    function()\n        while not bEnd do\n            local event, key = os.pullEvent(\"key\")\n            if key ~= keys.escape then\n                return\n            end\n        end\n    end,\n    function()\n        while true do\n            local fnMove = tMoves[math.random(1,#tMoves)]\n            fnMove()\n        end\n    end\n)\n\nif sAudio then\n    disk.stopAudio( sAudio )\nend","tunnel.lua":"\nlocal tArgs = { ... }\nif #tArgs ~= 1 then\n    print( \"Usage: tunnel <length>\" )\n    return\nend\n\n-- Mine in a quarry pattern until we hit something we can't dig\nlocal length = tonumber( tArgs[1] )\nif length < 1 then\n    print( \"Tunnel length must be positive\" )\n    return\nend\n\nlocal depth = 0\nlocal collected = 0\n\nlocal function collect()\n    collected = collected + 1\n    if math.fmod(collected, 25) == 0 then\n        print( \"Mined \"..collected..\" items.\" )\n    end\nend\n\nlocal function tryDig()\n    while turtle.detect() do\n        if turtle.dig() then\n            collect()\n            sleep(0.5)\n        else\n            return false\n        end\n    end\n    return true\nend\n\nlocal function tryDigUp()\n    while turtle.detectUp() do\n        if turtle.digUp() then\n            collect()\n            sleep(0.5)\n        else\n            return false\n        end\n    end\n    return true\nend\n\nlocal function tryDigDown()\n    while turtle.detectDown() do\n        if turtle.digDown() then\n            collect()\n            sleep(0.5)\n        else\n            return false\n        end\n    end\n    return true\nend\n\nlocal function refuel()\n    local fuelLevel = turtle.getFuelLevel()\n    if fuelLevel == \"unlimited\" or fuelLevel > 0 then\n        return\n    end\n\n    local function tryRefuel()\n        for n=1,16 do\n            if turtle.getItemCount(n) > 0 then\n                turtle.select(n)\n                if turtle.refuel(1) then\n                    turtle.select(1)\n                    return true\n                end\n            end\n        end\n        turtle.select(1)\n        return false\n    end\n\n    if not tryRefuel() then\n        print( \"Add more fuel to continue.\" )\n        while not tryRefuel() do\n            os.pullEvent( \"turtle_inventory\" )\n        end\n        print( \"Resuming Tunnel.\" )\n    end\nend\n\nlocal function tryUp()\n    refuel()\n    while not turtle.up() do\n        if turtle.detectUp() then\n            if not tryDigUp() then\n                return false\n            end\n        elseif turtle.attackUp() then\n            collect()\n        else\n            sleep( 0.5 )\n        end\n    end\n    return true\nend\n\nlocal function tryDown()\n    refuel()\n    while not turtle.down() do\n        if turtle.detectDown() then\n            if not tryDigDown() then\n                return false\n            end\n        elseif turtle.attackDown() then\n            collect()\n        else\n            sleep( 0.5 )\n        end\n    end\n    return true\nend\n\nlocal function tryForward()\n    refuel()\n    while not turtle.forward() do\n        if turtle.detect() then\n            if not tryDig() then\n                return false\n            end\n        elseif turtle.attack() then\n            collect()\n        else\n            sleep( 0.5 )\n        end\n    end\n    return true\nend\n\nprint( \"Tunnelling...\" )\n\nfor n=1,length do\n    turtle.placeDown()\n    tryDigUp()\n    turtle.turnLeft()\n    tryDig()\n    tryUp()\n    tryDig()\n    turtle.turnRight()\n    turtle.turnRight()\n    tryDig()\n    tryDown()\n    tryDig()\n    turtle.turnLeft()\n\n    if n<length then\n        tryDig()\n        if not tryForward() then\n            print( \"Aborting Tunnel.\" )\n            break\n        end\n    else\n        print( \"Tunnel complete.\" )\n    end\n\nend\n\n--[[\nprint( \"Returning to start...\" )\n\n-- Return to where we started\nturtle.turnLeft()\nturtle.turnLeft()\nwhile depth > 0 do\n    if turtle.forward() then\n        depth = depth - 1\n    else\n        turtle.dig()\n    end\nend\nturtle.turnRight()\nturtle.turnRight()\n]]\n\nprint( \"Tunnel complete.\" )\nprint( \"Mined \"..collected..\" items total.\" )","excavate.lua":"\nlocal tArgs = { ... }\nif #tArgs ~= 1 then\n    print( \"Usage: excavate <diameter>\" )\n    return\nend\n\n-- Mine in a quarry pattern until we hit something we can't dig\nlocal size = tonumber( tArgs[1] )\nif size < 1 then\n    print( \"Excavate diameter must be positive\" )\n    return\nend\n\nlocal depth = 0\nlocal unloaded = 0\nlocal collected = 0\n\nlocal xPos,zPos = 0,0\nlocal xDir,zDir = 0,1\n\nlocal goTo -- Filled in further down\nlocal refuel -- Filled in further down\n\nlocal function unload( _bKeepOneFuelStack )\n    print( \"Unloading items...\" )\n    for n=1,16 do\n        local nCount = turtle.getItemCount(n)\n        if nCount > 0 then\n            turtle.select(n)\n            local bDrop = true\n            if _bKeepOneFuelStack and turtle.refuel(0) then\n                bDrop = false\n                _bKeepOneFuelStack = false\n            end\n            if bDrop then\n                turtle.drop()\n                unloaded = unloaded + nCount\n            end\n        end\n    end\n    collected = 0\n    turtle.select(1)\nend\n\nlocal function returnSupplies()\n    local x,y,z,xd,zd = xPos,depth,zPos,xDir,zDir\n    print( \"Returning to surface...\" )\n    goTo( 0,0,0,0,-1 )\n\n    local fuelNeeded = 2*(x+y+z) + 1\n    if not refuel( fuelNeeded ) then\n        unload( true )\n        print( \"Waiting for fuel\" )\n        while not refuel( fuelNeeded ) do\n            os.pullEvent( \"turtle_inventory\" )\n        end\n    else\n        unload( true )\n    end\n\n    print( \"Resuming mining...\" )\n    goTo( x,y,z,xd,zd )\nend\n\nlocal function collect()\n    local bFull = true\n    local nTotalItems = 0\n    for n=1,16 do\n        local nCount = turtle.getItemCount(n)\n        if nCount == 0 then\n            bFull = false\n        end\n        nTotalItems = nTotalItems + nCount\n    end\n\n    if nTotalItems > collected then\n        collected = nTotalItems\n        if math.fmod(collected + unloaded, 50) == 0 then\n            print( \"Mined \"..(collected + unloaded)..\" items.\" )\n        end\n    end\n\n    if bFull then\n        print( \"No empty slots left.\" )\n        return false\n    end\n    return true\nend\n\nfunction refuel( ammount )\n    local fuelLevel = turtle.getFuelLevel()\n    if fuelLevel == \"unlimited\" then\n        return true\n    end\n\n    local needed = ammount or (xPos + zPos + depth + 2)\n    if turtle.getFuelLevel() < needed then\n        local fueled = false\n        for n=1,16 do\n            if turtle.getItemCount(n) > 0 then\n                turtle.select(n)\n                if turtle.refuel(1) then\n                    while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do\n                        turtle.refuel(1)\n                    end\n                    if turtle.getFuelLevel() >= needed then\n                        turtle.select(1)\n                        return true\n                    end\n                end\n            end\n        end\n        turtle.select(1)\n        return false\n    end\n\n    return true\nend\n\nlocal function tryForwards()\n    if not refuel() then\n        print( \"Not enough Fuel\" )\n        returnSupplies()\n    end\n\n    while not turtle.forward() do\n        if turtle.detect() then\n            if turtle.dig() then\n                if not collect() then\n                    returnSupplies()\n                end\n            else\n                return false\n            end\n        elseif turtle.attack() then\n            if not collect() then\n                returnSupplies()\n            end\n        else\n            sleep( 0.5 )\n        end\n    end\n\n    xPos = xPos + xDir\n    zPos = zPos + zDir\n    return true\nend\n\nlocal function tryDown()\n    if not refuel() then\n        print( \"Not enough Fuel\" )\n        returnSupplies()\n    end\n\n    while not turtle.down() do\n        if turtle.detectDown() then\n            if turtle.digDown() then\n                if not collect() then\n                    returnSupplies()\n                end\n            else\n                return false\n            end\n        elseif turtle.attackDown() then\n            if not collect() then\n                returnSupplies()\n            end\n        else\n            sleep( 0.5 )\n        end\n    end\n\n    depth = depth + 1\n    if math.fmod( depth, 10 ) == 0 then\n        print( \"Descended \"..depth..\" metres.\" )\n    end\n\n    return true\nend\n\nlocal function turnLeft()\n    turtle.turnLeft()\n    xDir, zDir = -zDir, xDir\nend\n\nlocal function turnRight()\n    turtle.turnRight()\n    xDir, zDir = zDir, -xDir\nend\n\nfunction goTo( x, y, z, xd, zd )\n    while depth > y do\n        if turtle.up() then\n            depth = depth - 1\n        elseif turtle.digUp() or turtle.attackUp() then\n            collect()\n        else\n            sleep( 0.5 )\n        end\n    end\n\n    if xPos > x then\n        while xDir ~= -1 do\n            turnLeft()\n        end\n        while xPos > x do\n            if turtle.forward() then\n                xPos = xPos - 1\n            elseif turtle.dig() or turtle.attack() then\n                collect()\n            else\n                sleep( 0.5 )\n            end\n        end\n    elseif xPos < x then\n        while xDir ~= 1 do\n            turnLeft()\n        end\n        while xPos < x do\n            if turtle.forward() then\n                xPos = xPos + 1\n            elseif turtle.dig() or turtle.attack() then\n                collect()\n            else\n                sleep( 0.5 )\n            end\n        end\n    end\n\n    if zPos > z then\n        while zDir ~= -1 do\n            turnLeft()\n        end\n        while zPos > z do\n            if turtle.forward() then\n                zPos = zPos - 1\n            elseif turtle.dig() or turtle.attack() then\n                collect()\n            else\n                sleep( 0.5 )\n            end\n        end\n    elseif zPos < z then\n        while zDir ~= 1 do\n            turnLeft()\n        end\n        while zPos < z do\n            if turtle.forward() then\n                zPos = zPos + 1\n            elseif turtle.dig() or turtle.attack() then\n                collect()\n            else\n                sleep( 0.5 )\n            end\n        end\n    end\n\n    while depth < y do\n        if turtle.down() then\n            depth = depth + 1\n        elseif turtle.digDown() or turtle.attackDown() then\n            collect()\n        else\n            sleep( 0.5 )\n        end\n    end\n\n    while zDir ~= zd or xDir ~= xd do\n        turnLeft()\n    end\nend\n\nif not refuel() then\n    print( \"Out of Fuel\" )\n    return\nend\n\nprint( \"Excavating...\" )\n\nlocal reseal = false\nturtle.select(1)\nif turtle.digDown() then\n    reseal = true\nend\n\nlocal alternate = 0\nlocal done = false\nwhile not done do\n    for n=1,size do\n        for m=1,size-1 do\n            if not tryForwards() then\n                done = true\n                break\n            end\n        end\n        if done then\n            break\n        end\n        if n<size then\n            if math.fmod(n + alternate,2) == 0 then\n                turnLeft()\n                if not tryForwards() then\n                    done = true\n                    break\n                end\n                turnLeft()\n            else\n                turnRight()\n                if not tryForwards() then\n                    done = true\n                    break\n                end\n                turnRight()\n            end\n        end\n    end\n    if done then\n        break\n    end\n\n    if size > 1 then\n        if math.fmod(size,2) == 0 then\n            turnRight()\n        else\n            if alternate == 0 then\n                turnLeft()\n            else\n                turnRight()\n            end\n            alternate = 1 - alternate\n        end\n    end\n\n    if not tryDown() then\n        done = true\n        break\n    end\nend\n\nprint( \"Returning to surface...\" )\n\n-- Return to where we started\ngoTo( 0,0,0,0,-1 )\nunload( false )\ngoTo( 0,0,0,0,1 )\n\n-- Seal the hole\nif reseal then\n    turtle.placeDown()\nend\n\nprint( \"Mined \"..(collected + unloaded)..\" items total.\" )","go.lua":"local tArgs = { ... }\nif #tArgs < 1 then\n    print( \"Usage: go <direction> <distance>\" )\n    return\nend\n\nlocal tHandlers = {\n    [\"fd\"] = turtle.forward,\n    [\"forward\"] = turtle.forward,\n    [\"forwards\"] = turtle.forward,\n    [\"bk\"] = turtle.back,\n    [\"back\"] = turtle.back,\n    [\"up\"] = turtle.up,\n    [\"dn\"] = turtle.down,\n    [\"down\"] = turtle.down,\n    [\"lt\"] = turtle.turnLeft,\n    [\"left\"] = turtle.turnLeft,\n    [\"rt\"] = turtle.turnRight,\n    [\"right\"] = turtle.turnRight,\n}\n\nlocal nArg = 1\nwhile nArg <= #tArgs do\n    local sDirection = tArgs[nArg]\n    local nDistance = 1\n    if nArg < #tArgs then\n        local num = tonumber( tArgs[nArg + 1] )\n        if num then\n            nDistance = num\n            nArg = nArg + 1\n        end\n    end\n    nArg = nArg + 1\n\n    local fnHandler = tHandlers[string.lower(sDirection)]\n    if fnHandler then\n        while nDistance > 0 do\n            if fnHandler() then\n                nDistance = nDistance - 1\n            elseif turtle.getFuelLevel() == 0 then\n                print( \"Out of fuel\" )\n                return\n            else\n                sleep(0.5)\n            end\n        end\n    else\n        print( \"No such direction: \"..sDirection )\n        print( \"Try: forward, back, up, down\" )\n        return\n    end\n\nend","turn.lua":"local tArgs = { ... }\nif #tArgs < 1 then\n    print( \"Usage: turn <direction> <turns>\" )\n    return\nend\n\nlocal tHandlers = {\n    [\"lt\"] = turtle.turnLeft,\n    [\"left\"] = turtle.turnLeft,\n    [\"rt\"] = turtle.turnRight,\n    [\"right\"] = turtle.turnRight,\n}\n\nlocal nArg = 1\nwhile nArg <= #tArgs do\n    local sDirection = tArgs[nArg]\n    local nDistance = 1\n    if nArg < #tArgs then\n        local num = tonumber( tArgs[nArg + 1] )\n        if num then\n            nDistance = num\n            nArg = nArg + 1\n        end\n    end\n    nArg = nArg + 1\n\n    local fnHandler = tHandlers[string.lower(sDirection)]\n    if fnHandler then\n        for n=1,nDistance do\n            fnHandler( nArg )\n        end\n    else\n        print( \"No such direction: \"..sDirection )\n        print( \"Try: left, right\" )\n        return\n    end\nend","unequip.lua":"\nlocal tArgs = { ... }\nlocal function printUsage()\n    print( \"Usage: unequip <side>\" )\nend\n\nif #tArgs ~= 1 then\n    printUsage()\n    return\nend\n\nlocal function unequip( fnEquipFunction )\n    for nSlot=1,16 do\n        local nOldCount = turtle.getItemCount( nSlot )\n        if nOldCount == 0 then\n            turtle.select( nSlot )\n            if fnEquipFunction() then\n                local nNewCount = turtle.getItemCount( nSlot )\n                if nNewCount > 0 then\n                    print( \"Item unequipped\" )\n                    return\n                else\n                    print( \"Nothing to unequip\" )\n                    return\n                end\n            end\n        end\n    end\n    print( \"No space to unequip item\" )\nend\n\nlocal sSide = tArgs[1]\nif sSide == \"left\" then\n    unequip( turtle.equipLeft )\nelseif sSide == \"right\" then\n    unequip( turtle.equipRight )\nelse\n    printUsage()\n    return\nend","equip.lua":"\nlocal tArgs = { ... }\nlocal function printUsage()\n    print( \"Usage: equip <slot> <side>\" )\nend\n\nif #tArgs ~= 2 then\n    printUsage()\n    return\nend\n\nlocal function equip( nSlot, fnEquipFunction )\n    turtle.select( nSlot )\n    local nOldCount = turtle.getItemCount( nSlot )\n    if nOldCount == 0 then\n        print( \"Nothing to equip\" )\n    elseif fnEquipFunction() then\n        local nNewCount = turtle.getItemCount( nSlot )\n        if nNewCount > 0 then\n            print( \"Items swapped\" )\n        else\n            print( \"Item equipped\" )\n        end\n    else\n        print( \"Item not equippable\" )\n    end\nend\n\nlocal nSlot = tonumber( tArgs[1] )\nlocal sSide = tArgs[2]\nif sSide == \"left\" then\n    equip( nSlot, turtle.equipLeft )\nelseif sSide == \"right\" then\n    equip( nSlot, turtle.equipRight )\nelse\n    printUsage()\n    return\nend","craft.lua":"\nif not turtle.craft then\n    print( \"Requires a Crafty Turtle\" )\n    return\nend\n\nlocal tArgs = { ... }\nlocal nLimit = nil\nif #tArgs < 1 then\n    print( \"Usage: craft [number]\" )\n    return\nelse\n    nLimit = tonumber( tArgs[1] )\nend\n\nlocal nCrafted = 0\nlocal nOldCount = turtle.getItemCount( turtle.getSelectedSlot() )\nif turtle.craft( nLimit ) then\n    local nNewCount = turtle.getItemCount( turtle.getSelectedSlot() )\n    if nOldCount <= nLimit then\n        nCrafted = nNewCount\n    else\n        nCrafted = nOldCount - nNewCount\n    end\nend\n\nif nCrafted > 1 then\n    print( nCrafted..\" items crafted\" )\nelseif nCrafted == 1 then\n    print( \"1 item crafted\" )\nelse\n    print( \"No items crafted\" )\nend"},"time.lua":"local nTime = os.time()\nlocal nDay = os.day()\nprint( \"The time is \"..textutils.formatTime( nTime, false )..\" on Day \"..nDay )","eject.lua":"\n-- Get arguments\nlocal tArgs = { ... }\nif #tArgs == 0 then\n    print( \"Usage: eject <drive>\" )\n    return\nend\n\nlocal sDrive = tArgs[1]\n\n-- Check the disk exists\nlocal bPresent = disk.isPresent( sDrive )\nif not bPresent then\n    print( \"Nothing in \"..sDrive..\" drive\" )\n    return\nend\n\ndisk.eject( sDrive )","edit.lua":"-- Get file to edit\nlocal tArgs = { ... }\nif #tArgs == 0 then\n    print( \"Usage: edit <path>\" )\n    return\nend\n\n-- Error checking\nlocal sPath = shell.resolve( tArgs[1] )\nlocal bReadOnly = fs.isReadOnly( sPath )\nif fs.exists( sPath ) and fs.isDir( sPath ) then\n    print( \"Cannot edit a directory.\" )\n    return\nend\n\n-- Create .lua files by default\nif not fs.exists( sPath ) and not string.find( sPath, \"%.\" ) then\n    local sExtension = settings.get(\"edit.default_extension\", \"\" )\n    if sExtension ~= \"\" and type( sExtension ) == \"string\" then\n        sPath = sPath .. \".\" .. sExtension\n    end\nend\n\nlocal x,y = 1,1\nlocal w,h = term.getSize()\nlocal scrollX, scrollY = 0,0\n\nlocal tLines = {}\nlocal bRunning = true\n\n-- Colours\nlocal highlightColour, keywordColour, commentColour, textColour, bgColour, stringColour\nif term.isColour() then\n    bgColour = colours.black\n    textColour = colours.white\n    highlightColour = colours.yellow\n    keywordColour = colours.yellow\n    commentColour = colours.green\n    stringColour = colours.red\nelse\n    bgColour = colours.black\n    textColour = colours.white\n    highlightColour = colours.white\n    keywordColour = colours.white\n    commentColour = colours.white\n    stringColour = colours.white\nend\n\n-- Menus\nlocal bMenu = false\nlocal nMenuItem = 1\nlocal tMenuItems = {}\nif not bReadOnly then\n    table.insert( tMenuItems, \"Save\" )\nend\nif shell.openTab then\n    table.insert( tMenuItems, \"Run\" )\nend\nif peripheral.find( \"printer\" ) then\n    table.insert( tMenuItems, \"Print\" )\nend\ntable.insert( tMenuItems, \"Exit\" )\n\nlocal sStatus = \"Press Ctrl to access menu\"\nif string.len( sStatus ) > w - 5 then\n    sStatus = \"Press Ctrl for menu\"\nend\n\nlocal function load( _sPath )\n    tLines = {}\n    if fs.exists( _sPath ) then\n        local file = io.open( _sPath, \"r\" )\n        local sLine = file:read()\n        while sLine do\n            table.insert( tLines, sLine )\n            sLine = file:read()\n        end\n        file:close()\n    end\n\n    if #tLines == 0 then\n        table.insert( tLines, \"\" )\n    end\nend\n\nlocal function save( _sPath )\n    -- Create intervening folder\n    local sDir = _sPath:sub(1, _sPath:len() - fs.getName(_sPath):len() )\n    if not fs.exists( sDir ) then\n        fs.makeDir( sDir )\n    end\n\n    -- Save\n    local file, fileerr\n    local function innerSave()\n        file, fileerr = fs.open( _sPath, \"w\" )\n        if file then\n            for n, sLine in ipairs( tLines ) do\n                file.write( sLine .. \"\\n\" )\n            end\n        else\n            error( \"Failed to open \".._sPath )\n        end\n    end\n\n    local ok, err = pcall( innerSave )\n    if file then\n        file.close()\n    end\n    return ok, err, fileerr\nend\n\nlocal tKeywords = {\n    [\"and\"] = true,\n    [\"break\"] = true,\n    [\"do\"] = true,\n    [\"else\"] = true,\n    [\"elseif\"] = true,\n    [\"end\"] = true,\n    [\"false\"] = true,\n    [\"for\"] = true,\n    [\"function\"] = true,\n    [\"if\"] = true,\n    [\"in\"] = true,\n    [\"local\"] = true,\n    [\"nil\"] = true,\n    [\"not\"] = true,\n    [\"or\"] = true,\n    [\"repeat\"] = true,\n    [\"return\"] = true,\n    [\"then\"] = true,\n    [\"true\"] = true,\n    [\"until\"]= true,\n    [\"while\"] = true,\n}\n\nlocal function tryWrite( sLine, regex, colour )\n    local match = string.match( sLine, regex )\n    if match then\n        if type(colour) == \"number\" then\n            term.setTextColour( colour )\n        else\n            term.setTextColour( colour(match) )\n        end\n        term.write( match )\n        term.setTextColour( textColour )\n        return string.sub( sLine, string.len(match) + 1 )\n    end\n    return nil\nend\n\nlocal function writeHighlighted( sLine )\n    while string.len(sLine) > 0 do\n        sLine =\n            tryWrite( sLine, \"^%-%-%[%[.-%]%]\", commentColour ) or\n            tryWrite( sLine, \"^%-%-.*\", commentColour ) or\n            tryWrite( sLine, \"^\\\"\\\"\", stringColour ) or\n            tryWrite( sLine, \"^\\\".-[^\\\\]\\\"\", stringColour ) or\n            tryWrite( sLine, \"^\\'\\'\", stringColour ) or\n            tryWrite( sLine, \"^\\'.-[^\\\\]\\'\", stringColour ) or\n            tryWrite( sLine, \"^%[%[.-%]%]\", stringColour ) or\n            tryWrite( sLine, \"^[%w_]+\", function( match )\n                if tKeywords[ match ] then\n                    return keywordColour\n                end\n                return textColour\n            end ) or\n            tryWrite( sLine, \"^[^%w_]\", textColour )\n    end\nend\n\nlocal tCompletions\nlocal nCompletion\n\nlocal tCompleteEnv = _ENV\nlocal function complete( sLine )\n    if settings.get( \"edit.autocomplete\" ) then\n        local nStartPos = string.find( sLine, \"[a-zA-Z0-9_%.:]+$\" )\n        if nStartPos then\n            sLine = string.sub( sLine, nStartPos )\n        end\n        if #sLine > 0 then\n            return textutils.complete( sLine, tCompleteEnv )\n        end\n    end\n    return nil\nend\n\nlocal function recomplete()\n    local sLine = tLines[y]\n    if not bMenu and not bReadOnly and x == string.len(sLine) + 1 then\n        tCompletions = complete( sLine )\n        if tCompletions and #tCompletions > 0 then\n            nCompletion = 1\n        else\n            nCompletion = nil\n        end\n    else\n        tCompletions = nil\n        nCompletion = nil\n    end\nend\n\nlocal function writeCompletion( sLine )\n    if nCompletion then\n        local sCompletion = tCompletions[ nCompletion ]\n        term.setTextColor( colours.white )\n        term.setBackgroundColor( colours.grey )\n        term.write( sCompletion )\n        term.setTextColor( textColour )\n        term.setBackgroundColor( bgColour )\n    end\nend\n\nlocal function redrawText()\n    local cursorX, cursorY = x, y\n    for y=1,h-1 do\n        term.setCursorPos( 1 - scrollX, y )\n        term.clearLine()\n\n        local sLine = tLines[ y + scrollY ]\n        if sLine ~= nil then\n            writeHighlighted( sLine )\n            if cursorY == y and cursorX == #sLine + 1 then\n                writeCompletion()\n            end\n        end\n    end\n    term.setCursorPos( x - scrollX, y - scrollY )\nend\n\nlocal function redrawLine(_nY)\n    local sLine = tLines[_nY]\n    if sLine then\n        term.setCursorPos( 1 - scrollX, _nY - scrollY )\n        term.clearLine()\n        writeHighlighted( sLine )\n        if _nY == y and x == #sLine + 1 then\n            writeCompletion()\n        end\n        term.setCursorPos( x - scrollX, _nY - scrollY )\n    end\nend\n\nlocal function redrawMenu()\n    -- Clear line\n    term.setCursorPos( 1, h )\n    term.clearLine()\n\n    -- Draw line numbers\n    term.setCursorPos( w - string.len( \"Ln \"..y ) + 1, h )\n    term.setTextColour( highlightColour )\n    term.write( \"Ln \" )\n    term.setTextColour( textColour )\n    term.write( y )\n\n    term.setCursorPos( 1, h )\n    if bMenu then\n        -- Draw menu\n        term.setTextColour( textColour )\n        for nItem,sItem in pairs( tMenuItems ) do\n            if nItem == nMenuItem then\n                term.setTextColour( highlightColour )\n                term.write( \"[\" )\n                term.setTextColour( textColour )\n                term.write( sItem )\n                term.setTextColour( highlightColour )\n                term.write( \"]\" )\n                term.setTextColour( textColour )\n            else\n                term.write( \" \"..sItem..\" \" )\n            end\n        end\n    else\n        -- Draw status\n        term.setTextColour( highlightColour )\n        term.write( sStatus )\n        term.setTextColour( textColour )\n    end\n\n    -- Reset cursor\n    term.setCursorPos( x - scrollX, y - scrollY )\nend\n\nlocal tMenuFuncs = {\n    Save = function()\n        if bReadOnly then\n            sStatus = \"Access denied\"\n        else\n            local ok, err, fileerr  = save( sPath )\n            if ok then\n                sStatus=\"Saved to \"..sPath\n            else\n                if fileerr then\n                    sStatus=\"Error saving to \"..fileerr\n                else\n                    sStatus=\"Error saving to \"..sPath\n                end\n            end\n        end\n        redrawMenu()\n    end,\n    Print = function()\n        local printer = peripheral.find( \"printer\" )\n        if not printer then\n            sStatus = \"No printer attached\"\n            return\n        end\n\n        local nPage = 0\n        local sName = fs.getName( sPath )\n        if printer.getInkLevel() < 1 then\n            sStatus = \"Printer out of ink\"\n            return\n        elseif printer.getPaperLevel() < 1 then\n            sStatus = \"Printer out of paper\"\n            return\n        end\n\n        local screenTerminal = term.current()\n        local printerTerminal = {\n            getCursorPos = printer.getCursorPos,\n            setCursorPos = printer.setCursorPos,\n            getSize = printer.getPageSize,\n            write = printer.write,\n        }\n        printerTerminal.scroll = function()\n            if nPage == 1 then\n                printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\n            end\n\n            while not printer.newPage()    do\n                if printer.getInkLevel() < 1 then\n                    sStatus = \"Printer out of ink, please refill\"\n                elseif printer.getPaperLevel() < 1 then\n                    sStatus = \"Printer out of paper, please refill\"\n                else\n                    sStatus = \"Printer output tray full, please empty\"\n                end\n\n                term.redirect( screenTerminal )\n                redrawMenu()\n                term.redirect( printerTerminal )\n\n                local timer = os.startTimer(0.5)\n                sleep(0.5)\n            end\n\n            nPage = nPage + 1\n            if nPage == 1 then\n                printer.setPageTitle( sName )\n            else\n                printer.setPageTitle( sName..\" (page \"..nPage..\")\" )\n            end\n        end\n\n        bMenu = false\n        term.redirect( printerTerminal )\n        local ok, error = pcall( function()\n            term.scroll()\n            for n, sLine in ipairs( tLines ) do\n                print( sLine )\n            end\n        end )\n        term.redirect( screenTerminal )\n        if not ok then\n            print( error )\n        end\n\n        while not printer.endPage() do\n            sStatus = \"Printer output tray full, please empty\"\n            redrawMenu()\n            sleep( 0.5 )\n        end\n        bMenu = true\n\n        if nPage > 1 then\n            sStatus = \"Printed \"..nPage..\" Pages\"\n        else\n            sStatus = \"Printed 1 Page\"\n        end\n        redrawMenu()\n    end,\n    Exit = function()\n        bRunning = false\n    end,\n    Run = function()\n        local sTempPath = \"/.temp\"\n        local ok, err = save( sTempPath )\n        if ok then\n            local nTask = shell.openTab( sTempPath )\n            if nTask then\n                shell.switchTab( nTask )\n            else\n                sStatus=\"Error starting Task\"\n            end\n            fs.delete( sTempPath )\n        else\n            sStatus=\"Error saving to \"..sTempPath\n        end\n        redrawMenu()\n    end\n}\n\nlocal function doMenuItem( _n )\n    tMenuFuncs[tMenuItems[_n]]()\n    if bMenu then\n        bMenu = false\n        term.setCursorBlink( true )\n    end\n    redrawMenu()\nend\n\nlocal function setCursor( newX, newY )\n    local oldX, oldY = x, y\n    x, y = newX, newY\n    local screenX = x - scrollX\n    local screenY = y - scrollY\n\n    local bRedraw = false\n    if screenX < 1 then\n        scrollX = x - 1\n        screenX = 1\n        bRedraw = true\n    elseif screenX > w then\n        scrollX = x - w\n        screenX = w\n        bRedraw = true\n    end\n\n    if screenY < 1 then\n        scrollY = y - 1\n        screenY = 1\n        bRedraw = true\n    elseif screenY > h-1 then\n        scrollY = y - (h-1)\n        screenY = h-1\n        bRedraw = true\n    end\n\n    recomplete()\n    if bRedraw then\n        redrawText()\n    elseif y ~= oldY then\n        redrawLine( oldY )\n        redrawLine( y )\n    else\n        redrawLine( y )\n    end\n    term.setCursorPos( screenX, screenY )\n\n    redrawMenu()\nend\n\n-- Actual program functionality begins\nload(sPath)\n\nterm.setBackgroundColour( bgColour )\nterm.clear()\nterm.setCursorPos(x,y)\nterm.setCursorBlink( true )\n\nrecomplete()\nredrawText()\nredrawMenu()\n\nlocal function acceptCompletion()\n    if nCompletion then\n        -- Append the completion\n        local sCompletion = tCompletions[ nCompletion ]\n        tLines[y] = tLines[y] .. sCompletion\n        setCursor( x + string.len( sCompletion ), y )\n    end\nend\n\n-- Handle input\nwhile bRunning do\n    local sEvent, param, param2, param3 = os.pullEvent()\n    if sEvent == \"key\" then\n        local oldX, oldY = x, y\n        if param == keys.up then\n            -- Up\n            if not bMenu then\n                if nCompletion then\n                    -- Cycle completions\n                    nCompletion = nCompletion - 1\n                    if nCompletion < 1 then\n                        nCompletion = #tCompletions\n                    end\n                    redrawLine(y)\n\n                elseif y > 1 then\n                    -- Move cursor up\n                    setCursor(\n                        math.min( x, string.len( tLines[y - 1] ) + 1 ),\n                        y - 1\n                    )\n                end\n            end\n\n        elseif param == keys.down then\n            -- Down\n            if not bMenu then\n                -- Move cursor down\n                if nCompletion then\n                    -- Cycle completions\n                    nCompletion = nCompletion + 1\n                    if nCompletion > #tCompletions then\n                        nCompletion = 1\n                    end\n                    redrawLine(y)\n\n                elseif y < #tLines then\n                    -- Move cursor down\n                    setCursor(\n                        math.min( x, string.len( tLines[y + 1] ) + 1 ),\n                        y + 1\n                    )\n                end\n            end\n\n        elseif param == keys.tab then\n            -- Tab\n            if not bMenu and not bReadOnly then\n                if nCompletion and x == string.len(tLines[y]) + 1 then\n                    -- Accept autocomplete\n                    acceptCompletion()\n                else\n                    -- Indent line\n                    local sLine = tLines[y]\n                    tLines[y] = string.sub(sLine,1,x-1) .. \"    \" .. string.sub(sLine,x)\n                    setCursor( x + 4, y )\n                end\n            end\n\n        elseif param == keys.pageUp then\n            -- Page Up\n            if not bMenu then\n                -- Move up a page\n                local newY\n                if y - (h - 1) >= 1 then\n                    newY = y - (h - 1)\n                else\n                    newY = 1\n                end\n                setCursor(\n                    math.min( x, string.len( tLines[newY] ) + 1 ),\n                    newY\n                )\n            end\n\n        elseif param == keys.pageDown then\n            -- Page Down\n            if not bMenu then\n                -- Move down a page\n                local newY\n                if y + (h - 1) <= #tLines then\n                    newY = y + (h - 1)\n                else\n                    newY = #tLines\n                end\n                local newX = math.min( x, string.len( tLines[newY] ) + 1 )\n                setCursor( newX, newY )\n            end\n\n        elseif param == keys.home then\n            -- Home\n            if not bMenu then\n                -- Move cursor to the beginning\n                if x > 1 then\n                    setCursor(1,y)\n                end\n            end\n\n        elseif param == keys[\"end\"] then\n            -- End\n            if not bMenu then\n                -- Move cursor to the end\n                local nLimit = string.len( tLines[y] ) + 1\n                if x < nLimit then\n                    setCursor( nLimit, y )\n                end\n            end\n\n        elseif param == keys.left then\n            -- Left\n            if not bMenu then\n                if x > 1 then\n                    -- Move cursor left\n                    setCursor( x - 1, y )\n                elseif x==1 and y>1 then\n                    setCursor( string.len( tLines[y-1] ) + 1, y - 1 )\n                end\n            else\n                -- Move menu left\n                nMenuItem = nMenuItem - 1\n                if nMenuItem < 1 then\n                    nMenuItem = #tMenuItems\n                end\n                redrawMenu()\n            end\n\n        elseif param == keys.right then\n            -- Right\n            if not bMenu then\n                local nLimit = string.len( tLines[y] ) + 1\n                if x < nLimit then\n                    -- Move cursor right\n                    setCursor( x + 1, y )\n                elseif nCompletion and x == string.len(tLines[y]) + 1 then\n                    -- Accept autocomplete\n                    acceptCompletion()\n                elseif x==nLimit and y<#tLines then\n                    -- Go to next line\n                    setCursor( 1, y + 1 )\n                end\n            else\n                -- Move menu right\n                nMenuItem = nMenuItem + 1\n                if nMenuItem > #tMenuItems then\n                    nMenuItem = 1\n                end\n                redrawMenu()\n            end\n\n        elseif param == keys.delete then\n            -- Delete\n            if not bMenu and not bReadOnly then\n                local nLimit = string.len( tLines[y] ) + 1\n                if x < nLimit then\n                    local sLine = tLines[y]\n                    tLines[y] = string.sub(sLine,1,x-1) .. string.sub(sLine,x+1)\n                    recomplete()\n                    redrawLine(y)\n                elseif y<#tLines then\n                    tLines[y] = tLines[y] .. tLines[y+1]\n                    table.remove( tLines, y+1 )\n                    recomplete()\n                    redrawText()\n                end\n            end\n\n        elseif param == keys.backspace then\n            -- Backspace\n            if not bMenu and not bReadOnly then\n                if x > 1 then\n                    -- Remove character\n                    local sLine = tLines[y]\n                    if x > 4 and string.sub(sLine,x-4,x-1) == \"    \" and not string.sub(sLine, 1, x - 1):find(\"%S\") then\n                        tLines[y] = string.sub(sLine,1,x-5) .. string.sub(sLine,x)\n                        setCursor( x - 4, y )\n                    else\n                        tLines[y] = string.sub(sLine,1,x-2) .. string.sub(sLine,x)\n                        setCursor( x - 1, y )\n                    end\n                elseif y > 1 then\n                    -- Remove newline\n                    local sPrevLen = string.len( tLines[y-1] )\n                    tLines[y-1] = tLines[y-1] .. tLines[y]\n                    table.remove( tLines, y )\n                    setCursor( sPrevLen + 1, y - 1 )\n                    redrawText()\n                end\n            end\n\n        elseif param == keys.enter then\n            -- Enter\n            if not bMenu and not bReadOnly then\n                -- Newline\n                local sLine = tLines[y]\n                local _,spaces=string.find(sLine,\"^[ ]+\")\n                if not spaces then\n                    spaces=0\n                end\n                tLines[y] = string.sub(sLine,1,x-1)\n                table.insert( tLines, y+1, string.rep(' ',spaces)..string.sub(sLine,x) )\n                setCursor( spaces + 1, y + 1 )\n                redrawText()\n\n            elseif bMenu then\n                -- Menu selection\n                doMenuItem( nMenuItem )\n\n            end\n\n        elseif param == keys.leftCtrl or param == keys.rightCtrl or param == keys.rightAlt then\n            -- Menu toggle\n            bMenu = not bMenu\n            if bMenu then\n                term.setCursorBlink( false )\n            else\n                term.setCursorBlink( true )\n            end\n            redrawMenu()\n\n        end\n\n    elseif sEvent == \"char\" then\n        if not bMenu and not bReadOnly then\n            -- Input text\n            local sLine = tLines[y]\n            tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\n            setCursor( x + 1, y )\n\n        elseif bMenu then\n            -- Select menu items\n            for n,sMenuItem in ipairs( tMenuItems ) do\n                if string.lower(string.sub(sMenuItem,1,1)) == string.lower(param) then\n                    doMenuItem( n )\n                    break\n                end\n            end\n        end\n\n    elseif sEvent == \"paste\" then\n        if not bReadOnly then\n            -- Close menu if open\n            if bMenu then\n                bMenu = false\n                term.setCursorBlink( true )\n                redrawMenu()\n            end\n            -- Input text\n            local sLine = tLines[y]\n            tLines[y] = string.sub(sLine,1,x-1) .. param .. string.sub(sLine,x)\n            setCursor( x + string.len( param ), y )\n        end\n\n    elseif sEvent == \"mouse_click\" then\n        if not bMenu then\n            if param == 1 then\n                -- Left click\n                local cx,cy = param2, param3\n                if cy < h then\n                    local newY = math.min( math.max( scrollY + cy, 1 ), #tLines )\n                    local newX = math.min( math.max( scrollX + cx, 1 ), string.len( tLines[newY] ) + 1 )\n                    setCursor( newX, newY )\n                end\n            end\n        end\n\n    elseif sEvent == \"mouse_scroll\" then\n        if not bMenu then\n            if param == -1 then\n                -- Scroll up\n                if scrollY > 0 then\n                    -- Move cursor up\n                    scrollY = scrollY - 1\n                    redrawText()\n                end\n\n            elseif param == 1 then\n                -- Scroll down\n                local nMaxScroll = #tLines - (h-1)\n                if scrollY < nMaxScroll then\n                    -- Move cursor down\n                    scrollY = scrollY + 1\n                    redrawText()\n                end\n\n            end\n        end\n\n    elseif sEvent == \"term_resize\" then\n        w,h = term.getSize()\n        setCursor( x, y )\n        redrawMenu()\n        redrawText()\n\n    end\nend\n\n-- Cleanup\nterm.clear()\nterm.setCursorBlink( false )\nterm.setCursorPos( 1, 1 )","shutdown.lua":"if term.isColour() then\n    term.setTextColour( colours.yellow )\nend\nprint( \"Goodbye\" )\nterm.setTextColour( colours.white )\n\nsleep( 1 )\nos.shutdown()","rednet":{"chat.lua":"\nlocal tArgs = { ... }\n\nlocal function printUsage()\n    print( \"Usages:\" )\n    print( \"chat host <hostname>\" )\n    print( \"chat join <hostname> <nickname>\" )\nend\n\nlocal sOpenedModem = nil\nlocal function openModem()\n    for n,sModem in ipairs( peripheral.getNames() ) do\n        if peripheral.getType( sModem ) == \"modem\" then\n            if not rednet.isOpen( sModem ) then\n                rednet.open( sModem )\n                sOpenedModem = sModem\n            end\n            return true\n        end\n    end\n    print( \"No modems found.\" )\n    return false\nend\n\nlocal function closeModem()\n    if sOpenedModem ~= nil then\n        rednet.close( sOpenedModem )\n        sOpenedModem = nil\n    end\nend\n\n-- Colours\nlocal highlightColour, textColour\nif term.isColour() then\n    textColour = colours.white\n    highlightColour = colours.yellow\nelse\n    textColour = colours.white\n    highlightColour = colours.white\nend\n\nlocal sCommand = tArgs[1]\nif sCommand == \"host\" then\n    -- \"chat host\"\n    -- Get hostname\n    local sHostname = tArgs[2]\n    if sHostname == nil then\n        printUsage()\n        return\n    end\n\n    -- Host server\n    if not openModem() then\n        return\n    end\n    rednet.host( \"chat\", sHostname )\n    print( \"0 users connected.\" )\n\n    local tUsers = {}\n    local nUsers = 0\n    local function send( sText, nUserID )\n        if nUserID then\n            local tUser = tUsers[ nUserID ]\n            if tUser then\n                rednet.send( tUser.nID, {\n                    sType = \"text\",\n                    nUserID = nUserID,\n                    sText = sText,\n                }, \"chat\" )\n            end\n        else\n            for nUserID, tUser in pairs( tUsers ) do\n                rednet.send( tUser.nID, {\n                    sType = \"text\",\n                    nUserID = nUserID,\n                    sText = sText,\n                }, \"chat\" )\n            end\n        end\n    end\n\n    -- Setup ping pong\n    local tPingPongTimer = {}\n    local function ping( nUserID )\n        local tUser = tUsers[ nUserID ]\n        rednet.send( tUser.nID, {\n            sType = \"ping to client\",\n            nUserID = nUserID,\n        }, \"chat\" )\n\n        local timer = os.startTimer( 15 )\n        tUser.bPingPonged = false\n        tPingPongTimer[ timer ] = nUserID\n    end\n\n    local function printUsers()\n        local x,y = term.getCursorPos()\n        term.setCursorPos( 1, y - 1 )\n        term.clearLine()\n        if nUsers == 1 then\n            print( nUsers .. \" user connected.\" )\n        else\n            print( nUsers .. \" users connected.\" )\n        end\n    end\n\n    -- Handle messages\n    local ok, error = pcall( function()\n        parallel.waitForAny( function()\n            while true do\n                local sEvent, timer = os.pullEvent( \"timer\" )\n                local nUserID = tPingPongTimer[ timer ]\n                if nUserID and tUsers[ nUserID ] then\n                    local tUser = tUsers[ nUserID ]\n                    if tUser then\n                        if not tUser.bPingPonged then\n                            send( \"* \"..tUser.sUsername..\" has timed out\" )\n                            tUsers[ nUserID ] = nil\n                            nUsers = nUsers - 1\n                            printUsers()\n                        else\n                            ping( nUserID )\n                        end\n                    end\n                end\n            end\n        end,\n        function()\n            while true do\n                local tCommands\n                tCommands = {\n                    [\"me\"] = function( tUser, sContent )\n                        if string.len(sContent) > 0 then\n                            send( \"* \"..tUser.sUsername..\" \"..sContent )\n                        else\n                            send( \"* Usage: /me [words]\", tUser.nUserID )\n                        end\n                    end,\n                    [\"nick\"] = function( tUser, sContent )\n                        if string.len(sContent) > 0 then\n                            local sOldName = tUser.sUsername\n                            tUser.sUsername = sContent\n                            send( \"* \"..sOldName..\" is now known as \"..tUser.sUsername )\n                        else\n                            send( \"* Usage: /nick [nickname]\", tUser.nUserID )\n                        end\n                    end,\n                    [\"users\"] = function( tUser, sContent )\n                        send( \"* Connected Users:\", tUser.nUserID )\n                        local sUsers = \"*\"\n                        for nUserID, tUser in pairs( tUsers ) do\n                            sUsers = sUsers .. \" \" .. tUser.sUsername\n                        end\n                        send( sUsers, tUser.nUserID )\n                    end,\n                    [\"help\"] = function( tUser, sContent )\n                        send( \"* Available commands:\", tUser.nUserID )\n                        local sCommands = \"*\"\n                        for sCommand, fnCommand in pairs( tCommands ) do\n                            sCommands = sCommands .. \" /\" .. sCommand\n                        end\n                        send( sCommands..\" /logout\", tUser.nUserID )\n                    end,\n                }\n\n                local nSenderID, tMessage = rednet.receive( \"chat\" )\n                if type( tMessage ) == \"table\" then\n                    if tMessage.sType == \"login\" then\n                        -- Login from new client\n                        local nUserID = tMessage.nUserID\n                        local sUsername = tMessage.sUsername\n                        if nUserID and sUsername then\n                            tUsers[ nUserID ] = {\n                                nID = nSenderID,\n                                nUserID = nUserID,\n                                sUsername = sUsername,\n                            }\n                            nUsers = nUsers + 1\n                            printUsers()\n                            send( \"* \"..sUsername..\" has joined the chat\" )\n                            ping( nUserID )\n                        end\n\n                    else\n                        -- Something else from existing client\n                        local nUserID = tMessage.nUserID\n                        local tUser = tUsers[ nUserID ]\n                        if tUser and tUser.nID == nSenderID then\n                            if tMessage.sType == \"logout\" then\n                                send( \"* \"..tUser.sUsername..\" has left the chat\" )\n                                tUsers[ nUserID ] = nil\n                                nUsers = nUsers - 1\n                                printUsers()\n\n                            elseif tMessage.sType == \"chat\" then\n                                local sMessage = tMessage.sText\n                                if sMessage then\n                                    local sCommand = string.match( sMessage, \"^/([a-z]+)\" )\n                                    if sCommand then\n                                        local fnCommand = tCommands[ sCommand ]\n                                        if fnCommand then\n                                            local sContent = string.sub( sMessage, string.len(sCommand)+3 )\n                                            fnCommand( tUser, sContent )\n                                        else\n                                            send( \"* Unrecognised command: /\"..sCommand, tUser.nUserID )\n                                        end\n                                    else\n                                        send( \"<\"..tUser.sUsername..\"> \"..tMessage.sText )\n                                    end\n                                end\n\n                            elseif tMessage.sType == \"ping to server\" then\n                                rednet.send( tUser.nID, {\n                                    sType = \"pong to client\",\n                                    nUserID = nUserID,\n                                }, \"chat\" )\n\n                            elseif tMessage.sType == \"pong to server\" then\n                                tUser.bPingPonged = true\n\n                            end\n                        end\n                    end\n                 end\n            end\n        end )\n    end )\n    if not ok then\n        printError( error )\n    end\n\n    -- Unhost server\n    for nUserID, tUser in pairs( tUsers ) do\n        rednet.send( tUser.nID, {\n            sType = \"kick\",\n            nUserID = nUserID,\n        }, \"chat\" )\n    end\n    rednet.unhost( \"chat\" )\n    closeModem()\n\nelseif sCommand == \"join\" then\n    -- \"chat join\"\n    -- Get hostname and username\n    local sHostname = tArgs[2]\n    local sUsername = tArgs[3]\n    if sHostname == nil or sUsername == nil then\n        printUsage()\n        return\n    end\n\n    -- Connect\n    if not openModem() then\n        return\n    end\n    write( \"Looking up \" .. sHostname .. \"... \" )\n    local nHostID = rednet.lookup( \"chat\", sHostname )\n    if nHostID == nil then\n        print( \"Failed.\" )\n        return\n    else\n        print( \"Success.\" )\n    end\n\n    -- Login\n    local nUserID = math.random( 1, 2147483647 )\n    rednet.send( nHostID, {\n        sType = \"login\",\n        nUserID = nUserID,\n        sUsername = sUsername,\n    }, \"chat\" )\n\n    -- Setup ping pong\n    local bPingPonged = true\n    local pingPongTimer = os.startTimer( 0 )\n\n    local function ping()\n        rednet.send( nHostID, {\n            sType = \"ping to server\",\n            nUserID = nUserID,\n        }, \"chat\" )\n        bPingPonged = false\n        pingPongTimer = os.startTimer( 15 )\n    end\n\n    -- Handle messages\n    local w,h = term.getSize()\n    local parentTerm = term.current()\n    local titleWindow = window.create( parentTerm, 1, 1, w, 1, true )\n    local historyWindow = window.create( parentTerm, 1, 2, w, h-2, true )\n    local promptWindow = window.create( parentTerm, 1, h, w, 1, true )\n    historyWindow.setCursorPos( 1, h-2 )\n\n    term.clear()\n    term.setTextColour( textColour )\n    term.redirect( promptWindow )\n    promptWindow.restoreCursor()\n\n    local function drawTitle()\n        local x,y = titleWindow.getCursorPos()\n        local w,h = titleWindow.getSize()\n        local sTitle = sUsername..\" on \"..sHostname\n        titleWindow.setTextColour( highlightColour )\n        titleWindow.setCursorPos( math.floor( w/2 - string.len(sTitle)/2 ), 1 )\n        titleWindow.clearLine()\n        titleWindow.write( sTitle )\n        promptWindow.restoreCursor()\n    end\n\n    local function printMessage( sMessage )\n        term.redirect( historyWindow )\n        print()\n        if string.match( sMessage, \"^%*\" ) then\n            -- Information\n            term.setTextColour( highlightColour )\n            write( sMessage )\n            term.setTextColour( textColour )\n        else\n            -- Chat\n            local sUsernameBit = string.match( sMessage, \"^<[^>]*>\" )\n            if sUsernameBit then\n                term.setTextColour( highlightColour )\n                write( sUsernameBit )\n                term.setTextColour( textColour )\n                write( string.sub( sMessage, string.len( sUsernameBit ) + 1 ) )\n            else\n                write( sMessage )\n            end\n        end\n        term.redirect( promptWindow )\n        promptWindow.restoreCursor()\n    end\n\n    drawTitle()\n\n    local ok, error = pcall( function()\n        parallel.waitForAny( function()\n            while true do\n                local sEvent, timer = os.pullEvent()\n                if sEvent == \"timer\" then\n                    if timer == pingPongTimer then\n                        if not bPingPonged then\n                            printMessage( \"Server timeout.\" )\n                            return\n                        else\n                            ping()\n                        end\n                    end\n\n                elseif sEvent == \"term_resize\" then\n                    local w,h = parentTerm.getSize()\n                    titleWindow.reposition( 1, 1, w, 1 )\n                    historyWindow.reposition( 1, 2, w, h-2 )\n                    promptWindow.reposition( 1, h, w, 1 )\n\n                end\n            end\n        end,\n        function()\n            while true do\n                local nSenderID, tMessage = rednet.receive( \"chat\" )\n                if nSenderID == nHostID and type( tMessage ) == \"table\" and tMessage.nUserID == nUserID then\n                    if tMessage.sType == \"text\" then\n                        local sText = tMessage.sText\n                        if sText then\n                            printMessage( sText )\n                        end\n\n                    elseif tMessage.sType == \"ping to client\" then\n                        rednet.send( nSenderID, {\n                            sType = \"pong to server\",\n                            nUserID = nUserID,\n                        }, \"chat\" )\n\n                    elseif tMessage.sType == \"pong to client\" then\n                        bPingPonged = true\n\n                    elseif tMessage.sType == \"kick\" then\n                        return\n\n                    end\n                end\n            end\n        end,\n        function()\n            local tSendHistory = {}\n            while true do\n                promptWindow.setCursorPos( 1,1 )\n                promptWindow.clearLine()\n                promptWindow.setTextColor( highlightColour )\n                promptWindow.write( \": \")\n                promptWindow.setTextColor( textColour )\n\n                local sChat = read( nil, tSendHistory )\n                if string.match( sChat, \"^/logout\" ) then\n                    break\n                else\n                    rednet.send( nHostID, {\n                        sType = \"chat\",\n                        nUserID = nUserID,\n                        sText = sChat,\n                    }, \"chat\" )\n                    table.insert( tSendHistory, sChat )\n                end\n            end\n        end )\n    end )\n\n    -- Close the windows\n    term.redirect( parentTerm )\n\n    -- Print error notice\n    local w,h = term.getSize()\n    term.setCursorPos( 1, h )\n    term.clearLine()\n    term.setCursorBlink( false )\n    if not ok then\n        printError( error )\n    end\n\n    -- Logout\n    rednet.send( nHostID, {\n        sType = \"logout\",\n        nUserID = nUserID,\n    }, \"chat\" )\n    closeModem()\n\n    -- Print disconnection notice\n    print( \"Disconnected.\" )\n\nelse\n    -- \"chat somethingelse\"\n    printUsage()\n\nend","repeat.lua":"\n-- Find modems\nlocal tModems = {}\nfor n,sModem in ipairs( peripheral.getNames() ) do\n    if peripheral.getType( sModem ) == \"modem\" then\n        table.insert( tModems, sModem )\n    end\nend\nif #tModems == 0 then\n    print( \"No modems found.\" )\n    return\nelseif #tModems == 1 then\n    print( \"1 modem found.\" )\nelse\n    print( #tModems .. \" modems found.\" )\nend\n\nlocal function open( nChannel )\n    for n=1,#tModems do\n        local sModem = tModems[n]\n        peripheral.call( sModem, \"open\", nChannel )\n    end\nend\n\nlocal function close( nChannel )\n    for n=1,#tModems do\n        local sModem = tModems[n]\n        peripheral.call( sModem, \"close\", nChannel )\n    end\nend\n\n-- Open channels\nprint( \"0 messages repeated.\" )\nopen( rednet.CHANNEL_REPEAT )\n\n-- Main loop (terminate to break)\nlocal ok, error = pcall( function()\n    local tReceivedMessages = {}\n    local tReceivedMessageTimeouts = {}\n    local nTransmittedMessages = 0\n\n    while true do\n        local sEvent, sModem, nChannel, nReplyChannel, tMessage = os.pullEvent()\n        if sEvent == \"modem_message\" then\n            -- Got a modem message, rebroadcast it if it's a rednet thing\n            if nChannel == rednet.CHANNEL_REPEAT then\n                if type( tMessage ) == \"table\" and tMessage.nMessageID and tMessage.nRecipient and type(tMessage.nRecipient) == \"number\" then\n                    if not tReceivedMessages[ tMessage.nMessageID ] then\n                        -- Ensure we only repeat a message once\n                        tReceivedMessages[ tMessage.nMessageID ] = true\n                        tReceivedMessageTimeouts[ os.startTimer( 30 ) ] = tMessage.nMessageID\n\n                        -- Send on all other open modems, to the target and to other repeaters\n                        for n=1,#tModems do\n                            local sOtherModem = tModems[n]\n                            peripheral.call( sOtherModem, \"transmit\", rednet.CHANNEL_REPEAT, nReplyChannel, tMessage )\n                            peripheral.call( sOtherModem, \"transmit\", tMessage.nRecipient, nReplyChannel, tMessage )\n                        end\n\n                        -- Log the event\n                        nTransmittedMessages = nTransmittedMessages + 1\n                        local x,y = term.getCursorPos()\n                        term.setCursorPos( 1, y - 1 )\n                        term.clearLine()\n                        if nTransmittedMessages == 1 then\n                            print( nTransmittedMessages .. \" message repeated.\" )\n                        else\n                            print( nTransmittedMessages .. \" messages repeated.\" )\n                        end\n                    end\n                end\n            end\n\n        elseif sEvent == \"timer\" then\n            -- Got a timer event, use it to clear the message history\n            local nTimer = sModem\n            local nMessageID = tReceivedMessageTimeouts[ nTimer ]\n            if nMessageID then\n                tReceivedMessageTimeouts[ nTimer ] = nil\n                tReceivedMessages[ nMessageID ] = nil\n            end\n\n        end\n    end\nend )\nif not ok then\n    printError( error )\nend\n\n-- Close channels\nclose( rednet.CHANNEL_REPEAT )"},"fun":{"adventure.lua":"\nlocal tBiomes = {\n    \"in a forest\",\n    \"in a pine forest\",\n    \"knee deep in a swamp\",\n    \"in a mountain range\",\n    \"in a desert\",\n    \"in a grassy plain\",\n    \"in frozen tundra\",\n}\n\nlocal function hasTrees( _nBiome )\n    return _nBiome <= 3\nend\n\nlocal function hasStone( _nBiome )\n    return _nBiome == 4\nend\n\nlocal function hasRivers( _nBiome )\n    return _nBiome ~= 3 and _nBiome ~= 5\nend\n\nlocal items = {\n    [\"no tea\"] = {\n        droppable = false,\n        desc = \"Pull yourself together man.\",\n    },\n    [\"a pig\"] = {\n        heavy = true,\n        creature = true,\n        drops = { \"some pork\" },\n        aliases = { \"pig\" },\n        desc = \"The pig has a square nose.\",\n    },\n    [\"a cow\"] = {\n        heavy = true,\n        creature = true,\n        aliases = { \"cow\" },\n        desc = \"The cow stares at you blankly.\",\n    },\n    [\"a sheep\"] = {\n        heavy = true,\n        creature = true,\n        hitDrops = { \"some wool\" },\n        aliases = { \"sheep\" },\n        desc = \"The sheep is fluffy.\",\n    },\n    [\"a chicken\"] = {\n        heavy = true,\n        creature = true,\n        drops = { \"some chicken\" },\n        aliases = { \"chicken\" },\n        desc = \"The chicken looks delicious.\",\n    },\n    [\"a creeper\"] = {\n        heavy = true,\n        creature = true,\n        monster = true,\n        aliases = { \"creeper\" },\n        desc = \"The creeper needs a hug.\",\n    },\n    [\"a skeleton\"] = {\n        heavy = true,\n        creature = true,\n        monster = true,\n        aliases = { \"skeleton\" },\n        nocturnal = true,\n        desc = \"The head bone's connected to the neck bone, the neck bone's connected to the chest bone, the chest bone's connected to the arm bone, the arm bone's connected to the bow, and the bow is pointed at you.\",\n    },\n    [\"a zombie\"] = {\n        heavy = true,\n        creature = true,\n        monster = true,\n        aliases = { \"zombie\" },\n        nocturnal = true,\n        desc = \"All he wants to do is eat your brains.\",\n    },\n    [\"a spider\"] = {\n        heavy = true,\n        creature = true,\n        monster = true,\n        aliases = { \"spider\" },\n        desc = \"Dozens of eyes stare back at you.\",\n    },\n    [\"a cave entrance\"] = {\n        heavy = true,\n        aliases = { \"cave entance\", \"cave\", \"entrance\" },\n        desc = \"The entrance to the cave is dark, but it looks like you can climb down.\",\n    },\n    [\"an exit to the surface\"] = {\n        heavy = true,\n        aliases = { \"exit to the surface\", \"exit\", \"opening\" },\n        desc = \"You can just see the sky through the opening.\",\n    },\n    [\"a river\"] = {\n        heavy = true,\n        aliases = { \"river\" },\n        desc = \"The river flows majestically towards the horizon. It doesn't do anything else.\",\n    },\n    [\"some wood\"] = {\n        aliases = { \"wood\" },\n        material = true,\n        desc = \"You could easilly craft this wood into planks.\",\n    },\n    [\"some planks\"] = {\n        aliases = { \"planks\", \"wooden planks\", \"wood planks\" },\n        desc = \"You could easilly craft these planks into sticks.\",\n    },\n    [\"some sticks\"] = {\n        aliases = { \"sticks\", \"wooden sticks\", \"wood sticks\" },\n        desc = \"A perfect handle for torches or a pickaxe.\",\n    },\n    [\"a crafting table\"] = {\n        aliases = { \"crafting table\", \"craft table\", \"work bench\", \"workbench\", \"crafting bench\", \"table\", },\n        desc = \"It's a crafting table. I shouldn't tell you this, but these don't actually do anything in this game, you can craft tools whenever you like.\",\n    },\n    [\"a furnace\"] = {\n        aliases = { \"furnace\" },\n        desc = \"It's a furnace. Between you and me, these don't actually do anything in this game.\",\n    },\n    [\"a wooden pickaxe\"] = {\n        aliases = { \"pickaxe\", \"pick\", \"wooden pick\", \"wooden pickaxe\", \"wood pick\", \"wood pickaxe\" },\n        tool = true,\n        toolLevel = 1,\n        toolType = \"pick\",\n        desc = \"The pickaxe looks good for breaking stone and coal.\",\n    },\n    [\"a stone pickaxe\"] = {\n        aliases = { \"pickaxe\", \"pick\", \"stone pick\", \"stone pickaxe\" },\n        tool = true,\n        toolLevel = 2,\n        toolType = \"pick\",\n        desc = \"The pickaxe looks good for breaking iron.\",\n    },\n    [\"an iron pickaxe\"] = {\n        aliases = { \"pickaxe\", \"pick\", \"iron pick\", \"iron pickaxe\" },\n        tool = true,\n        toolLevel = 3,\n        toolType = \"pick\",\n        desc = \"The pickaxe looks strong enough to break diamond.\",\n    },\n    [\"a diamond pickaxe\"] = {\n        aliases = { \"pickaxe\", \"pick\", \"diamond pick\", \"diamond pickaxe\" },\n        tool = true,\n        toolLevel = 4,\n        toolType = \"pick\",\n        desc = \"Best. Pickaxe. Ever.\",\n    },\n    [\"a wooden sword\"] = {\n        aliases = { \"sword\", \"wooden sword\", \"wood sword\" },\n        tool = true,\n        toolLevel = 1,\n        toolType = \"sword\",\n        desc = \"Flimsy, but better than nothing.\",\n    },\n    [\"a stone sword\"] = {\n        aliases = { \"sword\", \"stone sword\" },\n        tool = true,\n        toolLevel = 2,\n        toolType = \"sword\",\n        desc = \"A pretty good sword.\",\n    },\n    [\"an iron sword\"] = {\n        aliases = { \"sword\", \"iron sword\" },\n        tool = true,\n        toolLevel = 3,\n        toolType = \"sword\",\n        desc = \"This sword can slay any enemy.\",\n    },\n    [\"a diamond sword\"] = {\n        aliases = { \"sword\", \"diamond sword\" },\n        tool = true,\n        toolLevel = 4,\n        toolType = \"sword\",\n        desc = \"Best. Sword. Ever.\",\n    },\n    [\"a wooden shovel\"] = {\n        aliases = { \"shovel\", \"wooden shovel\", \"wood shovel\" },\n        tool = true,\n        toolLevel = 1,\n        toolType = \"shovel\",\n        desc = \"Good for digging holes.\",\n    },\n    [\"a stone shovel\"] = {\n        aliases = { \"shovel\", \"stone shovel\" },\n        tool = true,\n        toolLevel = 2,\n        toolType = \"shovel\",\n        desc = \"Good for digging holes.\",\n    },\n    [\"an iron shovel\"] = {\n        aliases = { \"shovel\", \"iron shovel\" },\n        tool = true,\n        toolLevel = 3,\n        toolType = \"shovel\",\n        desc = \"Good for digging holes.\",\n    },\n    [\"a diamond shovel\"] = {\n        aliases = { \"shovel\", \"diamond shovel\" },\n        tool = true,\n        toolLevel = 4,\n        toolType = \"shovel\",\n        desc = \"Good for digging holes.\",\n    },\n    [\"some coal\"] = {\n        aliases = { \"coal\" },\n        ore = true,\n        toolLevel = 1,\n        toolType = \"pick\",\n        desc = \"That coal looks useful for building torches, if only you had a pickaxe to mine it.\",\n    },\n    [\"some dirt\"] = {\n        aliases = { \"dirt\" },\n        material = true,\n        desc = \"Why not build a mud hut?\",\n    },\n    [\"some stone\"] = {\n        aliases = { \"stone\", \"cobblestone\" },\n        material = true,\n        ore = true,\n        infinite = true,\n        toolLevel = 1,\n        toolType = \"pick\",\n        desc = \"Stone is useful for building things, and making stone pickaxes.\",\n    },\n    [\"some iron\"] = {\n        aliases = { \"iron\" },\n        material = true,\n        ore = true,\n        toolLevel = 2,\n        toolType = \"pick\",\n        desc = \"That iron looks mighty strong, you'll need a stone pickaxe to mine it.\",\n    },\n    [\"some diamond\"] = {\n        aliases = { \"diamond\", \"diamonds\" },\n        material = true,\n        ore = true,\n        toolLevel = 3,\n        toolType = \"pick\",\n        desc = \"Sparkly, rare, and impossible to mine without an iron pickaxe.\",\n    },\n    [\"some torches\"] = {\n        aliases = { \"torches\", \"torch\" },\n        desc = \"These won't run out for a while.\",\n    },\n    [\"a torch\"] = {\n        aliases = { \"torch\" },\n        desc = \"Fire, fire, burn so bright, won't you light my cave tonight?\",\n    },\n    [\"some wool\"] = {\n        aliases = { \"wool\" },\n        material = true,\n        desc = \"Soft and good for building.\",\n    },\n    [\"some pork\"] = {\n        aliases = { \"pork\", \"porkchops\" },\n        food = true,\n        desc = \"Delicious and nutricious.\",\n    },\n    [\"some chicken\"] = {\n        aliases = { \"chicken\" },\n        food = true,\n        desc = \"Finger licking good.\",\n    },\n}\n\nlocal tAnimals = {\n    \"a pig\", \"a cow\", \"a sheep\", \"a chicken\",\n}\n\nlocal tMonsters = {\n    \"a creeper\", \"a skeleton\", \"a zombie\", \"a spider\"\n}\n\nlocal tRecipes = {\n    [\"some planks\"] = { \"some wood\" },\n    [\"some sticks\"] = { \"some planks\" },\n    [\"a crafting table\"] = { \"some planks\" },\n    [\"a furnace\"] = { \"some stone\" },\n    [\"some torches\"] = { \"some sticks\", \"some coal\" },\n\n    [\"a wooden pickaxe\"] = { \"some planks\", \"some sticks\" },\n    [\"a stone pickaxe\"] = { \"some stone\", \"some sticks\" },\n    [\"an iron pickaxe\"] = { \"some iron\", \"some sticks\" },\n    [\"a diamond pickaxe\"] = { \"some diamond\", \"some sticks\" },\n\n    [\"a wooden sword\"] = { \"some planks\", \"some sticks\" },\n    [\"a stone sword\"] = { \"some stone\", \"some sticks\" },\n    [\"an iron sword\"] = { \"some iron\", \"some sticks\" },\n    [\"a diamond sword\"] = { \"some diamond\", \"some sticks\" },\n\n    [\"a wooden shovel\"] = { \"some planks\", \"some sticks\" },\n    [\"a stone shovel\"] = { \"some stone\", \"some sticks\" },\n    [\"an iron shovel\"] = { \"some iron\", \"some sticks\" },\n    [\"a diamond shovel\"] = { \"some diamond\", \"some sticks\" },\n}\n\nlocal tGoWest = {\n    \"(life is peaceful there)\",\n    \"(lots of open air)\",\n    \"(to begin life anew)\",\n    \"(this is what we'll do)\",\n    \"(sun in winter time)\",\n    \"(we will do just fine)\",\n    \"(where the skies are blue)\",\n    \"(this and more we'll do)\",\n}\nlocal nGoWest = 0\n\nlocal bRunning = true\nlocal tMap = { { {}, }, }\nlocal x,y,z = 0,0,0\nlocal inventory = {\n    [\"no tea\"] = items[\"no tea\"],\n}\n\nlocal nTurn = 0\nlocal nTimeInRoom = 0\nlocal bInjured = false\n\nlocal tDayCycle = {\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"It is daytime.\",\n    \"The sun is setting.\",\n    \"It is night.\",\n    \"It is night.\",\n    \"It is night.\",\n    \"It is night.\",\n    \"It is night.\",\n    \"The sun is rising.\",\n}\n\nlocal function getTimeOfDay()\n    return math.fmod( math.floor(nTurn/3), #tDayCycle ) + 1\nend\n\nlocal function isSunny()\n    return (getTimeOfDay() < 10)\nend\n\nlocal function getRoom( x, y, z, dontCreate )\n    tMap[x] = tMap[x] or {}\n    tMap[x][y] = tMap[x][y] or {}\n    if not tMap[x][y][z] and dontCreate ~= true then\n         local room = {\n             items = {},\n             exits = {},\n             nMonsters = 0,\n         }\n        tMap[x][y][z] = room\n\n        if y == 0 then\n            -- Room is above ground\n\n            -- Pick biome\n            room.nBiome = math.random( 1, #tBiomes )\n            room.trees = hasTrees( room.nBiome )\n\n            -- Add animals\n            if math.random(1,3) == 1 then\n                for n = 1,math.random(1,2) do\n                    local sAnimal = tAnimals[ math.random( 1, #tAnimals ) ]\n                    room.items[ sAnimal ] = items[ sAnimal ]\n                end\n            end\n\n            -- Add surface ore\n            if math.random(1,5) == 1 or hasStone( room.nBiome ) then\n                room.items[ \"some stone\" ] = items[ \"some stone\" ]\n            end\n            if math.random(1,8) == 1 then\n                room.items[ \"some coal\" ] = items[ \"some coal\" ]\n            end\n            if math.random(1,8) == 1 and hasRivers( room.nBiome ) then\n                room.items[ \"a river\" ] = items[ \"a river\" ]\n            end\n\n            -- Add exits\n            room.exits = {\n                [\"north\"] = true,\n                [\"south\"] = true,\n                [\"east\"] = true,\n                [\"west\"] = true,\n            }\n            if math.random(1,8) == 1 then\n                room.exits[\"down\"] = true\n                room.items[\"a cave entrance\"] = items[\"a cave entrance\"]\n            end\n\n        else\n            -- Room is underground\n            -- Add exits\n            local function tryExit( sDir, sOpp, x, y, z )\n                local adj = getRoom( x, y, z, true )\n                if adj then\n                    if adj.exits[sOpp] then\n                        room.exits[sDir] = true\n                    end\n                else\n                    if math.random(1,3) == 1 then\n                        room.exits[sDir] = true\n                    end\n                end\n            end\n\n            if y == -1 then\n                local above = getRoom( x, y + 1, z )\n                if above.exits[\"down\"] then\n                    room.exits[\"up\"] = true\n                    room.items[\"an exit to the surface\"] = items[\"an exit to the surface\"]\n                end\n            else\n                tryExit( \"up\", \"down\", x, y + 1, z )\n            end\n\n            if y > -3 then\n                tryExit( \"down\", \"up\", x, y - 1, z )\n            end\n\n            tryExit( \"east\", \"west\", x - 1, y, z )\n            tryExit( \"west\", \"east\", x + 1, y, z )\n            tryExit( \"north\", \"south\", x, y, z + 1 )\n            tryExit( \"south\", \"north\", x, y, z - 1 )\n\n            -- Add ores\n            room.items[ \"some stone\" ] = items[ \"some stone\" ]\n            if math.random(1,3) == 1 then\n                room.items[ \"some coal\" ] = items[ \"some coal\" ]\n            end\n            if math.random(1,8) == 1 then\n                room.items[ \"some iron\" ] = items[ \"some iron\" ]\n            end\n            if y == -3 and math.random(1,15) == 1 then\n                room.items[ \"some diamond\" ] = items[ \"some diamond\" ]\n            end\n\n            -- Turn out the lights\n            room.dark = true\n        end\n    end\n    return tMap[x][y][z]\nend\n\nlocal function itemize( t )\n    local item = next( t )\n    if item == nil then\n        return \"nothing\"\n    end\n\n    local text = \"\"\n    while item do\n        text = text .. item\n\n        local nextItem = next( t, item )\n        if nextItem ~= nil then\n            local nextNextItem = next( t, nextItem )\n            if nextNextItem == nil then\n                text = text .. \" and \"\n            else\n                text = text .. \", \"\n            end\n        end\n        item = nextItem\n    end\n    return text\nend\n\nlocal function findItem( _tList, _sQuery )\n    for sItem, tItem in pairs( _tList ) do\n        if sItem == _sQuery then\n            return sItem\n        end\n        if tItem.aliases ~= nil then\n            for n, sAlias in pairs( tItem.aliases ) do\n                if sAlias == _sQuery then\n                    return sItem\n                end\n            end\n        end\n    end\n    return nil\nend\n\nlocal tMatches = {\n    [\"wait\"] = {\n        \"wait\",\n    },\n    [\"look\"] = {\n        \"look at the ([%a ]+)\",\n        \"look at ([%a ]+)\",\n        \"look\",\n        \"inspect ([%a ]+)\",\n        \"inspect the ([%a ]+)\",\n        \"inspect\",\n    },\n    [\"inventory\"] = {\n        \"check self\",\n        \"check inventory\",\n        \"inventory\",\n        \"i\",\n    },\n    [\"go\"] = {\n        \"go (%a+)\",\n        \"travel (%a+)\",\n        \"walk (%a+)\",\n        \"run (%a+)\",\n        \"go\",\n    },\n    [\"dig\"] = {\n        \"dig (%a+) using ([%a ]+)\",\n        \"dig (%a+) with ([%a ]+)\",\n        \"dig (%a+)\",\n        \"dig\",\n    },\n    [\"take\"] = {\n        \"pick up the ([%a ]+)\",\n        \"pick up ([%a ]+)\",\n        \"pickup ([%a ]+)\",\n        \"take the ([%a ]+)\",\n        \"take ([%a ]+)\",\n        \"take\",\n    },\n    [\"drop\"] = {\n        \"put down the ([%a ]+)\",\n        \"put down ([%a ]+)\",\n        \"drop the ([%a ]+)\",\n        \"drop ([%a ]+)\",\n        \"drop\",\n    },\n    [\"place\"] = {\n        \"place the ([%a ]+)\",\n        \"place ([%a ]+)\",\n        \"place\",\n    },\n    [\"cbreak\"] = {\n        \"punch the ([%a ]+)\",\n        \"punch ([%a ]+)\",\n        \"punch\",\n        \"break the ([%a ]+) with the ([%a ]+)\",\n        \"break ([%a ]+) with ([%a ]+) \",\n        \"break the ([%a ]+)\",\n        \"break ([%a ]+)\",\n        \"break\",\n    },\n    [\"mine\"] = {\n        \"mine the ([%a ]+) with the ([%a ]+)\",\n        \"mine ([%a ]+) with ([%a ]+)\",\n        \"mine ([%a ]+)\",\n        \"mine\",\n    },\n    [\"attack\"] = {\n        \"attack the ([%a ]+) with the ([%a ]+)\",\n        \"attack ([%a ]+) with ([%a ]+)\",\n        \"attack ([%a ]+)\",\n        \"attack\",\n        \"kill the ([%a ]+) with the ([%a ]+)\",\n        \"kill ([%a ]+) with ([%a ]+)\",\n        \"kill ([%a ]+)\",\n        \"kill\",\n        \"hit the ([%a ]+) with the ([%a ]+)\",\n        \"hit ([%a ]+) with ([%a ]+)\",\n        \"hit ([%a ]+)\",\n        \"hit\",\n    },\n    [\"craft\"] = {\n        \"craft a ([%a ]+)\",\n        \"craft some ([%a ]+)\",\n        \"craft ([%a ]+)\",\n        \"craft\",\n        \"make a ([%a ]+)\",\n        \"make some ([%a ]+)\",\n        \"make ([%a ]+)\",\n        \"make\",\n    },\n    [\"build\"] = {\n        \"build ([%a ]+) out of ([%a ]+)\",\n        \"build ([%a ]+) from ([%a ]+)\",\n        \"build ([%a ]+)\",\n        \"build\",\n    },\n    [\"eat\"] = {\n        \"eat a ([%a ]+)\",\n        \"eat the ([%a ]+)\",\n        \"eat ([%a ]+)\",\n        \"eat\",\n    },\n    [\"help\"] = {\n        \"help me\",\n        \"help\",\n    },\n    [\"exit\"] = {\n        \"exit\",\n        \"quit\",\n        \"goodbye\",\n        \"good bye\",\n        \"bye\",\n        \"farewell\",\n    },\n}\n\nlocal commands = {}\nlocal function doCommand( text )\n    if text == \"\" then\n        commands[ \"noinput\" ]()\n        return\n    end\n\n    for sCommand, t in pairs( tMatches ) do\n        for n, sMatch in pairs( t ) do\n            local tCaptures = { string.match( text, \"^\" .. sMatch .. \"$\" ) }\n            if #tCaptures ~= 0 then\n                local fnCommand = commands[ sCommand ]\n                if #tCaptures == 1 and tCaptures[1] == sMatch then\n                    fnCommand()\n                else\n                    fnCommand( table.unpack( tCaptures ) )\n                end\n                return\n            end\n        end\n    end\n    commands[ \"badinput\" ]()\nend\n\nfunction commands.wait()\n    print( \"Time passes...\" )\nend\n\nfunction commands.look( _sTarget )\n    local room = getRoom( x,y,z )\n    if room.dark then\n        print( \"It is pitch dark.\" )\n        return\n    end\n\n    if _sTarget == nil then\n        -- Look at the world\n        if y == 0 then\n            io.write( \"You are standing \" .. tBiomes[room.nBiome] .. \". \" )\n            print( tDayCycle[ getTimeOfDay() ] )\n        else\n            io.write( \"You are underground. \" )\n            if next( room.exits ) ~= nil then\n                print( \"You can travel \"..itemize( room.exits )..\".\" )\n            else\n                print()\n            end\n        end\n        if next( room.items ) ~= nil then\n            print( \"There is \" .. itemize( room.items ) .. \" here.\" )\n        end\n        if room.trees then\n            print( \"There are trees here.\" )\n        end\n\n    else\n        -- Look at stuff\n        if room.trees and (_sTarget == \"tree\" or _sTarget == \"trees\") then\n            print( \"The trees look easy to break.\" )\n        elseif _sTarget == \"self\" or _sTarget == \"myself\" then\n            print( \"Very handsome.\" )\n        else\n            local tItem = nil\n            local sItem = findItem( room.items, _sTarget )\n            if sItem then\n                tItem = room.items[sItem]\n            else\n                sItem = findItem( inventory, _sTarget )\n                if sItem then\n                    tItem = inventory[sItem]\n                end\n            end\n\n            if tItem then\n                print( tItem.desc or (\"You see nothing special about \"..sItem..\".\") )\n            else\n                print( \"You don't see any \".._sTarget..\" here.\" )\n            end\n        end\n    end\nend\n\nfunction commands.go( _sDir )\n    local room = getRoom( x,y,z )\n    if _sDir == nil then\n        print( \"Go where?\" )\n        return\n    end\n\n    if nGoWest ~= nil then\n        if _sDir == \"west\" then\n            nGoWest = nGoWest + 1\n            if nGoWest > #tGoWest then\n                nGoWest = 1\n            end\n            print( tGoWest[ nGoWest ] )\n        else\n            if nGoWest > 0 or nTurn > 6 then\n                nGoWest = nil\n            end\n        end\n    end\n\n    if room.exits[_sDir] == nil then\n        print( \"You can't go that way.\" )\n        return\n    end\n\n    if _sDir == \"north\" then\n        z = z + 1\n    elseif _sDir == \"south\" then\n        z = z - 1\n    elseif _sDir == \"east\" then\n        x = x - 1\n    elseif _sDir == \"west\" then\n        x = x + 1\n    elseif _sDir == \"up\" then\n        y = y + 1\n    elseif _sDir == \"down\" then\n        y = y - 1\n    else\n        print( \"I don't understand that direction.\" )\n        return\n    end\n\n    nTimeInRoom = 0\n    doCommand( \"look\" )\nend\n\nfunction commands.dig( _sDir, _sTool )\n    local room = getRoom( x,y,z )\n    if _sDir == nil then\n        print( \"Dig where?\" )\n        return\n    end\n\n    local sTool = nil\n    local tTool = nil\n    if _sTool ~= nil then\n        sTool = findItem( inventory, _sTool )\n        if not sTool then\n            print( \"You're not carrying a \".._sTool..\".\" )\n            return\n        end\n        tTool = inventory[ sTool ]\n    end\n\n    local bActuallyDigging = (room.exits[ _sDir ] ~= true)\n    if bActuallyDigging then\n        if sTool == nil or tTool.toolType ~= \"pick\" then\n            print( \"You need to use a pickaxe to dig through stone.\" )\n            return\n        end\n    end\n\n    if _sDir == \"north\" then\n        room.exits[\"north\"] = true\n        z = z + 1\n        getRoom( x, y, z ).exits[\"south\"] = true\n\n    elseif _sDir == \"south\" then\n        room.exits[\"south\"] = true\n        z = z - 1\n        getRoom( x, y, z ).exits[\"north\"] = true\n\n    elseif _sDir == \"east\" then\n        room.exits[\"east\"] = true\n        x = x - 1\n        getRoom( x, y, z ).exits[\"west\"] = true\n\n    elseif _sDir == \"west\" then\n        room.exits[\"west\"] = true\n        x = x + 1\n        getRoom( x, y, z ).exits[\"east\"] = true\n\n    elseif _sDir == \"up\" then\n        if y == 0 then\n            print( \"You can't dig that way.\" )\n            return\n        end\n\n        room.exits[\"up\"] = true\n        if y == -1 then\n            room.items[ \"an exit to the surface\" ] = items[ \"an exit to the surface\" ]\n        end\n        y = y + 1\n\n        room = getRoom( x, y, z )\n        room.exits[\"down\"] = true\n        if y == 0 then\n            room.items[ \"a cave entrance\" ] = items[ \"a cave entrance\" ]\n        end\n\n    elseif _sDir == \"down\" then\n        if y <= -3 then\n            print( \"You hit bedrock.\" )\n            return\n        end\n\n        room.exits[\"down\"] = true\n        if y == 0 then\n            room.items[ \"a cave entrance\" ] = items[ \"a cave entrance\" ]\n        end\n        y = y - 1\n\n        room = getRoom( x, y, z )\n        room.exits[\"up\"] = true\n        if y == -1 then\n            room.items[ \"an exit to the surface\" ] = items[ \"an exit to the surface\" ]\n        end\n\n    else\n        print( \"I don't understand that direction.\" )\n        return\n    end\n\n    --\n    if bActuallyDigging then\n        if _sDir == \"down\" and y == -1 or\n           _sDir == \"up\" and y == 0 then\n            inventory[ \"some dirt\" ] = items[ \"some dirt\" ]\n            inventory[ \"some stone\" ] = items[ \"some stone\" ]\n            print( \"You dig \".._sDir..\" using \"..sTool..\" and collect some dirt and stone.\" )\n        else\n            inventory[ \"some stone\" ] = items[ \"some stone\" ]\n            print( \"You dig \".._sDir..\" using \"..sTool..\" and collect some stone.\" )\n        end\n    end\n\n    nTimeInRoom = 0\n    doCommand( \"look\" )\nend\n\nfunction commands.inventory()\n    print( \"You are carrying \" .. itemize( inventory ) .. \".\" )\nend\n\nfunction commands.drop( _sItem )\n    if _sItem == nil then\n        print( \"Drop what?\" )\n        return\n    end\n\n    local room = getRoom( x,y,z )\n    local sItem = findItem( inventory, _sItem )\n    if sItem then\n        local tItem = inventory[ sItem ]\n        if tItem.droppable == false then\n            print( \"You can't drop that.\" )\n        else\n            room.items[ sItem ] = tItem\n            inventory[ sItem ] = nil\n            print( \"Dropped.\" )\n        end\n    else\n        print( \"You don't have a \".._sItem..\".\" )\n    end\nend\n\nfunction commands.place( _sItem )\n    if _sItem == nil then\n        print( \"Place what?\" )\n        return\n    end\n\n    if _sItem == \"torch\" or _sItem == \"a torch\" then\n        local room = getRoom( x,y,z )\n        if inventory[\"some torches\"] or inventory[\"a torch\"] then\n            inventory[\"a torch\"] = nil\n            room.items[\"a torch\"] = items[\"a torch\"]\n            if room.dark then\n                print( \"The cave lights up under the torchflame.\" )\n                room.dark = false\n            elseif y == 0 and not isSunny() then\n                print( \"The night gets a little brighter.\" )\n            else\n                print( \"Placed.\" )\n            end\n        else\n            print( \"You don't have torches.\" )\n        end\n        return\n    end\n\n    commands.drop( _sItem )\nend\n\nfunction commands.take( _sItem )\n    if _sItem == nil then\n        print( \"Take what?\" )\n        return\n    end\n\n    local room = getRoom( x,y,z )\n    local sItem = findItem( room.items, _sItem )\n    if sItem then\n        local tItem = room.items[ sItem ]\n        if tItem.heavy == true then\n            print( \"You can't carry \"..sItem..\".\" )\n        elseif tItem.ore == true then\n            print( \"You need to mine this ore.\" )\n        else\n            if tItem.infinite ~= true then\n                room.items[ sItem ] = nil\n            end\n            inventory[ sItem ] = tItem\n\n            if inventory[\"some torches\"] and inventory[\"a torch\"] then\n                inventory[\"a torch\"] = nil\n            end\n            if sItem == \"a torch\" and y < 0 then\n                room.dark = true\n                print( \"The cave plunges into darkness.\" )\n            else\n                print( \"Taken.\" )\n            end\n        end\n    else\n        print( \"You don't see a \".._sItem..\" here.\" )\n    end\nend\n\nfunction commands.mine( _sItem, _sTool )\n    if _sItem == nil then\n        print( \"Mine what?\" )\n        return\n    end\n    if _sTool == nil then\n        print( \"Mine \".._sItem..\" with what?\" )\n        return\n    end\n    commands.cbreak( _sItem, _sTool )\nend\n\nfunction commands.attack( _sItem, _sTool )\n    if _sItem == nil then\n        print( \"Attack what?\" )\n        return\n    end\n    commands.cbreak( _sItem, _sTool )\nend\n\nfunction commands.cbreak( _sItem, _sTool )\n    if _sItem == nil then\n        print( \"Break what?\" )\n        return\n    end\n\n    local sTool = nil\n    if _sTool ~= nil then\n        sTool = findItem( inventory, _sTool )\n        if sTool == nil then\n            print( \"You're not carrying a \".._sTool..\".\" )\n            return\n        end\n    end\n\n    local room = getRoom( x,y,z )\n    if _sItem == \"tree\" or _sItem == \"trees\" or _sItem == \"a tree\" then\n        print( \"The tree breaks into blocks of wood, which you pick up.\" )\n        inventory[ \"some wood\" ] = items[ \"some wood\" ]\n        return\n    elseif _sItem == \"self\" or _sItem == \"myself\" then\n        if term.isColour() then\n            term.setTextColour( colours.red )\n        end\n        print( \"You have died.\" )\n        print( \"Score: &e0\" )\n        term.setTextColour( colours.white )\n        bRunning = false\n        return\n    end\n\n    local sItem = findItem( room.items, _sItem )\n    if sItem then\n        local tItem = room.items[ sItem ]\n        if tItem.ore == true then\n            -- Breaking ore\n            if not sTool then\n                print( \"You need a tool to break this ore.\" )\n                return\n            end\n            local tTool = inventory[ sTool ]\n            if tTool.tool then\n                if tTool.toolLevel < tItem.toolLevel then\n                    print( sTool ..\" is not strong enough to break this ore.\" )\n                elseif tTool.toolType ~= tItem.toolType then\n                    print( \"You need a different kind of tool to break this ore.\" )\n                else\n                    print( \"The ore breaks, dropping \"..sItem..\", which you pick up.\" )\n                    inventory[ sItem ] = items[ sItem ]\n                    if tItem.infinite ~= true then\n                        room.items[ sItem ] = nil\n                    end\n                end\n            else\n                print( \"You can't break \"..sItem..\" with \"..sTool..\".\")\n            end\n\n        elseif tItem.creature == true then\n            -- Fighting monsters (or pigs)\n            local toolLevel = 0\n            local tTool = nil\n            if sTool then\n                tTool = inventory[ sTool ]\n                if tTool.toolType == \"sword\" then\n                    toolLevel = tTool.toolLevel\n                end\n            end\n\n            local tChances = { 0.2, 0.4, 0.55, 0.8, 1 }\n            if math.random() <= tChances[ toolLevel + 1 ] then\n                room.items[ sItem ] = nil\n                print( \"The \"..tItem.aliases[1]..\" dies.\" )\n\n                if tItem.drops then\n                    for n, sDrop in pairs( tItem.drops ) do\n                        if not room.items[sDrop] then\n                            print( \"The \"..tItem.aliases[1]..\" dropped \"..sDrop..\".\" )\n                            room.items[sDrop] = items[sDrop]\n                        end\n                    end\n                end\n\n                if tItem.monster then\n                    room.nMonsters = room.nMonsters - 1\n                end\n            else\n                print( \"The \"..tItem.aliases[1]..\" is injured by your blow.\" )\n            end\n\n            if tItem.hitDrops then\n                for n, sDrop in pairs( tItem.hitDrops ) do\n                    if not room.items[sDrop] then\n                        print( \"The \"..tItem.aliases[1]..\" dropped \"..sDrop..\".\" )\n                        room.items[sDrop] = items[sDrop]\n                    end\n                end\n            end\n\n        else\n            print( \"You can't break \"..sItem..\".\" )\n        end\n    else\n        print( \"You don't see a \".._sItem..\" here.\" )\n    end\nend\n\nfunction commands.craft( _sItem )\n    if _sItem == nil then\n        print( \"Craft what?\" )\n        return\n    end\n\n    if _sItem == \"computer\" or _sItem == \"a computer\" then\n        print( \"By creating a computer in a computer in a computer, you tear a hole in the spacetime continuum from which no mortal being can escape.\" )\n        if term.isColour() then\n            term.setTextColour( colours.red )\n        end\n        print( \"You have died.\" )\n        print( \"Score: &e0\" )\n        term.setTextColour( colours.white )\n        bRunning = false\n        return\n    end\n\n    local room = getRoom( x,y,z )\n    local sItem = findItem( items, _sItem )\n    local tRecipe = (sItem and tRecipes[ sItem ]) or nil\n    if tRecipe then\n        for n,sReq in ipairs( tRecipe ) do\n            if inventory[sReq] == nil then\n                print( \"You don't have the items you need to craft \"..sItem..\".\" )\n                return\n            end\n        end\n\n        for n,sReq in ipairs( tRecipe ) do\n            inventory[sReq] = nil\n        end\n        inventory[ sItem ] = items[ sItem ]\n        if inventory[\"some torches\"] and inventory[\"a torch\"] then\n            inventory[\"a torch\"] = nil\n        end\n        print( \"Crafted.\" )\n    else\n        print( \"You don't know how to make \"..(sItem or _sItem)..\".\" )\n    end\nend\n\nfunction commands.build( _sThing, _sMaterial )\n    if _sThing == nil then\n        print( \"Build what?\" )\n        return\n    end\n\n    local sMaterial = nil\n    if _sMaterial == nil then\n        for sItem, tItem in pairs( inventory ) do\n            if tItem.material then\n                sMaterial = sItem\n                break\n            end\n        end\n        if sMaterial == nil then\n            print( \"You don't have any building materials.\" )\n            return\n        end\n    else\n        sMaterial = findItem( inventory, _sMaterial )\n        if not sMaterial then\n            print( \"You don't have any \".._sMaterial )\n            return\n        end\n\n        if inventory[sMaterial].material ~= true then\n            print( sMaterial..\" is not a good building material.\" )\n            return\n        end\n    end\n\n    local alias = nil\n    if string.sub(_sThing, 1, 1) == \"a\" then\n        alias = string.match( _sThing, \"a ([%a ]+)\" )\n    end\n\n    local room = getRoom( x,y,z )\n    inventory[sMaterial] = nil\n    room.items[ _sThing ] = {\n        heavy = true,\n        aliases = { alias },\n        desc = \"As you look at your creation (made from \"..sMaterial..\"), you feel a swelling sense of pride.\",\n    }\n\n    print( \"Your construction is complete.\" )\nend\n\nfunction commands.help()\n    local sText =\n        \"Welcome to adventure, the greatest text adventure game on CraftOS. \" ..\n        \"To get around the world, type actions, and the adventure will \" ..\n        \"be read back to you. The actions availiable to you are go, look, inspect, inventory, \" ..\n        \"take, drop, place, punch, attack, mine, dig, craft, build, eat and exit.\"\n    print( sText )\nend\n\nfunction commands.eat( _sItem )\n    if _sItem == nil then\n        print( \"Eat what?\" )\n        return\n    end\n\n    local sItem = findItem( inventory, _sItem )\n    if not sItem then\n        print( \"You don't have any \".._sItem..\".\" )\n        return\n    end\n\n    local tItem = inventory[sItem]\n    if tItem.food then\n        print( \"That was delicious!\" )\n        inventory[sItem] = nil\n\n        if bInjured then\n            print( \"You are no longer injured.\" )\n            bInjured = false\n        end\n    else\n        print( \"You can't eat \"..sItem..\".\" )\n    end\nend\n\nfunction commands.exit()\n    bRunning = false\nend\n\nfunction commands.badinput()\n    local tResponses = {\n        \"I don't understand.\",\n        \"I don't understand you.\",\n        \"You can't do that.\",\n        \"Nope.\",\n        \"Huh?\",\n        \"Say again?\",\n        \"That's crazy talk.\",\n        \"Speak clearly.\",\n        \"I'll think about it.\",\n        \"Let me get back to you on that one.\",\n        \"That doesn't make any sense.\",\n        \"What?\",\n    }\n    print( tResponses[ math.random(1,#tResponses) ] )\nend\n\nfunction commands.noinput()\n    local tResponses = {\n        \"Speak up.\",\n        \"Enunciate.\",\n        \"Project your voice.\",\n        \"Don't be shy.\",\n        \"Use your words.\",\n    }\n    print( tResponses[ math.random(1,#tResponses) ] )\nend\n\nlocal function simulate()\n    local bNewMonstersThisRoom = false\n\n    -- Spawn monsters in nearby rooms\n    for sx = -2,2 do\n        for sy = -1,1 do\n            for sz = -2,2 do\n                local h = y + sy\n                if h >= -3 and h <= 0 then\n                    local room = getRoom( x + sx, h, z + sz )\n\n                    -- Spawn monsters\n                    if room.nMonsters < 2 and\n                       ((h == 0 and not isSunny() and not room.items[\"a torch\"]) or room.dark) and\n                       math.random(1,6) == 1 then\n\n                        local sMonster = tMonsters[ math.random(1,#tMonsters) ]\n                        if room.items[ sMonster ] == nil then\n                               room.items[ sMonster ] = items[ sMonster ]\n                               room.nMonsters = room.nMonsters + 1\n\n                               if sx == 0 and sy == 0 and sz == 0 and not room.dark then\n                                   print( \"From the shadows, \"..sMonster..\" appears.\" )\n                                   bNewMonstersThisRoom = true\n                               end\n                        end\n                    end\n\n                    -- Burn monsters\n                    if h == 0 and isSunny() then\n                        for n,sMonster in ipairs( tMonsters ) do\n                            if room.items[sMonster] and items[sMonster].nocturnal then\n                                room.items[sMonster] = nil\n                                   if sx == 0 and sy == 0 and sz == 0 and not room.dark then\n                                       print( \"With the sun high in the sky, the \"..items[sMonster].aliases[1]..\" bursts into flame and dies.\" )\n                                   end\n                                   room.nMonsters = room.nMonsters - 1\n                               end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    -- Make monsters attack\n    local room = getRoom( x, y, z )\n    if nTimeInRoom >= 2 and not bNewMonstersThisRoom then\n        for n,sMonster in ipairs( tMonsters ) do\n            if room.items[sMonster] then\n                if math.random(1,4) == 1 and\n                   not (y == 0 and isSunny() and (sMonster == \"a spider\")) then\n                    if sMonster == \"a creeper\" then\n                        if room.dark then\n                            print( \"A creeper explodes.\" )\n                        else\n                            print( \"The creeper explodes.\" )\n                        end\n                        room.items[sMonster] = nil\n                        room.nMonsters = room.nMonsters - 1\n                    else\n                        if room.dark then\n                            print( \"A \"..items[sMonster].aliases[1]..\" attacks you.\" )\n                        else\n                            print( \"The \"..items[sMonster].aliases[1]..\" attacks you.\" )\n                        end\n                    end\n\n                    if bInjured then\n                        if term.isColour() then\n                            term.setTextColour( colours.red )\n                        end\n                        print( \"You have died.\" )\n                        print( \"Score: &e0\" )\n                        term.setTextColour( colours.white )\n                        bRunning = false\n                        return\n                    else\n                        bInjured = true\n                    end\n\n                    break\n                end\n            end\n        end\n    end\n\n    -- Always print this\n    if bInjured then\n        if term.isColour() then\n            term.setTextColour( colours.red )\n        end\n        print( \"You are injured.\" )\n        term.setTextColour( colours.white )\n    end\n\n    -- Advance time\n    nTurn = nTurn + 1\n    nTimeInRoom = nTimeInRoom + 1\nend\n\ndoCommand( \"look\" )\nsimulate()\n\nlocal tCommandHistory = {}\nwhile bRunning do\n    if term.isColour() then\n        term.setTextColour( colours.yellow )\n    end\n    write( \"? \" )\n    term.setTextColour( colours.white )\n\n    local sRawLine = read( nil, tCommandHistory )\n    table.insert( tCommandHistory, sRawLine )\n\n    local sLine = nil\n    for match in string.gmatch(sRawLine, \"%a+\") do\n        if sLine then\n            sLine = sLine .. \" \" .. string.lower(match)\n        else\n            sLine = string.lower(match)\n        end\n    end\n\n    doCommand( sLine or \"\" )\n    if bRunning then\n        simulate()\n    end\nend","hello.lua":"if term.isColour() then\n    term.setTextColour( 2^math.random(0,15) )\nend\ntextutils.slowPrint( \"Hello World!\" )\nterm.setTextColour( colours.white )","dj.lua":"local tArgs = { ... }\n\nlocal function printUsage()\n    print( \"Usages:\")\n    print( \"dj play\" )\n    print( \"dj play <drive>\" )\n    print( \"dj stop\" )\nend\n\nif #tArgs > 2 then\n    printUsage()\n    return\nend\n\nlocal sCommand = tArgs[1]\nif sCommand == \"stop\" then\n    -- Stop audio\n    disk.stopAudio()\n\nelseif sCommand == \"play\" or sCommand == nil then\n    -- Play audio\n    local sName = tArgs[2]\n    if sName == nil then\n        -- No disc specified, pick one at random\n        local tNames = {}\n        for n,sName in ipairs( peripheral.getNames() ) do\n            if disk.isPresent( sName ) and disk.hasAudio( sName ) then\n                table.insert( tNames, sName )\n            end\n        end\n        if #tNames == 0 then\n            print( \"No Music Discs in attached disk drives\" )\n            return\n        end\n        sName = tNames[ math.random(1,#tNames) ]\n    end\n\n    -- Play the disc\n    if disk.isPresent( sName ) and disk.hasAudio( sName ) then\n        print( \"Playing \"..disk.getAudioTitle( sName ) )\n        disk.playAudio( sName )\n    else\n        print( \"No Music Disc in disk drive: \"..sName )\n        return\n    end\n\nelse\n    printUsage()\n\nend","worm.lua":"\n-- Display the start screen\nlocal w,h = term.getSize()\n\nlocal titleColour, headingColour, textColour, wormColour, fruitColour\nif term.isColour() then\n    titleColour = colours.red\n    headingColour = colours.yellow\n    textColour = colours.white\n    wormColour = colours.green\n    fruitColour = colours.red\nelse\n    titleColour = colours.white\n    headingColour = colours.white\n    textColour = colours.white\n    wormColour = colours.white\n    fruitColour = colours.white\nend\n\nlocal function printCentred( y, s )\n    local x = math.floor((w - string.len(s)) / 2)\n    term.setCursorPos(x,y)\n    --term.clearLine()\n    term.write( s )\nend\n\nlocal xVel,yVel = 1,0\nlocal xPos, yPos = math.floor(w/2), math.floor(h/2)\nlocal pxVel, pyVel = nil, nil\n\nlocal nLength = 1\nlocal nExtraLength = 6\nlocal bRunning = true\n\nlocal tailX,tailY = xPos,yPos\nlocal nScore = 0\nlocal nDifficulty = 2\nlocal nSpeed, nInterval\n\n-- Setup the screen\nlocal screen = {}\nfor x=1,w do\n    screen[x] = {}\n    for y=1,h do\n        screen[x][y] = {}\n    end\nend\nscreen[xPos][yPos] = { snake = true }\n\nlocal nFruit = 1\nlocal tFruits = {\n    \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\",\n    \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\n    \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\",\n    \"Y\", \"Z\",\n    \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\n    \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\",\n    \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\",\n    \"y\", \"z\",\n    \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"0\",\n    \"@\", \"$\", \"%\", \"#\", \"&\", \"!\", \"?\", \"+\", \"*\", \"~\"\n}\n\nlocal function addFruit()\n    while true do\n        local x = math.random(1,w)\n        local y = math.random(2,h)\n        local fruit = screen[x][y]\n        if fruit.snake == nil and fruit.wall == nil and fruit.fruit == nil then\n            screen[x][y] = { fruit = true }\n            term.setCursorPos(x,y)\n            term.setBackgroundColour( fruitColour )\n            term.write(\" \")\n            term.setBackgroundColour( colours.black )\n            break\n        end\n    end\n\n    nFruit = nFruit + 1\n    if nFruit > #tFruits then\n        nFruit = 1\n    end\nend\n\nlocal function drawMenu()\n    term.setTextColour( headingColour )\n    term.setCursorPos(1,1)\n    term.write( \"SCORE \" )\n\n    term.setTextColour( textColour )\n    term.setCursorPos(7,1)\n    term.write( tostring(nScore) )\n\n    term.setTextColour( headingColour )\n    term.setCursorPos(w-11,1)\n    term.write( \"DIFFICULTY \")\n\n    term.setTextColour( textColour )\n    term.setCursorPos(w,1)\n    term.write( tostring(nDifficulty or \"?\") )\n\n    term.setTextColour( colours.white )\nend\n\nlocal function update( )\n    local x,y = xPos,yPos\n    if pxVel and pyVel then\n        xVel, yVel = pxVel, pyVel\n        pxVel, pyVel = nil, nil\n    end\n\n    -- Remove the tail\n    if nExtraLength == 0 then\n        local tail = screen[tailX][tailY]\n        screen[tailX][tailY] = {}\n        term.setCursorPos(tailX,tailY)\n        term.write(\" \")\n        tailX = tail.nextX\n        tailY = tail.nextY\n    else\n        nExtraLength = nExtraLength - 1\n    end\n\n    -- Update the head\n    local head = screen[xPos][yPos]\n    local newXPos = xPos + xVel\n    local newYPos = yPos + yVel\n    if newXPos < 1 then\n        newXPos = w\n    elseif newXPos > w then\n        newXPos = 1\n    end\n    if newYPos < 2 then\n        newYPos = h\n    elseif newYPos > h then\n        newYPos = 2\n    end\n\n    local newHead = screen[newXPos][newYPos]\n    if newHead.snake == true or newHead.wall == true then\n        bRunning = false\n\n    else\n        if newHead.fruit == true then\n            nScore = nScore + 10\n            nExtraLength = nExtraLength + 1\n            addFruit()\n        end\n        xPos = newXPos\n        yPos = newYPos\n        head.nextX = newXPos\n        head.nextY = newYPos\n        screen[newXPos][newYPos] = { snake = true }\n\n    end\n\n    term.setCursorPos(xPos,yPos)\n    term.setBackgroundColour( wormColour )\n    term.write(\" \")\n    term.setBackgroundColour( colours.black )\n\n    drawMenu()\nend\n\n-- Display the frontend\nterm.clear()\nlocal function drawFrontend()\n    --term.setTextColour( titleColour )\n    --printCentred( math.floor(h/2) - 4, \" W O R M \" )\n\n    term.setTextColour( headingColour )\n    printCentred( math.floor(h/2) - 3, \"\" )\n    printCentred( math.floor(h/2) - 2, \" SELECT DIFFICULTY \" )\n    printCentred( math.floor(h/2) - 1, \"\" )\n\n    printCentred( math.floor(h/2) + 0, \"            \" )\n    printCentred( math.floor(h/2) + 1, \"            \" )\n    printCentred( math.floor(h/2) + 2, \"            \" )\n    printCentred( math.floor(h/2) - 1 + nDifficulty, \" [        ] \" )\n\n    term.setTextColour( textColour )\n    printCentred( math.floor(h/2) + 0, \"EASY\" )\n    printCentred( math.floor(h/2) + 1, \"MEDIUM\" )\n    printCentred( math.floor(h/2) + 2, \"HARD\" )\n    printCentred( math.floor(h/2) + 3, \"\" )\n\n    term.setTextColour( colours.white )\nend\n\ndrawMenu()\ndrawFrontend()\nwhile true do\n    local e,key = os.pullEvent( \"key\" )\n    if key == keys.up or key == keys.w then\n        -- Up\n        if nDifficulty > 1 then\n            nDifficulty = nDifficulty - 1\n            drawMenu()\n            drawFrontend()\n        end\n    elseif key == keys.down or key == keys.s then\n        -- Down\n        if nDifficulty < 3 then\n            nDifficulty = nDifficulty + 1\n            drawMenu()\n            drawFrontend()\n        end\n    elseif key == keys.enter then\n        -- Enter\n        break\n    end\nend\n\nlocal tSpeeds = { 5, 10, 25 }\nnSpeed = tSpeeds[nDifficulty]\nnInterval = 1 / nSpeed\n\n-- Grow the snake to its intended size\nterm.clear()\ndrawMenu()\nscreen[tailX][tailY].snake = true\nwhile nExtraLength > 0 do\n    update()\nend\naddFruit()\naddFruit()\n\n-- Play the game\nlocal timer = os.startTimer(0)\nwhile bRunning do\n    local event, p1, p2 = os.pullEvent()\n    if event == \"timer\" and p1 == timer then\n        timer = os.startTimer(nInterval)\n        update( false )\n\n    elseif event == \"key\" then\n        local key = p1\n        if key == keys.up or key == keys.w then\n            -- Up\n            if yVel == 0 then\n                pxVel,pyVel = 0,-1\n            end\n        elseif key == keys.down or key == keys.s then\n            -- Down\n            if yVel == 0 then\n                pxVel,pyVel = 0,1\n            end\n        elseif key == keys.left or key == keys.a then\n            -- Left\n            if xVel == 0 then\n                pxVel,pyVel = -1,0\n            end\n\n        elseif key == keys.right or key == keys.d then\n            -- Right\n            if xVel == 0 then\n                pxVel,pyVel = 1,0\n            end\n\n        end\n    end\nend\n\n-- Display the gameover screen\nterm.setTextColour( headingColour )\nprintCentred( math.floor(h/2) - 2, \"                   \" )\nprintCentred( math.floor(h/2) - 1, \" G A M E   O V E R \" )\n\nterm.setTextColour( textColour )\nprintCentred( math.floor(h/2) + 0, \"                 \" )\nprintCentred( math.floor(h/2) + 1, \" FINAL SCORE \"..nScore..\" \" )\nprintCentred( math.floor(h/2) + 2, \"                 \" )\nterm.setTextColour( colours.white )\n\nlocal timer = os.startTimer(2.5)\nrepeat\n    local e,p = os.pullEvent()\n    if e == \"timer\" and p == timer then\n        term.setTextColour( textColour )\n        printCentred( math.floor(h/2) + 2, \" PRESS ANY KEY \" )\n        printCentred( math.floor(h/2) + 3, \"               \" )\n        term.setTextColour( colours.white )\n    end\nuntil e == \"char\"\n\nterm.clear()\nterm.setCursorPos(1,1)","advanced":{"levels":{"10.dat":"5\n 777    77777\n 727777778837\n 788888878787\n 787777888887\n77877778777777\n7e8b7888b888e7\n7787787b777877\n 777887887887\n   7487807487\n   7777777777","1.dat":"1\n     777\n     7b7\n     787\n7777778777\n7188888887\n7777777777","0.dat":"0\n77     77\n718888887\n 8     8\n 8     8\n 8     8\n788888897\n77     77","9.dat":"2\n    777  777\n  777877778777\n  788838888887\n7778bbbbbbbb8777\n7888b888888b8897\n7878be8888eb8787\n7588b888888b8887\n7778bbbbbbbb8777\n  788888818887\n  777877778777\n    777  777","8.dat":"4\n777777 7777\n7287b7 7867\n788787 7887\n77878777877\n 7888eb8887\n 77877787877\n 7887 787887\n 7487 7e7807\n 7777 777777","5.dat":"3\n777777777\n788888887\n787787787\n787787787\n788888887\n787787787\n787787787\n78e748887\n777777777","4.dat":"2\n    77777777\n777778888887\n788888777787\n7b77787  787\n787 787  787\n7b77787  787\n7888887  787\n7777707  707\n    777  777","3.dat":"2\n  77777777\n777888188777\n7b78777787b7\n78787  78787\n78787  78787\n78887  78887\n777877778777\n  78838887\n  77777777","2.dat":"1\n777777777\n7888888b7\n787778887\n787 78777\n7877787\n7888887\n7777787\n    707\n    777","11.dat":"4\n   777777777\n   727872787\n   787878787\n777787878787777\n7be888888888be7\n777787878787777\n   787878787\n   787478747\n   777777777","12.dat":"6\n77  777  77\n72888888897\n 8   8   8\n 8 8b888 8\n78 e8888 87\n78888788887\n78 8888e 87\n 8 888b8 8\n 8   8   8\n75888888807\n77  777  77","7.dat":"3\n728777778b7\n78888888887\n78777877787\n787 787 787\n787 7877788\n787 7888889\n88777877777\ne888887\n7777887","6.dat":"4\n7777777777\n7288888837\n78      87\n788888b 87\n788888b 87\n788888b 87\n788888b 87\n78      87\n7188888807\n7777777777"},"paint.lua":"-- Paint created by nitrogenfingers (edited by dan200)\n-- http://www.youtube.com/user/NitrogenFingers\n\n------------\n-- Fields --\n------------\n\n-- The width and height of the terminal\nlocal w,h = term.getSize()\n\n-- The selected colours on the left and right mouse button, and the colour of the canvas\nlocal leftColour, rightColour = colours.white, nil\nlocal canvasColour = colours.black\n\n-- The values stored in the canvas\nlocal canvas = {}\n\n-- The menu options\nlocal mChoices = { \"Save\",\"Exit\" }\n\n-- The message displayed in the footer bar\nlocal fMessage = \"Press Ctrl to access menu\"\n\n-------------------------\n-- Initialisation --\n-------------------------\n\n-- Determine if we can even run this\nif not term.isColour() then\n    print(\"Requires an Advanced Computer\")\n    return\nend\n\n-- Determines if the file exists, and can be edited on this computer\nlocal tArgs = {...}\nif #tArgs == 0 then\n    print(\"Usage: paint <path>\")\n    return\nend\nlocal sPath = shell.resolve(tArgs[1])\nlocal bReadOnly = fs.isReadOnly(sPath)\nif fs.exists(sPath) and fs.isDir(sPath) then\n    print(\"Cannot edit a directory.\")\n    return\nend\n\n-- Create .nfp files by default\nif not fs.exists( sPath ) and not string.find( sPath, \"%.\" ) then\n    local sExtension = settings.get(\"paint.default_extension\", \"\" )\n    if sExtension ~= \"\" and type( sExtension ) == \"string\" then\n        sPath = sPath .. \".\" .. sExtension\n    end\nend\n\n\n---------------\n-- Functions --\n---------------\n\nlocal function getCanvasPixel( x, y )\n    if canvas[y] then\n        return canvas[y][x]\n    end\n    return nil\nend\n\n--[[\n    Converts a colour value to a text character\n    params: colour = the number to convert to a hex value\n    returns: a string representing the chosen colour\n]]\nlocal function getCharOf( colour )\n    -- Incorrect values always convert to nil\n    if type(colour) == \"number\" then\n        local value = math.floor( math.log(colour) / math.log(2) ) + 1\n        if value >= 1 and value <= 16 then\n            return string.sub( \"0123456789abcdef\", value, value )\n        end\n    end\n    return \" \"\nend\n\n--[[\n    Converts a text character to colour value\n    params: char = the char (from string.byte) to convert to number\n    returns: the colour number of the hex value\n]]\nlocal tColourLookup = {}\nfor n=1,16 do\n    tColourLookup[ string.byte( \"0123456789abcdef\",n,n ) ] = 2^(n-1)\nend\nlocal function getColourOf( char )\n    -- Values not in the hex table are transparent (canvas coloured)\n    return tColourLookup[char]\nend\n\n--[[\n    Loads the file into the canvas\n    params: path = the path of the file to open\n    returns: nil\n]]\nlocal function load(path)\n    -- Load the file\n    if fs.exists(path) then\n        local file = fs.open(sPath, \"r\")\n        local sLine = file.readLine()\n        while sLine do\n            local line = {}\n            for x=1,w-2 do\n                line[x] = getColourOf( string.byte(sLine,x,x) )\n            end\n            table.insert( canvas, line )\n            sLine = file.readLine()\n        end\n        file.close()\n    end\nend\n\n--[[\n    Saves the current canvas to file\n    params: path = the path of the file to save\n    returns: true if save was successful, false otherwise\n]]\nlocal function save(path)\n    -- Open file\n    local sDir = string.sub(sPath, 1, #sPath - #fs.getName(sPath))\n    if not fs.exists(sDir) then\n        fs.makeDir(sDir)\n    end\n\n    local file, err = fs.open( path, \"w\" )\n    if not file then\n        return false, err\n    end\n\n    -- Encode (and trim)\n    local tLines = {}\n    local nLastLine = 0\n    for y=1,h-1 do\n        local sLine = \"\"\n        local nLastChar = 0\n        for x=1,w-2 do\n            local c = getCharOf( getCanvasPixel( x, y ) )\n            sLine = sLine .. c\n            if c ~= \" \" then\n                nLastChar = x\n            end\n        end\n        sLine = string.sub( sLine, 1, nLastChar )\n        tLines[y] = sLine\n        if string.len( sLine ) > 0 then\n            nLastLine = y\n        end\n    end\n\n    -- Save out\n    for n=1,nLastLine do\n           file.writeLine( tLines[ n ] )\n    end\n    file.close()\n    return true\nend\n\n--[[\n    Draws colour picker sidebar, the pallette and the footer\n    returns: nil\n]]\nlocal function drawInterface()\n    -- Footer\n    term.setCursorPos(1, h)\n    term.setBackgroundColour(colours.black)\n    term.setTextColour(colours.yellow)\n    term.clearLine()\n    term.write(fMessage)\n\n    -- Colour Picker\n    for i=1,16 do\n        term.setCursorPos(w-1, i)\n        term.setBackgroundColour( 2^(i-1) )\n        term.write(\"  \")\n    end\n\n    term.setCursorPos(w-1, 17)\n    term.setBackgroundColour( canvasColour )\n    term.setTextColour( colours.grey )\n    term.write(\"\\127\\127\")\n\n    -- Left and Right Selected Colours\n    for i=18,18 do\n        term.setCursorPos(w-1, i)\n        if leftColour ~= nil then\n            term.setBackgroundColour( leftColour )\n            term.write(\" \")\n        else\n            term.setBackgroundColour( canvasColour )\n            term.setTextColour( colours.grey )\n            term.write(\"\\127\")\n        end\n        if rightColour ~= nil then\n            term.setBackgroundColour( rightColour )\n            term.write(\" \")\n        else\n            term.setBackgroundColour( canvasColour )\n            term.setTextColour( colours.grey )\n            term.write(\"\\127\")\n        end\n    end\n\n    -- Padding\n    term.setBackgroundColour( canvasColour )\n    for i=20,h-1 do\n        term.setCursorPos(w-1, i)\n        term.write(\"  \")\n    end\nend\n\n--[[\n    Converts a single pixel of a single line of the canvas and draws it\n    returns: nil\n]]\nlocal function drawCanvasPixel( x, y )\n    local pixel = getCanvasPixel( x, y )\n    if pixel then\n        term.setBackgroundColour( pixel or canvasColour )\n        term.setCursorPos(x, y)\n        term.write(\" \")\n    else\n        term.setBackgroundColour( canvasColour )\n        term.setTextColour( colours.grey )\n        term.setCursorPos(x, y)\n        term.write(\"\\127\")\n    end\nend\n\n--[[\n    Converts each colour in a single line of the canvas and draws it\n    returns: nil\n]]\nlocal function drawCanvasLine( y )\n    for x = 1, w-2 do\n        drawCanvasPixel( x, y )\n    end\nend\n\n--[[\n    Converts each colour in the canvas and draws it\n    returns: nil\n]]\nlocal function drawCanvas()\n    for y = 1, h-1 do\n        drawCanvasLine( y )\n    end\nend\n\n--[[\n    Draws menu options and handles input from within the menu.\n    returns: true if the program is to be exited; false otherwise\n]]\nlocal function accessMenu()\n    -- Selected menu option\n    local selection = 1\n\n    term.setBackgroundColour(colours.black)\n    while true do\n        -- Draw the menu\n        term.setCursorPos(1,h)\n        term.clearLine()\n        term.setTextColour(colours.white)\n        for k,v in pairs(mChoices) do\n            if selection==k then\n                term.setTextColour(colours.yellow)\n                local ox,_ = term.getCursorPos()\n                term.write(\"[\"..string.rep(\" \",#v)..\"]\")\n                term.setCursorPos(ox+1,h)\n                term.setTextColour(colours.white)\n                term.write(v)\n                term.setCursorPos(term.getCursorPos()+1,h)\n            else\n                term.write(\" \"..v..\" \")\n            end\n        end\n\n        -- Handle input in the menu\n        local id,key = os.pullEvent(\"key\")\n        if id == \"key\" then\n            -- S and E are shortcuts\n            if key == keys.s then\n                selection = 1\n                key = keys.enter\n            elseif key == keys.e then\n                selection = 2\n                key = keys.enter\n            end\n\n            if key == keys.right then\n                -- Move right\n                selection = selection + 1\n                if selection > #mChoices then\n                    selection = 1\n                end\n\n            elseif key == keys.left and selection > 1 then\n                -- Move left\n                selection = selection - 1\n                if selection < 1 then\n                    selection = #mChoices\n                end\n\n            elseif key == keys.enter then\n                -- Select an option\n                if mChoices[selection]==\"Save\" then\n                    if bReadOnly then\n                        fMessage = \"Access denied\"\n                        return false\n                    end\n                    local success, err = save(sPath)\n                    if success then\n                        fMessage = \"Saved to \"..sPath\n                    else\n                        if err then\n                            fMessage = \"Error saving to \"..err\n                        else\n                            fMessage = \"Error saving to \"..sPath\n                        end\n                    end\n                    return false\n                elseif mChoices[selection]==\"Exit\" then\n                    return true\n                end\n            elseif key == keys.leftCtrl or keys == keys.rightCtrl then\n                -- Cancel the menu\n                return false\n            end\n        end\n    end\nend\n\n--[[\n    Runs the main thread of execution. Draws the canvas and interface, and handles\n    mouse and key events.\n    returns: nil\n]]\nlocal function handleEvents()\n    local programActive = true\n    while programActive do\n        local id,p1,p2,p3 = os.pullEvent()\n        if id==\"mouse_click\" or id==\"mouse_drag\" then\n            if p2 >= w-1 and p3 >= 1 and p3 <= 17 then\n                if id ~= \"mouse_drag\" then\n                    -- Selecting an items in the colour picker\n                    if p3 <= 16 then\n                        if p1==1 then\n                            leftColour = 2^(p3-1)\n                        else\n                            rightColour = 2^(p3-1)\n                        end\n                    else\n                        if p1==1 then\n                            leftColour = nil\n                        else\n                            rightColour = nil\n                        end\n                    end\n                    --drawCanvas()\n                    drawInterface()\n                end\n            elseif p2 < w-1 and p3 <= h-1 then\n                -- Clicking on the canvas\n                local paintColour = nil\n                if p1==1 then\n                    paintColour = leftColour\n                elseif p1==2 then\n                    paintColour = rightColour\n                end\n                if not canvas[p3] then\n                    canvas[p3] = {}\n                end\n                canvas[p3][p2] = paintColour\n\n                drawCanvasPixel( p2, p3 )\n            end\n        elseif id==\"key\" then\n            if p1==keys.leftCtrl or p1==keys.rightCtrl then\n                programActive = not accessMenu()\n                drawInterface()\n            end\n        elseif id==\"term_resize\" then\n            w,h = term.getSize()\n            drawCanvas()\n            drawInterface()\n        end\n    end\nend\n\n-- Init\nload(sPath)\ndrawCanvas()\ndrawInterface()\n\n-- Main loop\nhandleEvents()\n\n-- Shutdown\nterm.setBackgroundColour(colours.black)\nterm.setTextColour(colours.white)\nterm.clear()\nterm.setCursorPos(1,1)","redirection.lua":"--CCRedirection by : RamiLego4Game and Dan200--\n--Based on Redirection by Dan200: http://www.redirectiongame.com--\n--Clearing Screen--\n\n--Vars--\nlocal TermW,TermH = term.getSize()\n\nlocal sLevelTitle\nlocal tScreen\nlocal oScreen\nlocal SizeW,SizeH\nlocal aExits\nlocal fExit\nlocal nSpeed\nlocal Speed\nlocal fSpeed\nlocal fSpeedS\nlocal bPaused\nlocal Tick\nlocal Blocks\nlocal XOrgin,YOrgin\nlocal fLevel\n\nlocal function reset()\n    sLevelTitle = \"\"\n    tScreen = {}\n    oScreen = {}\n    SizeW,SizeH = TermW,TermH\n    aExits = 0\n    fExit = \"nop\"\n    nSpeed = 0.6\n    Speed = nSpeed\n    fSpeed = 0.2\n    fSpeedS = false\n    bPaused = false\n    Tick = os.startTimer(Speed)\n    Blocks = 0\n    XOrgin,YOrgin = 1,1\n\n    term.setBackgroundColor(colors.black)\n    term.setTextColor(colors.white)\n    term.clear()\nend\n\nlocal InterFace = {}\nInterFace.cExit = colors.red\nInterFace.cSpeedD = colors.white\nInterFace.cSpeedA = colors.red\nInterFace.cTitle = colors.red\n\nlocal cG = colors.lightGray\nlocal cW = colors.gray\nlocal cS = colors.black\nlocal cR1 = colors.blue\nlocal cR2 = colors.red\nlocal cR3 = colors.green\nlocal cR4 = colors.yellow\n\nlocal tArgs = { ... }\n\n--Functions--\nlocal function printCentred( yc, stg )\n    local xc = math.floor((TermW - string.len(stg)) / 2) + 1\n    term.setCursorPos(xc,yc)\n    term.write( stg )\nend\n\nlocal function centerOrgin()\n    XOrgin = math.floor((TermW/2)-(SizeW/2))\n    YOrgin = math.floor((TermH/2)-(SizeH/2))\nend\n\nlocal function reMap()\n    tScreen = nil\n    tScreen = {}\n    for x=1,SizeW do\n        tScreen[x] = {}\n        for y=1,SizeH do\n            tScreen[x][y] = { space = true, wall = false, ground = false, robot = \"zz\", start = \"zz\", exit = \"zz\" }\n        end\n    end\nend\n\nlocal function tablecopy(t)\n  local t2 = {}\n  for k,v in pairs(t) do\n    t2[k] = v\n  end\n  return t2\nend\n\nlocal function buMap()\n    oScreen = nil\n    oScreen = {}\n    for x=1,SizeW do\n        oScreen[x] = {}\n        for y=1,SizeH do\n            oScreen[x][y] = tablecopy(tScreen[x][y])\n        end\n    end\nend\n\nlocal function addRobot(x,y,side,color)\n    local obj = tScreen[x][y]\n    local data = side..color\n    if obj.wall == nil and obj.robot == nil then\n        tScreen[x][y].robot = data\n    else\n        obj.wall = nil\n        obj.robot = \"zz\"\n        tScreen[x][y].robot = data\n    end\nend\n\nlocal function addStart(x,y,side,color)\n    local obj = tScreen[x][y]\n    local data = side..color\n    if obj.wall == nil and obj.space == nil then\n        tScreen[x][y].start = data\n    else\n        obj.wall = nil\n        obj.space = nil\n        tScreen[x][y].start = data\n    end\n    aExits = aExits+1\nend\n\nlocal function addGround(x,y)\n    local obj = tScreen[x][y]\n    if obj.space == nil and obj.exit == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then\n        tScreen[x][y].ground = true\n    else\n        obj.space = nil\n        obj.exit = \"zz\"\n        obj.wall = nil\n        obj.robot = \"zz\"\n        obj.start = \"zz\"\n        tScreen[x][y].ground = true\n    end\nend\n\nlocal function addExit(x,y,cl)\n    local obj = tScreen[x][y]\n    if obj.space == nil and obj.ground == nil and obj.wall == nil and obj.robot == nil and obj.start == nil then\n        tScreen[x][y].exit = cl\n    else\n        obj.space = nil\n        obj.ground = nil\n        obj.wall = nil\n        obj.robot = \"zz\"\n        obj.start = \"zz\"\n        tScreen[x][y].exit = cl\n    end\nend\n\nlocal function addWall(x,y)\n    local obj = tScreen[x][y]\n    if obj == nil then\n        return error(\"Here X\"..x..\" Y\"..y)\n    end\n    if obj.space == nil and obj.exit == nil and obj.ground == nil and obj.robot == nil and obj.start == nil then\n        tScreen[x][y].wall = true\n    else\n        obj.space = nil\n        obj.exit = nil\n        obj.ground = nil\n        obj.robot = nil\n        obj.start = nil\n        tScreen[x][y].wall = true\n    end\nend\n\nlocal function loadLevel(nNum)\n    sLevelTitle = \"Level \"..nNum\n    if nNum == nil then return error(\"nNum == nil\") end\n    local sDir = fs.getDir( shell.getRunningProgram() )\n    local sLevelD = sDir .. \"/levels/\" .. tostring(nNum)..\".dat\"\n    if not ( fs.exists(sLevelD) or fs.isDir(sLevelD) ) then return error(\"Level Not Exists : \"..sLevelD) end\n    fLevel = fs.open(sLevelD,\"r\")\n    local Line = 0\n    local wl = true\n    Blocks = tonumber(string.sub(fLevel.readLine(),1,1))\n    local xSize = string.len(fLevel.readLine())+2\n    local Lines = 3\n    while wl do\n        local wLine = fLevel.readLine()\n        if wLine == nil then\n            fLevel.close()\n            wl = false\n        else\n            xSize = math.max(string.len(wLine)+2,xSize)\n            Lines = Lines + 1\n        end\n    end\n    SizeW,SizeH = xSize,Lines\n    reMap()\n    fLevel = fs.open(sLevelD,\"r\")\n    fLevel.readLine()\n    for Line=2,Lines-1 do\n        local sLine = fLevel.readLine()\n        local chars = string.len(sLine)\n        for char = 1, chars do\n            local el = string.sub(sLine,char,char)\n            if el == \"8\" then\n                addGround(char+1,Line)\n            elseif el == \"0\" then\n                addStart(char+1,Line,\"a\",\"a\")\n            elseif el == \"1\" then\n                addStart(char+1,Line,\"b\",\"a\")\n            elseif el == \"2\" then\n                addStart(char+1,Line,\"c\",\"a\")\n            elseif el == \"3\" then\n                addStart(char+1,Line,\"d\",\"a\")\n            elseif el == \"4\" then\n                addStart(char+1,Line,\"a\",\"b\")\n            elseif el == \"5\" then\n                addStart(char+1,Line,\"b\",\"b\")\n            elseif el == \"6\" then\n                addStart(char+1,Line,\"c\",\"b\")\n            elseif el == \"9\" then\n                addStart(char+1,Line,\"d\",\"b\")\n            elseif el == \"b\" then\n                addExit(char+1,Line,\"a\")\n            elseif el == \"e\" then\n                addExit(char+1,Line,\"b\")\n            elseif el == \"7\" then\n                addWall(char+1,Line)\n            end\n        end\n    end\n    fLevel.close()\nend\n\nlocal function drawStars()\n    --CCR Background By : RamiLego--\n    local cStar,cStarG,crStar,crStarB = colors.lightGray,colors.gray,\".\",\"*\"\n    local DStar,BStar,nStar,gStar = 14,10,16,3\n    local TermW,TermH = term.getSize()\n\n    term.clear()\n    term.setCursorPos(1,1)\n    for x=1,TermW do\n        for y=1,TermH do\n            local StarT = math.random(1,30)\n            if StarT == DStar then\n                term.setCursorPos(x,y)\n                term.setTextColor(cStar)\n                write(crStar)\n            elseif StarT == BStar then\n                term.setCursorPos(x,y)\n                term.setTextColor(cStar)\n                write(crStarB)\n            elseif StarT == nStar then\n                term.setCursorPos(x,y)\n                term.setTextColor(cStarG)\n                write(crStar)\n            elseif StarT == gStar then\n                term.setCursorPos(x,y)\n                term.setTextColor(cStarG)\n                write(crStarB)\n            end\n        end\n    end\nend\n\nlocal function drawMap()\n    for x=1,SizeW do\n        for y=1,SizeH do\n\n            local obj = tScreen[x][y]\n            if obj.ground == true then\n                paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cG)\n            end\n            if obj.wall == true then\n                paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cW)\n            end\n\n         local ex = tostring(tScreen[x][y].exit)\n            if not(ex == \"zz\" or ex == \"nil\") then\n                if ex == \"a\" then\n                    ex = cR1\n                elseif ex == \"b\" then\n                    ex = cR2\n                elseif ex == \"c\" then\n                    ex = cR3\n                elseif ex == \"d\" then\n                    ex = cR4\n                else\n                    return error(\"Exit Color Out\")\n                end\n                term.setBackgroundColor(cG)\n                term.setTextColor(ex)\n                term.setCursorPos(XOrgin+x,YOrgin+y+1)\n                print(\"X\")\n            end\n\n         local st = tostring(tScreen[x][y].start)\n            if not(st == \"zz\" or st == \"nil\") then\n                local Cr = string.sub(st,2,2)\n                if Cr == \"a\" then\n                    Cr = cR1\n                elseif Cr == \"b\" then\n                    Cr = cR2\n                elseif Cr == \"c\" then\n                    Cr = cR3\n                elseif Cr == \"d\" then\n                    Cr = cR4\n                else\n                    return error(\"Start Color Out\")\n                end\n\n                term.setTextColor(Cr)\n            term.setBackgroundColor(cG)\n                term.setCursorPos(XOrgin+x,YOrgin+y+1)\n\n                local sSide = string.sub(st,1,1)\n                if sSide == \"a\" then\n                    print(\"^\")\n                elseif sSide == \"b\" then\n                    print(\">\")\n                elseif sSide == \"c\" then\n                    print(\"v\")\n                elseif sSide == \"d\" then\n                    print(\"<\")\n                else\n                    print(\"@\")\n                end\n            end\n\n            if obj.space == true then\n                paintutils.drawPixel(XOrgin+x,YOrgin+y+1,cS)\n            end\n\n            local rb = tostring(tScreen[x][y].robot)\n            if not(rb == \"zz\" or rb == \"nil\") then\n                local Cr = string.sub(rb,2,2)\n                if Cr == \"a\" then\n                    Cr = cR1\n                elseif Cr == \"b\" then\n                    Cr = cR2\n                elseif Cr == \"c\" then\n                    Cr = cR3\n                elseif Cr == \"d\" then\n                    Cr = cR4\n                else\n                    Cr = colors.white\n                end\n                term.setBackgroundColor(Cr)\n                term.setTextColor(colors.white)\n                term.setCursorPos(XOrgin+x,YOrgin+y+1)\n                local sSide = string.sub(rb,1,1)\n                if sSide == \"a\" then\n                    print(\"^\")\n                elseif sSide == \"b\" then\n                    print(\">\")\n                elseif sSide == \"c\" then\n                    print(\"v\")\n                elseif sSide == \"d\" then\n                    print(\"<\")\n                else\n                    print(\"@\")\n                end\n            end\n        end\n    end\nend\n\nlocal function isBrick(x,y)\n    local brb = tostring(tScreen[x][y].robot)\n    local bobj = oScreen[x][y]\n    if (brb == \"zz\" or brb == \"nil\") and not bobj.wall == true then\n        return false\n    else\n        return true\n    end\nend\n\nlocal function gRender(sContext)\n    if sContext == \"start\" then\n        for x=1,SizeW do\n            for y=1,SizeH do\n                local st = tostring(tScreen[x][y].start)\n                if not(st == \"zz\" or st == \"nil\") then\n                    local Cr = string.sub(st,2,2)\n                    local sSide = string.sub(st,1,1)\n                    addRobot(x,y,sSide,Cr)\n                end\n            end\n        end\n    elseif sContext == \"tick\" then\n        buMap()\n        for x=1,SizeW do\n            for y=1,SizeH do\n                local rb = tostring(oScreen[x][y].robot)\n                if not(rb == \"zz\" or rb == \"nil\") then\n                    local Cr = string.sub(rb,2,2)\n                    local sSide = string.sub(rb,1,1)\n                    local sobj = oScreen[x][y]\n                    if sobj.space == true then\n                        tScreen[x][y].robot = \"zz\"\n                        if not sSide == \"g\" then\n                            addRobot(x,y,\"g\",Cr)\n                        end\n                    elseif sobj.exit == Cr then\n                        if sSide == \"a\" or sSide == \"b\" or sSide == \"c\" or sSide == \"d\" then\n                        tScreen[x][y].robot = \"zz\"\n                        addRobot(x,y,\"g\",Cr)\n                        aExits = aExits-1\n                        end\n                    elseif sSide == \"a\" then\n                        local obj = isBrick(x,y-1)\n                        tScreen[x][y].robot = \"zz\"\n                        if not obj == true then\n                            addRobot(x,y-1,sSide,Cr)\n                        else\n                            local obj2 = isBrick(x-1,y)\n                            local obj3 = isBrick(x+1,y)\n                            if not obj2 == true and not obj3 == true then\n                                if Cr == \"a\" then\n                                    addRobot(x,y,\"d\",Cr)\n                                elseif Cr == \"b\" then\n                                    addRobot(x,y,\"b\",Cr)\n                                end\n                            elseif obj == true and obj2 == true and obj3 == true then\n                                addRobot(x,y,\"c\",Cr)\n                            else\n                                if obj3 == true then\n                                    addRobot(x,y,\"d\",Cr)\n                                elseif obj2 == true then\n                                    addRobot(x,y,\"b\",Cr)\n                                end\n                            end\n                        end\n                    elseif sSide == \"b\" then\n                        local obj = isBrick(x+1,y)\n                        tScreen[x][y].robot = \"zz\"\n                        if not obj == true then\n                            addRobot(x+1,y,sSide,Cr)\n                        else\n                            local obj2 = isBrick(x,y-1)\n                            local obj3 = isBrick(x,y+1)\n                            if not obj2 == true and not obj3 == true then\n                                if Cr == \"a\" then\n                                    addRobot(x,y,\"a\",Cr)\n                                elseif Cr == \"b\" then\n                                    addRobot(x,y,\"c\",Cr)\n                                end\n                            elseif obj == true and obj2 == true and obj3 == true then\n                                addRobot(x,y,\"d\",Cr)\n                            else\n                                if obj3 == true then\n                                    addRobot(x,y,\"a\",Cr)\n                                elseif obj2 == true then\n                                    addRobot(x,y,\"c\",Cr)\n                                end\n                            end\n                        end\n                    elseif sSide == \"c\" then\n                        local obj = isBrick(x,y+1)\n                        tScreen[x][y].robot = \"zz\"\n                        if not obj == true then\n                            addRobot(x,y+1,sSide,Cr)\n                        else\n                            local obj2 = isBrick(x-1,y)\n                            local obj3 = isBrick(x+1,y)\n                            if not obj2 == true and not obj3 == true then\n                                if Cr == \"a\" then\n                                    addRobot(x,y,\"b\",Cr)\n                                elseif Cr == \"b\" then\n                                    addRobot(x,y,\"d\",Cr)\n                                end\n                            elseif obj == true and obj2 == true and obj3 == true then\n                                addRobot(x,y,\"a\",Cr)\n                            else\n                                if obj3 == true then\n                                    addRobot(x,y,\"d\",Cr)\n                                elseif obj2 == true then\n                                    addRobot(x,y,\"b\",Cr)\n                                end\n                            end\n                        end\n                    elseif sSide == \"d\" then\n                        local obj = isBrick(x-1,y)\n                        tScreen[x][y].robot = \"zz\"\n                        if not obj == true then\n                            addRobot(x-1,y,sSide,Cr)\n                        else\n                            local obj2 = isBrick(x,y-1)\n                            local obj3 = isBrick(x,y+1)\n                            if not obj2 == true and not obj3 == true then\n                                if Cr == \"a\" then\n                                    addRobot(x,y,\"c\",Cr)\n                                elseif Cr == \"b\" then\n                                    addRobot(x,y,\"a\",Cr)\n                                end\n                            elseif obj == true and obj2 == true and obj3 == true then\n                                addRobot(x,y,\"b\",Cr)\n                            else\n                                if obj3 == true then\n                                    addRobot(x,y,\"a\",Cr)\n                                elseif obj2 == true then\n                                    addRobot(x,y,\"c\",Cr)\n                                end\n                            end\n                        end\n                    else\n                        addRobot(x,y,sSide,\"g\")\n                    end\n                end\n            end\n        end\n    end\nend\n\nfunction InterFace.drawBar()\n    term.setBackgroundColor( colors.black )\n    term.setTextColor( InterFace.cTitle )\n    printCentred( 1, \"  \"..sLevelTitle..\"  \" )\n\n    term.setCursorPos(1,1)\n    term.setBackgroundColor( cW )\n    write( \" \" )\n    term.setBackgroundColor( colors.black )\n    write( \" x \"..tostring(Blocks)..\" \" )\n\n    term.setCursorPos( TermW-8,TermH )\n    term.setBackgroundColor( colors.black )\n    term.setTextColour(InterFace.cSpeedD)\n    write(\" <<\" )\n    if bPaused then\n        term.setTextColour(InterFace.cSpeedA)\n    else\n        term.setTextColour(InterFace.cSpeedD)\n    end\n    write(\" ||\")\n    if fSpeedS then\n        term.setTextColour(InterFace.cSpeedA)\n    else\n        term.setTextColour(InterFace.cSpeedD)\n    end\n    write(\" >>\")\n\n    term.setCursorPos( TermW-1, 1 )\n    term.setBackgroundColor( colors.black )\n    term.setTextColour( InterFace.cExit )\n    write(\" X\")\n    term.setBackgroundColor(colors.black)\nend\n\nfunction InterFace.render()\n    local id,p1,p2,p3 = os.pullEvent()\n    if id == \"mouse_click\" then\n        if p3 == 1 and p2 == TermW then\n            return \"end\"\n        elseif p3 == TermH and p2 >= TermW-7 and p2 <= TermW-6 then\n            return \"retry\"\n        elseif p3 == TermH and p2 >= TermW-4 and p2 <= TermW-3 then\n            bPaused = not bPaused\n            fSpeedS = false\n            Speed = (bPaused and 0) or nSpeed\n            if Speed > 0 then\n                Tick = os.startTimer(Speed)\n            else\n                Tick = nil\n            end\n            InterFace.drawBar()\n        elseif p3 == TermH and p2 >= TermW-1 then\n            bPaused = false\n            fSpeedS = not fSpeedS\n            Speed = (fSpeedS and fSpeed) or nSpeed\n            Tick = os.startTimer(Speed)\n            InterFace.drawBar()\n        elseif p3-1 < YOrgin+SizeH+1 and p3-1 > YOrgin and\n               p2 < XOrgin+SizeW+1 and p2 > XOrgin then\n            local eobj = tScreen[p2-XOrgin][p3-YOrgin-1]\n            local erobj = tostring(tScreen[p2-XOrgin][p3-YOrgin-1].robot)\n            if (erobj == \"zz\" or erobj == \"nil\") and not eobj.wall == true and not eobj.space == true and Blocks > 0 then\n                addWall(p2-XOrgin,p3-YOrgin-1)\n                Blocks = Blocks-1\n                InterFace.drawBar()\n                drawMap()\n            end\n        end\n    elseif id == \"timer\" and p1 == Tick then\n        gRender(\"tick\")\n        drawMap()\n        if Speed > 0 then\n            Tick = os.startTimer(Speed)\n        else\n            Tick = nil\n        end\n    end\nend\n\nlocal function startG(LevelN)\n    drawStars()\n    loadLevel(LevelN)\n    centerOrgin()\n    local create = true\n    drawMap()\n    InterFace.drawBar()\n    gRender(\"start\")\n    drawMap()\n\n    local NExit = true\n    if aExits == 0 then\n        NExit = false\n    end\n\n    while true do\n        local isExit = InterFace.render()\n        if isExit == \"end\" then\n            return nil\n        elseif isExit == \"retry\" then\n            return LevelN\n        elseif fExit == \"yes\" then\n            if fs.exists( fs.getDir( shell.getRunningProgram() ) .. \"/levels/\" .. tostring(LevelN + 1) .. \".dat\" ) then\n                return LevelN + 1\n            else\n                return nil\n            end\n        end\n        if aExits == 0 and NExit == true then\n            fExit = \"yes\"\n        end\n    end\nend\n\nlocal ok, err = true, nil\n\n--Menu--\nlocal sStartLevel = tArgs[1]\nif ok and not sStartLevel then\n    ok, err = pcall( function()\n        term.setTextColor(colors.white)\n        term.setBackgroundColor( colors.black )\n        term.clear()\n        drawStars()\n        term.setTextColor( colors.red )\n        printCentred( TermH/2 - 1, \"  REDIRECTION  \" )\n        printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\n        term.setTextColor( colors.yellow )\n        printCentred( TermH/2 + 2, \"  Click to Begin  \" )\n        os.pullEvent( \"mouse_click\" )\n    end )\nend\n\n--Game--\nif ok then\n    ok,err = pcall( function()\n        local nLevel\n        if sStartLevel then\n            nLevel = tonumber( sStartLevel )\n        else\n            nLevel = 1\n        end\n        while nLevel do\n            reset()\n            nLevel = startG(nLevel)\n        end\n    end )\nend\n\n--Upsell screen--\nif ok then\n    ok, err = pcall( function()\n        term.setTextColor(colors.white)\n        term.setBackgroundColor( colors.black )\n        term.clear()\n        drawStars()\n        term.setTextColor( colors.red )\n        if TermW >= 40 then\n            printCentred( TermH/2 - 1, \"  Thank you for playing Redirection  \" )\n            printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\n            printCentred( TermH/2 + 2, \"  Check out the full game:  \" )\n            term.setTextColor( colors.yellow )\n            printCentred( TermH/2 + 3, \"  http://www.redirectiongame.com  \" )\n        else\n            printCentred( TermH/2 - 2, \"  Thank you for  \" )\n            printCentred( TermH/2 - 1, \"  playing Redirection  \" )\n            printCentred( TermH/2 - 0, \"  ComputerCraft Edition  \" )\n            printCentred( TermH/2 + 2, \"  Check out the full game:  \" )\n            term.setTextColor( colors.yellow )\n            printCentred( TermH/2 + 3, \"  www.redirectiongame.com  \" )\n        end\n        parallel.waitForAll(\n            function() sleep(2) end,\n            function() os.pullEvent( \"mouse_click\" ) end\n        )\n    end )\nend\n\n--Clear and exit--\nterm.setCursorPos(1,1)\nterm.setTextColor(colors.white)\nterm.setBackgroundColor(colors.black)\nterm.clear()\nif not ok then\n    if err == \"Terminated\" then\n        print( \"Check out the full version of Redirection:\" )\n        print( \"http://www.redirectiongame.com\" )\n    else\n        printError( err )\n    end\nend"}},"shell.lua":"\nlocal multishell = multishell\nlocal parentShell = shell\nlocal parentTerm = term.current()\n\nif multishell then\n    multishell.setTitle( multishell.getCurrent(), \"shell\" )\nend\n\nlocal bExit = false\nlocal sDir = (parentShell and parentShell.dir()) or \"\"\nlocal sPath = (parentShell and parentShell.path()) or \".:/rom/programs\"\nlocal tAliases = (parentShell and parentShell.aliases()) or {}\nlocal tCompletionInfo = (parentShell and parentShell.getCompletionInfo()) or {}\nlocal tProgramStack = {}\n\nlocal shell = {}\nlocal function createShellEnv( sDir )\n    local tEnv = {}\n    tEnv[ \"shell\" ] = shell\n    tEnv[ \"multishell\" ] = multishell\n\n    local package = {}\n    package.loaded = {\n        _G = _G,\n        bit32 = bit32,\n        coroutine = coroutine,\n        math = math,\n        package = package,\n        string = string,\n        table = table,\n    }\n    package.path = \"?;?.lua;?/init.lua;/rom/modules/main/?;/rom/modules/main/?.lua;/rom/modules/main/?/init.lua\"\n    if turtle then\n        package.path = package.path..\";/rom/modules/turtle/?;/rom/modules/turtle/?.lua;/rom/modules/turtle/?/init.lua\"\n    elseif command then\n        package.path = package.path..\";/rom/modules/command/?;/rom/modules/command/?.lua;/rom/modules/command/?/init.lua\"\n    end\n    package.config = \"/\\n;\\n?\\n!\\n-\"\n    package.preload = {}\n    package.loaders = {\n        function( name )\n            if package.preload[name] then\n                return package.preload[name]\n            else\n                return nil, \"no field package.preload['\" .. name .. \"']\"\n            end\n        end,\n        function( name )\n            local fname = string.gsub(name, \"%.\", \"/\")\n            local sError = \"\"\n            for pattern in string.gmatch(package.path, \"[^;]+\") do\n                local sPath = string.gsub(pattern, \"%?\", fname)\n                if sPath:sub(1,1) ~= \"/\" then\n                    sPath = fs.combine(sDir, sPath)\n                end\n                if fs.exists(sPath) and not fs.isDir(sPath) then\n                    local fnFile, sError = loadfile( sPath, tEnv )\n                    if fnFile then\n                        return fnFile, sPath\n                    else\n                        return nil, sError\n                    end\n                else\n                    if #sError > 0 then\n                        sError = sError .. \"\\n  \"\n                    end\n                    sError = sError .. \"no file '\" .. sPath .. \"'\"\n                end\n            end\n            return nil, sError\n        end\n    }\n\n    local sentinel = {}\n    local function require( name )\n        if type( name ) ~= \"string\" then\n            error( \"bad argument #1 (expected string, got \" .. type( name ) .. \")\", 2 )\n        end\n        if package.loaded[name] == sentinel then\n            error(\"loop or previous error loading module '\" .. name .. \"'\", 0)\n        end\n        if package.loaded[name] then\n            return package.loaded[name]\n        end\n\n        local sError = \"module '\" .. name .. \"' not found:\"\n        for _, searcher in ipairs(package.loaders) do\n            local loader = table.pack(searcher(name))\n            if loader[1] then\n                package.loaded[name] = sentinel\n                local result = loader[1](name, table.unpack(loader, 2, loader.n))\n                if result == nil then result = true end\n\n                package.loaded[name] = result\n                return result\n            else\n                sError = sError .. \"\\n  \" .. loader[2]\n            end\n        end\n        error(sError, 2)\n    end\n\n    tEnv[\"package\"] = package\n    tEnv[\"require\"] = require\n\n    return tEnv\nend\n\n-- Colours\nlocal promptColour, textColour, bgColour\nif term.isColour() then\n    promptColour = colours.yellow\n    textColour = colours.white\n    bgColour = colours.black\nelse\n    promptColour = colours.white\n    textColour = colours.white\n    bgColour = colours.black\nend\n\nlocal function run( _sCommand, ... )\n    local sPath = shell.resolveProgram( _sCommand )\n    if sPath ~= nil then\n        tProgramStack[#tProgramStack + 1] = sPath\n        if multishell then\n            local sTitle = fs.getName( sPath )\n            if sTitle:sub(-4) == \".lua\" then\n                sTitle = sTitle:sub(1,-5)\n            end\n            multishell.setTitle( multishell.getCurrent(), sTitle )\n        end\n        local sDir = fs.getDir( sPath )\n        local result = os.run( createShellEnv( sDir ), sPath, ... )\n        tProgramStack[#tProgramStack] = nil\n        if multishell then\n            if #tProgramStack > 0 then\n                local sTitle = fs.getName( tProgramStack[#tProgramStack] )\n                if sTitle:sub(-4) == \".lua\" then\n                    sTitle = sTitle:sub(1,-5)\n                end\n                multishell.setTitle( multishell.getCurrent(), sTitle )\n            else\n                multishell.setTitle( multishell.getCurrent(), \"shell\" )\n            end\n        end\n        return result\n       else\n        printError( \"No such program\" )\n        return false\n    end\nend\n\nlocal function tokenise( ... )\n    local sLine = table.concat( { ... }, \" \" )\n    local tWords = {}\n    local bQuoted = false\n    for match in string.gmatch( sLine .. \"\\\"\", \"(.-)\\\"\" ) do\n        if bQuoted then\n            table.insert( tWords, match )\n        else\n            for m in string.gmatch( match, \"[^ \\t]+\" ) do\n                table.insert( tWords, m )\n            end\n        end\n        bQuoted = not bQuoted\n    end\n    return tWords\nend\n\n-- Install shell API\nfunction shell.run( ... )\n    local tWords = tokenise( ... )\n    local sCommand = tWords[1]\n    if sCommand then\n        return run( sCommand, table.unpack( tWords, 2 ) )\n    end\n    return false\nend\n\nfunction shell.exit()\n    bExit = true\nend\n\nfunction shell.dir()\n    return sDir\nend\n\nfunction shell.setDir( _sDir )\n    if type( _sDir ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sDir ) .. \")\", 2 )\n    end\n    if not fs.isDir( _sDir ) then\n        error( \"Not a directory\", 2 )\n    end\n    sDir = _sDir\nend\n\nfunction shell.path()\n    return sPath\nend\n\nfunction shell.setPath( _sPath )\n    if type( _sPath ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sPath ) .. \")\", 2 )\n    end\n    sPath = _sPath\nend\n\nfunction shell.resolve( _sPath )\n    if type( _sPath ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sPath ) .. \")\", 2 )\n    end\n    local sStartChar = string.sub( _sPath, 1, 1 )\n    if sStartChar == \"/\" or sStartChar == \"\\\\\" then\n        return fs.combine( \"\", _sPath )\n    else\n        return fs.combine( sDir, _sPath )\n    end\nend\n\nlocal function pathWithExtension( _sPath, _sExt )\n    local nLen = #sPath\n    local sEndChar = string.sub( _sPath, nLen, nLen )\n    -- Remove any trailing slashes so we can add an extension to the path safely\n    if sEndChar == \"/\" or sEndChar == \"\\\\\" then\n        _sPath = string.sub( _sPath, 1, nLen - 1 )\n    end\n    return _sPath .. \".\" .. _sExt\nend\n\nfunction shell.resolveProgram( _sCommand )\n    if type( _sCommand ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sCommand ) .. \")\", 2 )\n    end\n    -- Substitute aliases firsts\n    if tAliases[ _sCommand ] ~= nil then\n        _sCommand = tAliases[ _sCommand ]\n    end\n\n    -- If the path is a global path, use it directly\n    if _sCommand:find(\"/\") or _sCommand:find(\"\\\\\") then\n        local sPath = shell.resolve( _sCommand )\n        if fs.exists( sPath ) and not fs.isDir( sPath ) then\n            return sPath\n        else\n            local sPathLua = pathWithExtension( sPath, \"lua\" )\n            if fs.exists( sPathLua ) and not fs.isDir( sPathLua ) then\n                return sPathLua\n            end\n        end\n        return nil\n    end\n\n     -- Otherwise, look on the path variable\n    for sPath in string.gmatch(sPath, \"[^:]+\") do\n        sPath = fs.combine( shell.resolve( sPath ), _sCommand )\n        if fs.exists( sPath ) and not fs.isDir( sPath ) then\n            return sPath\n        else\n            local sPathLua = pathWithExtension( sPath, \"lua\" )\n            if fs.exists( sPathLua ) and not fs.isDir( sPathLua ) then\n                return sPathLua\n            end\n        end\n    end\n\n    -- Not found\n    return nil\nend\n\nfunction shell.programs( _bIncludeHidden )\n    local tItems = {}\n\n    -- Add programs from the path\n    for sPath in string.gmatch(sPath, \"[^:]+\") do\n        sPath = shell.resolve( sPath )\n        if fs.isDir( sPath ) then\n            local tList = fs.list( sPath )\n            for n=1,#tList do\n                local sFile = tList[n]\n                if not fs.isDir( fs.combine( sPath, sFile ) ) and\n                   (_bIncludeHidden or string.sub( sFile, 1, 1 ) ~= \".\") then\n                    if #sFile > 4 and sFile:sub(-4) == \".lua\" then\n                        sFile = sFile:sub(1,-5)\n                    end\n                    tItems[ sFile ] = true\n                end\n            end\n        end\n    end\n\n    -- Sort and return\n    local tItemList = {}\n    for sItem, b in pairs( tItems ) do\n        table.insert( tItemList, sItem )\n    end\n    table.sort( tItemList )\n    return tItemList\nend\n\nlocal function completeProgram( sLine )\n    if #sLine > 0 and (sLine:find(\"/\") or sLine:find(\"\\\\\")) then\n        -- Add programs from the root\n        return fs.complete( sLine, sDir, true, false )\n\n    else\n        local tResults = {}\n        local tSeen = {}\n\n        -- Add aliases\n        for sAlias, sCommand in pairs( tAliases ) do\n            if #sAlias > #sLine and string.sub( sAlias, 1, #sLine ) == sLine then\n                local sResult = string.sub( sAlias, #sLine + 1 )\n                if not tSeen[ sResult ] then\n                    table.insert( tResults, sResult )\n                    tSeen[ sResult ] = true\n                end\n            end\n        end\n\n        -- Add all subdirectories. We don't include files as they will be added in the block below\n        local tDirs = fs.complete( sLine, sDir, false, false )\n        for i = 1, #tDirs do\n            local sResult = tDirs[i]\n            if not tSeen[ sResult ] then\n                table.insert ( tResults, sResult )\n                tSeen [ sResult ] = true\n            end\n        end\n\n        -- Add programs from the path\n        local tPrograms = shell.programs()\n        for n=1,#tPrograms do\n            local sProgram = tPrograms[n]\n            if #sProgram > #sLine and string.sub( sProgram, 1, #sLine ) == sLine then\n                local sResult = string.sub( sProgram, #sLine + 1 )\n                if not tSeen[ sResult ] then\n                    table.insert( tResults, sResult )\n                    tSeen[ sResult ] = true\n                end\n            end\n        end\n\n        -- Sort and return\n        table.sort( tResults )\n        return tResults\n    end\nend\n\nlocal function completeProgramArgument( sProgram, nArgument, sPart, tPreviousParts )\n    local tInfo = tCompletionInfo[ sProgram ]\n    if tInfo then\n        return tInfo.fnComplete( shell, nArgument, sPart, tPreviousParts )\n    end\n    return nil\nend\n\nfunction shell.complete( sLine )\n    if type( sLine ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sLine ) .. \")\", 2 )\n    end\n    if #sLine > 0 then\n        local tWords = tokenise( sLine )\n        local nIndex = #tWords\n        if string.sub( sLine, #sLine, #sLine ) == \" \" then\n            nIndex = nIndex + 1\n        end\n        if nIndex == 1 then\n            local sBit = tWords[1] or \"\"\n            local sPath = shell.resolveProgram( sBit )\n            if tCompletionInfo[ sPath ] then\n                return { \" \" }\n            else\n                local tResults = completeProgram( sBit )\n                for n=1,#tResults do\n                    local sResult = tResults[n]\n                    local sPath = shell.resolveProgram( sBit .. sResult )\n                    if tCompletionInfo[ sPath ] then\n                        tResults[n] = sResult .. \" \"\n                    end\n                end\n                return tResults\n            end\n\n        elseif nIndex > 1 then\n            local sPath = shell.resolveProgram( tWords[1] )\n            local sPart = tWords[nIndex] or \"\"\n            local tPreviousParts = tWords\n            tPreviousParts[nIndex] = nil\n            return completeProgramArgument( sPath , nIndex - 1, sPart, tPreviousParts )\n\n        end\n    end\n    return nil\nend\n\nfunction shell.completeProgram( sProgram )\n    if type( sProgram ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sProgram ) .. \")\", 2 )\n    end\n    return completeProgram( sProgram )\nend\n\nfunction shell.setCompletionFunction( sProgram, fnComplete )\n    if type( sProgram ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( sProgram ) .. \")\", 2 )\n    end\n    if type( fnComplete ) ~= \"function\" then\n        error( \"bad argument #2 (expected function, got \" .. type( fnComplete ) .. \")\", 2 )\n    end\n    tCompletionInfo[ sProgram ] = {\n        fnComplete = fnComplete\n    }\nend\n\nfunction shell.getCompletionInfo()\n    return tCompletionInfo\nend\n\nfunction shell.getRunningProgram()\n    if #tProgramStack > 0 then\n        return tProgramStack[#tProgramStack]\n    end\n    return nil\nend\n\nfunction shell.setAlias( _sCommand, _sProgram )\n    if type( _sCommand ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sCommand ) .. \")\", 2 )\n    end\n    if type( _sProgram ) ~= \"string\" then\n        error( \"bad argument #2 (expected string, got \" .. type( _sProgram ) .. \")\", 2 )\n    end\n    tAliases[ _sCommand ] = _sProgram\nend\n\nfunction shell.clearAlias( _sCommand )\n    if type( _sCommand ) ~= \"string\" then\n        error( \"bad argument #1 (expected string, got \" .. type( _sCommand ) .. \")\", 2 )\n    end\n    tAliases[ _sCommand ] = nil\nend\n\nfunction shell.aliases()\n    -- Copy aliases\n    local tCopy = {}\n    for sAlias, sCommand in pairs( tAliases ) do\n        tCopy[sAlias] = sCommand\n    end\n    return tCopy\nend\n\nif multishell then\n    function shell.openTab( ... )\n        local tWords = tokenise( ... )\n        local sCommand = tWords[1]\n        if sCommand then\n            local sPath = shell.resolveProgram( sCommand )\n            if sPath == \"rom/programs/shell.lua\" then\n                return multishell.launch( createShellEnv( \"rom/programs\" ), sPath, table.unpack( tWords, 2 ) )\n            elseif sPath ~= nil then\n                return multishell.launch( createShellEnv( \"rom/programs\" ), \"rom/programs/shell.lua\", sCommand, table.unpack( tWords, 2 ) )\n            else\n                printError( \"No such program\" )\n            end\n        end\n    end\n\n    function shell.switchTab( nID )\n        if type( nID ) ~= \"number\" then\n            error( \"bad argument #1 (expected number, got \" .. type( nID ) .. \")\", 2 )\n        end\n        multishell.setFocus( nID )\n    end\nend\n\nlocal tArgs = { ... }\nif #tArgs > 0 then\n    -- \"shell x y z\"\n    -- Run the program specified on the commandline\n    shell.run( ... )\n\nelse\n    -- \"shell\"\n    -- Print the header\n    term.setBackgroundColor( bgColour )\n    term.setTextColour( promptColour )\n    print( os.version() )\n    term.setTextColour( textColour )\n\n    -- Run the startup program\n    if parentShell == nil then\n        shell.run( \"/rom/startup.lua\" )\n    end\n\n    -- Read commands and execute them\n    local tCommandHistory = {}\n    while not bExit do\n        term.redirect( parentTerm )\n        term.setBackgroundColor( bgColour )\n        term.setTextColour( promptColour )\n        write( shell.dir() .. \"> \" )\n        term.setTextColour( textColour )\n\n\n        local sLine\n        if settings.get( \"shell.autocomplete\" ) then\n            sLine = read( nil, tCommandHistory, shell.complete )\n        else\n            sLine = read( nil, tCommandHistory )\n        end\n        if sLine:match(\"%S\") and tCommandHistory[#tCommandHistory] ~= sLine then\n            table.insert( tCommandHistory, sLine )\n        end\n        shell.run( sLine )\n    end\nend","peripherals.lua":"local tPeripherals = peripheral.getNames()\nprint( \"Attached Peripherals:\" )\nif #tPeripherals > 0 then\n    for n=1,#tPeripherals do\n        local sPeripheral = tPeripherals[n]\n        print( sPeripheral .. \" (\" .. peripheral.getType( sPeripheral ) .. \")\" )\n    end\nelse\n    print( \"None\" )\nend","move.lua":"\nlocal tArgs = { ... }\nif #tArgs < 2 then\n    print( \"Usage: mv <source> <destination>\" )\n    return\nend\n\nlocal sSource = shell.resolve( tArgs[1] )\nlocal sDest = shell.resolve( tArgs[2] )\nlocal tFiles = fs.find( sSource )\nif #tFiles > 0 then\n    for n,sFile in ipairs( tFiles ) do\n        if fs.isDir( sDest ) then\n            fs.move( sFile, fs.combine( sDest, fs.getName(sFile) ) )\n        elseif #tFiles == 1 then\n            fs.move( sFile, sDest )\n        else\n            printError( \"Cannot overwrite file multiple times\" )\n            return\n        end\n    end\nelse\n    printError( \"No matching files\" )\nend","id.lua":"\nlocal sDrive = nil\nlocal tArgs = { ... }\nif #tArgs > 0 then\n    sDrive = tostring( tArgs[1] )\nend\n\nif sDrive == nil then\n    print( \"This is computer #\"..os.getComputerID() )\n\n    local label = os.getComputerLabel()\n    if label then\n        print( \"This computer is labelled \\\"\"..label..\"\\\"\" )\n    end\n\nelse\n    local bData = disk.hasData( sDrive )\n    if not bData then\n        print( \"No disk in drive \"..sDrive )\n        return\n    end\n\n    print( \"The disk is #\"..disk.getID( sDrive ) )\n\n    local label = disk.getLabel( sDrive )\n    if label then\n        print( \"The disk is labelled \\\"\"..label..\"\\\"\" )\n    end\nend","delete.lua":"\nlocal tArgs = { ... }\nif #tArgs < 1 then\n    print( \"Usage: rm <path>\" )\n    return\nend\n\nlocal sPath = shell.resolve( tArgs[1] )\nlocal tFiles = fs.find( sPath )\nif #tFiles > 0 then\n    for n,sFile in ipairs( tFiles ) do\n        fs.delete( sFile )\n    end\nelse\n    printError( \"No matching files\" )\nend"}}}
